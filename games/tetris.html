<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris</title>
    <style>
        /* =========================================
           1. VARIABLES Y RESET (PALETA NEO UI)
           ========================================= */
        :root {
            --bg-1: #10141B;
            --bg-2: #161C24;
            --panel: #1F2732;
            --accent: #4ADE80;     /* Verde suave */
            --accent-2: #60A5FA;   /* Azul suave */
            --danger: #F87171;     /* Rojo suave */
            --text-1: #E2E8F0;     /* Blanco humo */
            --text-2: #94A3B8;     /* Gris azulado */
            
            --font-main: "Inter", -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
            --shadow-soft: 0 10px 30px -10px rgba(0,0,0,0.5);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; 
            font-family: var(--font-main);
            background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
            color: var(--text-1);
            touch-action: none;
        }

        /* 2. FONDO ANIMADO SUTIL */
        #bg-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 0; opacity: 0.1; /* Reducido según instrucciones */
            pointer-events: none;
        }

        /* Contenedor Principal */
        #game-container {
            position: relative; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            touch-action: none;
        }

        /* 3. PANTALLAS Y OVERLAYS (Glassmorphism) */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column;
            align-items: center; justify-content: center; 
            z-index: 10;
            transition: opacity 0.25s ease;
        }
        .screen.active { display: flex; animation: fadeIn 0.3s ease-out; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .overlay { 
            background: rgba(16, 20, 27, 0.85); 
            backdrop-filter: blur(12px); 
            -webkit-backdrop-filter: blur(12px);
        }
        
        .overlay h2 { 
            font-size: 2.2rem; font-weight: 800; margin-bottom: 10px; 
            color: var(--text-1); letter-spacing: -0.5px;
            text-align: center;
        }

        .overlay p {
            font-size: 1.1rem; color: var(--text-2); margin-bottom: 30px;
        }

        /* 4. TIPOGRAFÍA Y TÍTULO */
        .title {
            font-size: 4rem; font-weight: 900; margin-bottom: 3rem;
            letter-spacing: -2px; display: flex; gap: 2px; z-index: 2;
            filter: drop-shadow(0 0 15px rgba(74, 222, 128, 0.2));
        }
        /* Colores clásicos pero suavizados para las letras */
        .t-let:nth-child(1) { color: #22d3ee; } 
        .t-let:nth-child(2) { color: #3b82f6; }
        .t-let:nth-child(3) { color: #fb923c; } 
        .t-let:nth-child(4) { color: #facc15; }
        .t-let:nth-child(5) { color: #4ade80; } 
        .t-let:nth-child(6) { color: #a855f7; }

        /* 5. BOTONES MODERNOS (Estilo App) */
        .btn {
            border: none;
            padding: 16px 32px; 
            font-size: 1.15rem; font-weight: 600; 
            border-radius: 14px;
            cursor: pointer; margin: 12px; 
            min-width: 200px;
            text-decoration: none; text-align: center;
            box-shadow: 0 4px 14px rgba(0,0,0,0.25);
            transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s;
            position: relative; overflow: hidden;
            letter-spacing: 0.5px;
        }
        .btn:active { transform: scale(0.96); box-shadow: 0 2px 8px rgba(0,0,0,0.15); }

        /* Botón Primario (Verde) */
        .btn-green { 
            background: linear-gradient(135deg, #4ADE80, #22C55E); 
            color: #064E3B; /* Texto oscuro para contraste */
        }
        
        /* Botón Secundario (Azul - Usado para niveles/continuar) */
        .btn-orange { 
            background: linear-gradient(135deg, #60A5FA, #3B82F6); 
            color: #EFF6FF; 
        }

        /* Botón Peligro/Salir */
        .btn-red { 
            background: linear-gradient(135deg, #F87171, #EF4444); 
            color: #FEF2F2; 
        }
        
        .pulse { animation: softPulse 3s infinite ease-in-out; }
        @keyframes softPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
        }

        /* 6. HUD (Cabecera del juego) */
        #game-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; flex-direction: column;
            padding: 15px; z-index: 20;
        }
        .hud-top {
            display: flex; justify-content: center; width: 100%;
            max-width: 420px; margin: 0 auto; gap: 12px; pointer-events: auto;
        }
        .hud-box {
            background: var(--glass-bg);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: var(--glass-border);
            border-radius: 14px;
            display: flex; flex-direction: column; flex: 1; 
            text-align: center; padding: 8px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .hud-label {
            font-size: 0.7rem; color: var(--text-2); 
            font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
            margin-bottom: 2px;
        }
        .hud-value { font-size: 1.3rem; font-weight: 700; color: var(--text-1); }
        
        /* Botón Pausa (Circular) */
        #btn-pause {
            position: absolute; top: 20px; right: 20px; width: 44px; height: 44px;
            background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; pointer-events: auto; cursor: pointer; z-index: 50;
            color: var(--text-1);
            transition: background 0.2s;
        }
        #btn-pause:active { background: rgba(255,255,255,0.2); }

        /* 7. CANVAS DEL JUEGO */
        #tetris-canvas {
            display: block; margin: auto;
            border-radius: 14px; /* Bordes del tablero */
            box-shadow: 0 0 40px rgba(0,0,0,0.65); /* Sombra elegante */
            background: linear-gradient(180deg, #0f141a, #161c24); /* Fondo sutil */
            touch-action: none;
        }

        /* 8. MENÚ LATERAL (DRAWER) ESTILO iOS */
        #drawer-toggle {
            position: absolute; top: 20px; left: 20px; font-size: 1.5rem;
            cursor: pointer; z-index: 100; color: var(--text-1);
            width: 44px; height: 44px; text-align: center; line-height: 44px;
            background: rgba(255,255,255,0.05); border-radius: 12px; 
            backdrop-filter: blur(5px); display: block; 
        }
        #drawer-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(2px);
            z-index: 101; display: none; opacity: 0; transition: opacity 0.3s;
        }
        #drawer-overlay.visible { display: block; opacity: 1; }
        
        #drawer {
            position: fixed; top: 0; left: -340px; width: 300px; height: 100%;
            background: var(--panel); 
            border-right: 1px solid rgba(255,255,255,0.08);
            border-radius: 0 24px 24px 0;
            transition: left 0.35s cubic-bezier(0.2, 0.8, 0.2, 1); 
            z-index: 102; padding: 25px; 
            overflow-y: auto; 
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column;
        }
        #drawer.open { left: 0; }

        .drawer-top-bar {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 30px; padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .drawer-close-btn { 
            font-size: 1.2rem; cursor: pointer; color: var(--text-2); 
            padding: 8px; border-radius: 50%; background: rgba(0,0,0,0.2);
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
        }

        .drawer-section { margin-bottom: 30px; }
        .drawer-header { 
            font-size: 0.85rem; margin-bottom: 15px; 
            color: var(--accent); font-weight: 700; 
            letter-spacing: 1.2px; text-transform: uppercase;
        }
        
        .setting-row { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 18px; color: var(--text-1); font-size: 0.95rem;
        }

        /* Switches estilo iOS con CSS Puro */
        input[type="checkbox"] {
            appearance: none; -webkit-appearance: none;
            width: 42px; height: 24px;
            background: #334155;
            border-radius: 50px;
            position: relative; cursor: pointer;
            transition: background 0.3s;
            outline: none;
        }
        input[type="checkbox"]::after {
            content: ''; position: absolute;
            top: 2px; left: 2px;
            width: 20px; height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(18px); }

        /* Slider de sensibilidad */
        input[type="range"] {
            width: 100%; height: 4px; background: #334155;
            border-radius: 2px; appearance: none; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 18px; height: 18px;
            background: var(--accent); border-radius: 50%;
            cursor: pointer; box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }

        /* Grid de Niveles */
        .level-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .lvl-btn {
            background: rgba(255,255,255,0.03); 
            border: 1px solid rgba(255,255,255,0.05);
            color: var(--text-2); padding: 12px 0; border-radius: 10px; cursor: pointer;
            font-size: 0.9rem; text-align: center; font-weight: 600;
            transition: all 0.2s;
        }
        .lvl-btn:disabled { opacity: 0.2; cursor: not-allowed; }
        .lvl-btn.unlocked { 
            background: rgba(96, 165, 250, 0.15); 
            border-color: rgba(96, 165, 250, 0.3); 
            color: var(--accent-2); 
        }
        .lvl-btn.completed { 
            background: var(--accent); 
            border-color: var(--accent);
            color: #064E3B; 
        }

        /* Next Piece Canvas */
        #next-canvas { 
            display: block; margin: 0 auto; 
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.3));
        }

    </style>
</head>
<body>

    <canvas id="bg-canvas"></canvas>

    <div id="drawer-toggle">☰</div>
    <div id="drawer-overlay"></div>

    <aside id="drawer">
        <div class="drawer-top-bar">
            <span style="font-weight:800; font-size:1.4rem; color:var(--text-1);">Ajustes</span>
            <div class="drawer-close-btn" id="drawer-close">✕</div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Sistema</div>
            <div class="setting-row">
                <span>Música</span>
                <input type="checkbox" id="toggle-music" checked>
            </div>
            <div class="setting-row">
                <span>Efectos de Sonido</span>
                <input type="checkbox" id="toggle-sfx" checked>
            </div>
            <div class="setting-row">
                <span style="opacity:0.5; text-decoration:line-through;">Vibración (Off)</span>
                <input type="checkbox" id="toggle-haptics" disabled>
            </div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Juego</div>
            <div class="setting-row">
                <span>Pieza Fantasma</span>
                <input type="checkbox" id="toggle-ghost" checked>
            </div>
            <div class="setting-row" style="flex-direction:column; align-items:flex-start;">
                <div style="display:flex; justify-content:space-between; width:100%; margin-bottom:8px;">
                    <span>Sensibilidad Touch</span>
                    <span id="sens-val" style="color:var(--accent)">5</span>
                </div>
                <input type="range" id="slider-sens" min="1" max="10" value="5">
            </div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Niveles</div>
            <div class="level-grid" id="level-grid"></div>
        </div>
        
        <div style="margin-top:auto; font-size:0.75rem; color:var(--text-2); text-align:center; padding-top:20px;">
            Tetris Neo UI v2.0
        </div>
    </aside>

    <div id="game-container">
        <div id="screen-start" class="screen active">
            <div class="title">
                <span class="t-let">T</span><span class="t-let">E</span><span class="t-let">T</span><span class="t-let">R</span><span class="t-let">I</span><span class="t-let">S</span>
            </div>
            <p style="color:var(--text-2); margin-bottom:30px; letter-spacing:2px; font-size:0.9rem;">NEO ARCADE EDITION</p>
            
            <button id="btn-start" class="btn btn-green pulse">JUGAR NIVEL 1</button>
            <a href="../index.html" class="btn btn-red">SALIR</a>
        </div>

        <div id="screen-game" class="screen">
            <div id="game-ui">
                <div class="hud-top">
                    <div class="hud-box">
                        <div class="hud-label">MOVS</div>
                        <div class="hud-value" id="hud-moves">0</div>
                    </div>
                    <div class="hud-box" style="flex:2;">
                        <div class="hud-label" id="hud-obj-label">OBJETIVO</div>
                        <div class="hud-value" id="hud-obj-val">--</div>
                    </div>
                    <div class="hud-box">
                        <div class="hud-label">SIG</div>
                        <canvas id="next-canvas" width="60" height="60"></canvas>
                    </div>
                </div>
                <div id="btn-pause">||</div>
            </div>
            <canvas id="tetris-canvas"></canvas>
        </div>

        <div id="screen-pause" class="screen overlay">
            <h2>PAUSA</h2>
            <button id="btn-resume" class="btn btn-green">CONTINUAR</button>
            <button id="btn-quit-level" class="btn btn-orange">MENÚ PRINCIPAL</button>
        </div>

        <div id="screen-gameover" class="screen overlay">
            <h2 style="color:var(--danger)">GAME OVER</h2>
            <p id="go-reason">Inténtalo de nuevo</p>
            <button id="btn-retry" class="btn btn-green">REINTENTAR</button>
            <button id="btn-go-menu" class="btn btn-red">SALIR</button>
        </div>

        <div id="screen-win" class="screen overlay">
            <h2 style="color:var(--accent)">¡NIVEL COMPLETADO!</h2>
            <div style="text-align:center; margin-bottom:30px;">
                <p style="font-size:1.3rem; margin-bottom:5px; color:var(--text-1);">Puntuación: <span id="win-score" style="font-weight:800;">0</span></p>
                <p style="color:var(--accent-2); font-size:1rem;">Monedas: +<span id="win-coins">0</span></p>
            </div>
            <button id="btn-next-level" class="btn btn-green">SIGUIENTE</button>
            <button id="btn-win-menu" class="btn btn-orange">MENÚ</button>
        </div>
    </div>

    <audio id="bg-music" src="../assets/music/retro-arcade-game-music-297305.mp3" loop></audio>

    <script>
        const CONFIG = {
            GRID_W: 10, GRID_H: 20, CELL_SIZE: 30, 
            STORAGE_KEY: "tetris_progress_v2", SETTINGS_KEY: "tetris_settings_v2",
            DROP_INTERVAL: 1000
        };

        // Paleta de colores actualizada para las piezas (Más vibrantes para contrastar con el fondo oscuro)
        const COLORS = {
            I: "#22d3ee", J: "#3b82f6", L: "#fb923c", O: "#facc15",
            S: "#4ade80", T: "#a855f7", Z: "#f87171",
            GHOST: "rgba(255, 255, 255, 0.1)", 
            // Colores de tablero modificados para diseño Neo
            BG_DARK: "transparent", BG_LIGHT: "transparent" 
        };

        const SHAPES = {
            I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
            J: [[1,0,0], [1,1,1], [0,0,0]],
            L: [[0,0,1], [1,1,1], [0,0,0]],
            O: [[1,1], [1,1]],
            S: [[0,1,1], [1,1,0], [0,0,0]],
            T: [[0,1,0], [1,1,1], [0,0,0]],
            Z: [[1,1,0], [0,1,1], [0,0,0]]
        };
        const SHAPE_KEYS = Object.keys(SHAPES);

        const LEVELS = [
            { id:1,  name:"Nivel 1", obj:{type:"lines", val:5},   moves:50,  coins:5 }, 
            { id:2,  name:"Nivel 2", obj:{type:"points", val:2000}, moves:60,  coins:10 },
            { id:3,  name:"Nivel 3", obj:{type:"lines", val:10},  moves:70,  coins:15 },
            { id:4,  name:"Nivel 4", obj:{type:"points", val:5000}, moves:80, coins:20 },
            { id:5,  name:"Nivel 5", obj:{type:"lines", val:15},  moves:90, coins:25 },
            { id:6,  name:"Nivel 6", obj:{type:"points", val:10000}, moves:100, coins:30 },
            { id:7,  name:"Nivel 7", obj:{type:"lines", val:20},  moves:110, coins:40 },
            { id:8,  name:"Nivel 8", obj:{type:"points", val:20000}, moves:120, coins:50 },
            { id:9,  name:"Nivel 9", obj:{type:"lines", val:30},  moves:140, coins:75 },
            { id:10, name:"MAESTRO", obj:{type:"lines", val:40},  moves:160, coins:100 }
        ];

        let canvas, ctx, nextCanvas, nextCtx, bgCanvas, bgCtx;
        
        let lastTime = 0;
        let dropCounter = 0;
        let currentLevelIdx = 0;
        
        let isPaused = false;
        let gameActive = false;
        
        let grid = [];
        let player = { matrix: null, pos: {x:0, y:0}, type: null, score: 0, lines: 0, movesLeft: 0, objRemaining: 0 };
        let nextPieceType = null;
        let particles = [];
        
        let settings = { music: true, sfx: true, ghost: true, touchSens: 5, haptics: false }; // Haptics false por defecto
        let progress = { unlocked: [1], coins: 0, scores: {}, rewardsClaimed: [] };

        let audioCtx = null;
        let gainMaster = null;

        window.onload = () => {
            initDOM();
            loadStorage();
            initAudioSystem();
            initBgAnimation();
            resize();
            window.addEventListener('resize', resize);
            renderMenuLevels();
        };

        function initDOM() {
            canvas = document.getElementById('tetris-canvas');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('next-canvas');
            nextCtx = nextCanvas.getContext('2d');
            
            document.getElementById('drawer-toggle').onclick = toggleDrawer;
            document.getElementById('drawer-close').onclick = toggleDrawer;
            document.getElementById('drawer-overlay').onclick = toggleDrawer;

            document.getElementById('btn-start').onclick = () => startGame(currentLevelIdx);
            
            document.getElementById('btn-pause').onclick = togglePause;
            document.getElementById('btn-resume').onclick = togglePause;
            document.getElementById('btn-quit-level').onclick = showMainMenu;
            
            document.getElementById('btn-retry').onclick = () => startGame(currentLevelIdx);
            document.getElementById('btn-go-menu').onclick = showMainMenu;
            
            document.getElementById('btn-next-level').onclick = () => {
                if(currentLevelIdx < LEVELS.length -1) startGame(currentLevelIdx + 1);
                else showMainMenu();
            };
            document.getElementById('btn-win-menu').onclick = showMainMenu;

            document.getElementById('toggle-music').onchange = (e) => { settings.music = e.target.checked; updateMusicState(); saveSettings(); };
            document.getElementById('toggle-sfx').onchange = (e) => { settings.sfx = e.target.checked; saveSettings(); };
            document.getElementById('toggle-ghost').onchange = (e) => { settings.ghost = e.target.checked; saveSettings(); };
            
            // Haptics toggle disabled logic
            document.getElementById('toggle-haptics').onchange = (e) => { 
                settings.haptics = false; // Forzado a false
                e.target.checked = false; 
                saveSettings(); 
            };
            
            const slider = document.getElementById('slider-sens');
            slider.oninput = (e) => {
                settings.touchSens = parseInt(e.target.value);
                document.getElementById('sens-val').innerText = settings.touchSens;
                saveSettings();
            };
            
            document.addEventListener('keydown', handleKey);
            setupTouch(canvas);
            document.body.addEventListener('click', enableAudioGlobal, { once: true });
            document.body.addEventListener('touchstart', enableAudioGlobal, { once: true });
        }

        function enableAudioGlobal() {
            if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            updateMusicState();
        }

        function loadStorage() {
            const savedSet = localStorage.getItem(CONFIG.SETTINGS_KEY);
            if(savedSet) {
                settings = Object.assign(settings, JSON.parse(savedSet));
                document.getElementById('toggle-music').checked = settings.music;
                document.getElementById('toggle-sfx').checked = settings.sfx;
                document.getElementById('toggle-ghost').checked = settings.ghost;
                // Forzar haptics a apagado visualmente
                document.getElementById('toggle-haptics').checked = false; 
                settings.haptics = false;
                
                document.getElementById('slider-sens').value = settings.touchSens;
                document.getElementById('sens-val').innerText = settings.touchSens;
            }
            const savedProg = localStorage.getItem(CONFIG.STORAGE_KEY);
            if(savedProg) progress = Object.assign(progress, JSON.parse(savedProg));

            const maxUnlocked = Math.max(...progress.unlocked);
            const nextLvl = LEVELS.find(l => l.id === maxUnlocked);
            if(nextLvl) {
                currentLevelIdx = LEVELS.indexOf(nextLvl);
                document.getElementById('btn-start').innerText = "JUGAR " + nextLvl.name;
            }
        }

        function saveSettings() { localStorage.setItem(CONFIG.SETTINGS_KEY, JSON.stringify(settings)); }
        function saveProgress() { localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(progress)); }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const containerH = window.innerHeight;
            const containerW = window.innerWidth;
            
            let cellSize = Math.floor((containerH * 0.75) / CONFIG.GRID_H);
            if(cellSize * CONFIG.GRID_W > containerW * 0.9) cellSize = Math.floor((containerW * 0.9) / CONFIG.GRID_W);
            CONFIG.CELL_SIZE = cellSize;

            const w = CONFIG.GRID_W * CONFIG.CELL_SIZE;
            const h = CONFIG.GRID_H * CONFIG.CELL_SIZE;

            canvas.width = w * dpr; canvas.height = h * dpr;
            canvas.style.width = w + "px"; canvas.style.height = h + "px";
            ctx.resetTransform(); ctx.scale(dpr, dpr);

            const bgC = document.getElementById('bg-canvas');
            bgC.width = containerW * dpr; bgC.height = containerH * dpr;
            bgC.style.width = containerW + "px"; bgC.style.height = containerH + "px";
            const bgCtx = bgC.getContext('2d');
            bgCtx.scale(dpr, dpr);
            
            if(!gameActive) draw(); 
        }

        // ============================================
        // RENDERIZADO VISUAL ACTUALIZADO (NEO UI)
        // ============================================
        function draw() {
            // Fondo limpio (sin cuadricula alternada, solo color sólido del CSS + canvas transparente)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawMatrix(grid, {x:0, y:0});

            if(gameActive && !isPaused && player.matrix) {
                if(settings.ghost) {
                    const ghostPos = { ...player.pos };
                    while(!collide(grid, {matrix:player.matrix, pos:ghostPos})) ghostPos.y++;
                    ghostPos.y--;
                    ctx.globalAlpha = 0.25; // Fantasma más sutil
                    drawMatrix(player.matrix, ghostPos, true);
                    ctx.globalAlpha = 1.0;
                }
                drawMatrix(player.matrix, player.pos);
            }

            // Partículas
            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
                // Partículas redondas
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        function drawMatrix(matrix, offset, isGhost = false) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const drawX = (x + offset.x) * CONFIG.CELL_SIZE;
                        const drawY = (y + offset.y) * CONFIG.CELL_SIZE;
                        const size = CONFIG.CELL_SIZE;
                        const pad = 2; // Padding entre bloques
                        
                        if(isGhost) {
                            // Estilo Ghost: Borde solamente
                            ctx.strokeStyle = COLORS[value]; 
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.roundRect(drawX + pad, drawY + pad, size - pad*2, size - pad*2, 4);
                            ctx.stroke();
                        } else {
                            // Estilo Bloque Neo: Redondeado + Brillo
                            ctx.fillStyle = COLORS[value];
                            
                            // 1. Base shape rounded
                            ctx.beginPath();
                            ctx.roundRect(drawX + pad, drawY + pad, size - pad*2, size - pad*2, 6);
                            ctx.fill();

                            // 2. Brillo superior (Overlay)
                            ctx.fillStyle = "rgba(255,255,255,0.2)";
                            ctx.beginPath();
                            ctx.roundRect(drawX + pad, drawY + pad, size - pad*2, (size - pad*2) * 0.4, [6, 6, 0, 0]);
                            ctx.fill();

                            // 3. Sombra interna sutil (simulada con borde oscuro semitransparente abajo)
                            ctx.fillStyle = "rgba(0,0,0,0.1)";
                            ctx.beginPath();
                            ctx.roundRect(drawX + pad, drawY + size - 8, size - pad*2, 6, [0, 0, 6, 6]);
                            ctx.fill();
                        }
                    }
                });
            });
        }
        
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            if(!nextPieceType) return;
            const matrix = SHAPES[nextPieceType];
            const boxSize = 12; // Un poco más grande para visibilidad
            const w = matrix[0].length * boxSize;
            const h = matrix.length * boxSize;
            const offX = (nextCanvas.width - w) / 2;
            const offY = (nextCanvas.height - h) / 2;
            
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if(val) {
                        nextCtx.fillStyle = COLORS[nextPieceType];
                        // Bloques mini redondeados
                        nextCtx.beginPath();
                        nextCtx.roundRect(offX + x*boxSize, offY + y*boxSize, boxSize-1, boxSize-1, 2);
                        nextCtx.fill();
                    }
                });
            });
        }

        // ============================================
        // LÓGICA DEL JUEGO (INTACTA)
        // ============================================

        function startGame(levelIndex) {
            currentLevelIdx = levelIndex;
            const lvlData = LEVELS[currentLevelIdx];
            grid = createGrid(CONFIG.GRID_W, CONFIG.GRID_H);
            player = {
                matrix: null, pos: {x:0, y:0}, type: null,
                score: 0, lines: 0,
                movesLeft: lvlData.moves,
                objRemaining: lvlData.obj.val
            };
            particles = [];
            isGameOver = false; isPaused = false; gameActive = true;
            nextPieceType = getRandomPiece();
            
            dropCounter = 0;
            
            playerReset();
            
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-game').classList.add('active');
            document.getElementById('game-ui').style.display = 'flex';
            document.getElementById('drawer-toggle').style.display = 'none';
            toggleDrawer(false);
            
            updateHUD();
            updateMusicState();
            
            lastTime = performance.now();
            requestAnimationFrame(update);
        }

        function createGrid(w, h) {
            const m = [];
            while (h--) m.push(new Array(w).fill(0));
            return m;
        }

        function update(time) {
            if(!gameActive || isPaused) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > CONFIG.DROP_INTERVAL) {
                playerDrop();
                dropCounter = 0;
            }
            
            if(particles.length > 300) particles.splice(0, particles.length - 300);
            updateParticles(deltaTime);

            draw();
            requestAnimationFrame(update);
        }

        function updateParticles(dt) {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= dt * 0.003;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function playerReset() {
            const piece = nextPieceType;
            nextPieceType = getRandomPiece();
            drawNextPiece();
            player.matrix = JSON.parse(JSON.stringify(SHAPES[piece]));
            player.type = piece;
            player.matrix.forEach((row, y) => row.forEach((val, x) => {
                if(val!==0) player.matrix[y][x] = piece; 
            }));
            player.pos.y = 0;
            player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(grid, player)) gameOver("Tablero bloqueado");
        }

        function getRandomPiece() { return SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)]; }

        function playerDrop() {
            player.pos.y++;
            if (collide(grid, player)) {
                player.pos.y--;
                merge(grid, player);
                playSound('drop');
                triggerHaptic(null); // Llamada muda
                decrementMoves();
                sweep();
                playerReset();
            }
        }
        
        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(grid, player)) {
                player.pos.x -= dir;
            } else {
                playSound('move');
            }
        }

        function playerRotate() {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix);
            while (collide(grid, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -1);
                    player.pos.x = pos;
                    return;
                }
            }
            playSound('rotate');
        }

        function rotate(matrix, dir = 1) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function collide(arena, p) {
            const m = p.matrix; const o = p.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(arena, p) {
            p.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + p.pos.y][x + p.pos.x] = value;
                });
            });
        }

        function sweep() {
            let rowCount = 0;
            outer: for (let y = grid.length -1; y > 0; --y) {
                for (let x = 0; x < grid[y].length; ++x) {
                    if (grid[y][x] === 0) continue outer;
                }
                const row = grid.splice(y, 1)[0].fill(0);
                grid.unshift(row);
                ++y;
                rowCount++;
                createExplosion(y * CONFIG.CELL_SIZE, CONFIG.GRID_W * CONFIG.CELL_SIZE);
            }
            if(rowCount > 0) {
                playSound('clear');
                triggerHaptic(null); // Llamada muda

                const points = rowCount * 1000 * rowCount;
                player.score += points;
                player.lines += rowCount;
                const lvl = LEVELS[currentLevelIdx];
                if(lvl.obj.type === 'lines') player.objRemaining -= rowCount;
                if(lvl.obj.type === 'points') player.objRemaining = lvl.obj.val - player.score;
                checkWin();
                updateHUD();
            }
        }
        
        function decrementMoves() {
            player.movesLeft--;
            updateHUD();
            if(player.movesLeft <= 0) gameOver("Sin movimientos");
        }

        function updateHUD() {
            const lvl = LEVELS[currentLevelIdx];
            document.getElementById('hud-moves').innerText = player.movesLeft;
            let val = Math.max(0, player.objRemaining);
            document.getElementById('hud-obj-val').innerText = (lvl.obj.type==='lines' ? val + " L" : val);
        }

        function createExplosion(y, width) {
            for(let i=0; i<30; i++) {
                particles.push({
                    x: Math.random() * width, y: y + Math.random() * 20,
                    vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                    life: 1.0, color: `hsl(${Math.random()*360}, 100%, 70%)`, size: Math.random() * 5 + 2
                });
            }
        }

        function checkWin() {
            if(player.objRemaining <= 0) {
                gameActive = false;
                const lvl = LEVELS[currentLevelIdx];
                const nextId = lvl.id + 1;
                let coinsWon = 0;
                if(!progress.rewardsClaimed.includes(lvl.id)) {
                    progress.rewardsClaimed.push(lvl.id);
                    progress.coins += lvl.coins;
                    coinsWon = lvl.coins;
                }
                if(!progress.unlocked.includes(nextId)) progress.unlocked.push(nextId);
                if(!progress.scores[lvl.id] || player.score > progress.scores[lvl.id]) progress.scores[lvl.id] = player.score;
                saveProgress();
                document.getElementById('win-score').innerText = player.score;
                document.getElementById('win-coins').innerText = coinsWon;
                document.getElementById('screen-win').classList.add('active');
                playSound('win');
            }
        }

        function gameOver(reason) {
            gameActive = false;
            document.getElementById('go-reason').innerText = reason;
            document.getElementById('screen-gameover').classList.add('active');
            playSound('lose');
            triggerHaptic(null); // Llamada muda
        }

        function handleKey(event) {
            if(!gameActive || isPaused) {
                if(event.key.toLowerCase() === 'p') togglePause();
                return;
            }
            if (event.keyCode === 37) playerMove(-1);
            else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop();
            else if (event.keyCode === 38) playerRotate();
            else if (event.keyCode === 32) hardDrop();
            else if (event.key.toLowerCase() === 'p') togglePause();
        }
        
        function hardDrop() {
            while (!collide(grid, player)) player.pos.y++;
            player.pos.y--;
            merge(grid, player);
            playSound('drop');
            triggerHaptic(null); // Llamada muda
            decrementMoves(); 
            createExplosion(player.pos.y * CONFIG.CELL_SIZE, CONFIG.GRID_W * CONFIG.CELL_SIZE);
            sweep();
            playerReset();
            dropCounter = 0;
        }

        // ===========================================
        // CONTROLES TÁCTILES (Con Bloqueo de Eje)
        // ===========================================
        function setupTouch(element) {
            let startX = 0, startY = 0;
            let lastX = 0;
            let touchAccumulatorX = 0;
            let isVerticalGesture = false;

            element.addEventListener('pointerdown', e => {
                if(!gameActive || isPaused) return;
                e.preventDefault();
                startX = e.clientX;
                startY = e.clientY;
                lastX = e.clientX;
                touchAccumulatorX = 0;
                isVerticalGesture = false; 
            }, {passive:false});

            element.addEventListener('pointermove', e => {
                if(!gameActive || isPaused || startX === 0) return;
                e.preventDefault();

                const totalDx = e.clientX - startX;
                const totalDy = e.clientY - startY;

                // DETECCIÓN DE EJE
                if (!isVerticalGesture) {
                    if (totalDy > 20 && totalDy > Math.abs(totalDx) * 1.5) {
                        isVerticalGesture = true;
                    }
                }

                if (isVerticalGesture) return; 

                const dx = e.clientX - lastX;
                lastX = e.clientX; 
                const sens = Math.max(10, 35 - (settings.touchSens * 2.5));
                touchAccumulatorX += dx;

                while(Math.abs(touchAccumulatorX) > sens) {
                    if(touchAccumulatorX > 0) {
                        playerMove(1);
                        touchAccumulatorX -= sens;
                    } else {
                        playerMove(-1);
                        touchAccumulatorX += sens;
                    }
                }
            });

            element.addEventListener('pointerup', e => {
                if(!gameActive || isPaused || startX === 0) return;
                
                const totalDx = e.clientX - startX;
                const totalDy = e.clientY - startY;
                
                if (isVerticalGesture && totalDy > 60) {
                    hardDrop();
                }
                else if (!isVerticalGesture && Math.abs(totalDx) < 20 && Math.abs(totalDy) < 30) {
                    playerRotate();
                }
                else if (totalDy > 50 && !isVerticalGesture) {
                     playerDrop();
                     dropCounter = 0;
                }
                
                startX = 0; startY = 0;
                isVerticalGesture = false;
            });
            
            element.addEventListener('pointerleave', () => { 
                startX = 0; isVerticalGesture = false; 
            });
        }
        
        // ===========================================
        // VIBRACIÓN ELIMINADA (FUNCIÓN VACÍA)
        // ===========================================
        function triggerHaptic(pattern) {
            return; // Eliminado por solicitud de diseño
        }

        function initAudioSystem() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            gainMaster = audioCtx.createGain();
            gainMaster.connect(audioCtx.destination);
            gainMaster.gain.value = 0.4;
        }

        function playSound(type) {
            if(!settings.sfx || !audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(gainMaster);

            switch(type) {
                case 'move':
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.05);
                    osc.start(now); osc.stop(now + 0.05);
                    break;
                case 'rotate':
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(600, now + 0.08);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.08);
                    osc.start(now); osc.stop(now + 0.08);
                    break;
                case 'drop':
                    osc.type = 'square'; osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                    break;
                case 'clear':
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
                    gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'lose':
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.8);
                    gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    break;
                 case 'win':
                    [523, 659, 784, 1046].forEach((f, i) => {
                        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                        o.connect(g); g.connect(gainMaster); o.type = 'triangle'; o.frequency.value = f;
                        g.gain.setValueAtTime(0.1, now + i*0.1); g.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.3);
                        o.start(now + i*0.1); o.stop(now + i*0.1 + 0.3);
                    });
                    break;
            }
        }

        function updateMusicState() {
            const musicEl = document.getElementById('bg-music');
            if(audioCtx && audioCtx.state === 'running' && settings.music) musicEl.play().catch(()=>{});
            else musicEl.pause();
        }

        function togglePause() {
            if(!gameActive) return;
            isPaused = !isPaused;
            const pScreen = document.getElementById('screen-pause');
            if(isPaused) pScreen.classList.add('active');
            else {
                pScreen.classList.remove('active');
                lastTime = performance.now(); 
                requestAnimationFrame(update);
            }
            updateMusicState();
        }

        function showMainMenu() {
            gameActive = false;
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-start').classList.add('active');
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('drawer-toggle').style.display = 'block';
            loadStorage();
            renderMenuLevels();
        }

        function toggleDrawer(forceOpen = null) {
            const d = document.getElementById('drawer');
            const o = document.getElementById('drawer-overlay');
            const isOpen = d.classList.contains('open');
            if(forceOpen === false || isOpen) {
                d.classList.remove('open'); o.classList.remove('visible');
            } else {
                d.classList.add('open'); o.classList.add('visible');
            }
        }

        function renderMenuLevels() {
            const container = document.getElementById('level-grid');
            container.innerHTML = '';
            LEVELS.forEach((lvl, idx) => {
                const btn = document.createElement('div');
                const isUnlocked = progress.unlocked.includes(lvl.id);
                const isCompleted = progress.scores[lvl.id] !== undefined;
                let cls = 'lvl-btn';
                if(isUnlocked) cls += ' unlocked';
                if(isCompleted) cls += ' completed'; 
                btn.className = cls; btn.innerText = lvl.id;
                if(isUnlocked) {
                    btn.onclick = () => { startGame(idx); toggleDrawer(false); };
                } else btn.setAttribute('disabled', true);
                container.appendChild(btn);
            });
        }
        
        function initBgAnimation() {
            bgCanvas = document.getElementById('bg-canvas');
            bgCtx = bgCanvas.getContext('2d');
            const shapes = [];
            const possibleShapes = Object.values(SHAPES);
            const dpr = window.devicePixelRatio || 1;
            for(let i=0; i<20; i++) { // Reducido numero de particulas fondo para look mas limpio
                shapes.push({
                    x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight,
                    speed: (0.01 + Math.random() * 0.04), scale: 1.0 + Math.random() * 1.0,
                    matrix: possibleShapes[Math.floor(Math.random()*possibleShapes.length)]
                });
            }
            function loop() {
                bgCtx.setTransform(1,0,0,1,0,0);
                bgCtx.clearRect(0,0,bgCanvas.width, bgCanvas.height);
                bgCtx.scale(dpr, dpr);
                bgCtx.fillStyle = "rgba(255,255,255,0.05)";
                shapes.forEach(s => {
                    s.x += s.speed;
                    if(s.x > window.innerWidth) s.x = -100; 
                    s.matrix.forEach((row, ry) => {
                        row.forEach((val, rx) => {
                            if(val) bgCtx.fillRect(s.x + rx * (10 * s.scale), s.y + ry * (10 * s.scale), (10 * s.scale), (10 * s.scale));
                        });
                    });
                });
                requestAnimationFrame(loop);
            }
            loop();
        }
    </script>
</body>
</html>
