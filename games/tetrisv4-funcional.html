<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Tetris estilo neo, para mi pareja.">
    
    <title>Tetris</title>
    <style>
        /* =========================================
           VARIABLES Y RESET
           ========================================= */
        :root {
            --bg-1: #10141B;
            --bg-2: #161C24;
            --panel: #1F2732;
            --accent: #4ADE80;
            --accent-2: #60A5FA;
            --danger: #F87171;
            --text-1: #E2E8F0;
            --text-2: #94A3B8;
            
            --font-main: "Inter", -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; 
            font-family: var(--font-main);
            background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
            color: var(--text-1);
            touch-action: none;
        }

        /* 2.4. Skip Link Accesible */
        .skip-link {
            position: absolute; top: -40px; left: 0;
            background: var(--accent); color: #000;
            padding: 8px; z-index: 1000;
            text-decoration: none; font-weight: bold;
            transition: top 0.2s;
        }
        .skip-link:focus { top: 0; }

        #bg-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 0; opacity: 0.1; 
            pointer-events: none;
            will-change: transform;
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            touch-action: none;
        }

        /* PANTALLAS Y OVERLAYS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column;
            align-items: center; justify-content: center; 
            z-index: 10;
            transition: opacity 0.2s ease;
        }
        .screen.active { display: flex; animation: fadeIn 0.3s ease-out; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .overlay { 
            background: rgba(16, 20, 27, 0.85); 
            backdrop-filter: blur(12px); 
            -webkit-backdrop-filter: blur(12px);
            border-radius: 20px;
            padding: 40px 20px;
        }
        
        @media (max-width: 720px) {
            .overlay { backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); }
        }

        .overlay h2 { 
            font-size: 2.2rem; font-weight: 800; margin-bottom: 10px; 
            color: var(--text-1); letter-spacing: -0.5px; text-align: center;
        }
        .overlay p { font-size: 1.1rem; color: var(--text-2); margin-bottom: 30px; }

        .title {
            font-size: 4rem; font-weight: 900; margin-bottom: 3rem;
            letter-spacing: -2px; display: flex; gap: 2px; z-index: 2;
        }
        .t-let:nth-child(1) { color: #22d3ee; } .t-let:nth-child(2) { color: #3b82f6; }
        .t-let:nth-child(3) { color: #fb923c; } .t-let:nth-child(4) { color: #facc15; }
        .t-let:nth-child(5) { color: #4ade80; } .t-let:nth-child(6) { color: #a855f7; }

        .btn {
            border: none; padding: 16px 32px; 
            font-size: 1.15rem; font-weight: 600; border-radius: 14px;
            cursor: pointer; margin: 12px; min-width: 200px;
            text-decoration: none; text-align: center;
            box-shadow: 0 4px 14px rgba(0,0,0,0.25);
            transition: transform 0.1s, box-shadow 0.2s;
            position: relative; overflow: hidden; letter-spacing: 0.5px;
        }
        .btn:active { transform: scale(0.96); box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .btn-green { background: linear-gradient(135deg, #4ADE80, #22C55E); color: #064E3B; }
        .btn-orange { background: linear-gradient(135deg, #60A5FA, #3B82F6); color: #EFF6FF; }
        .btn-red { background: linear-gradient(135deg, #F87171, #EF4444); color: #FEF2F2; }
        
        /* 3.1. Animación GPU-Friendly (Transform/Opacity) */
        .pulse { animation: softPulse 2s infinite ease-in-out; will-change: transform, opacity; }
        @keyframes softPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.03); opacity: 0.95; }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; flex-direction: column;
            padding: 15px; z-index: 20;
        }
        .hud-top {
            display: flex; justify-content: center; width: 100%;
            max-width: 420px; margin: 0 auto; gap: 12px; pointer-events: auto;
        }
        .hud-box {
            background: var(--glass-bg);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: var(--glass-border); border-radius: 14px;
            display: flex; flex-direction: column; flex: 1; 
            text-align: center; padding: 8px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .hud-label {
            font-size: 0.7rem; color: var(--text-2); 
            font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
            margin-bottom: 2px;
        }
        .hud-value { font-size: 1.3rem; font-weight: 700; color: var(--text-1); }
        
        #btn-pause {
            position: absolute; top: 20px; right: 20px; width: 44px; height: 44px;
            background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; pointer-events: auto; cursor: pointer; z-index: 50;
            color: var(--text-1); transition: background 0.2s;
        }

        #tetris-canvas {
            display: block; margin: auto;
            border-radius: 14px; 
            box-shadow: 0 0 40px rgba(0,0,0,0.65);
            background: linear-gradient(180deg, #0f141a, #161c24);
            touch-action: none;
            will-change: contents; 
        }

        #drawer-toggle {
            position: absolute; top: 20px; left: 20px; font-size: 1.5rem;
            cursor: pointer; z-index: 100; color: var(--text-1);
            width: 44px; height: 44px; text-align: center; line-height: 44px;
            background: rgba(255,255,255,0.05); border-radius: 12px; 
            backdrop-filter: blur(5px); display: block; 
        }
        #drawer-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(2px);
            z-index: 101; display: none; opacity: 0; transition: opacity 0.3s;
        }
        #drawer-overlay.visible { display: block; opacity: 1; }
        
        #drawer {
            position: fixed; top: 0; left: -340px; width: 300px; height: 100%;
            background: var(--panel); border-right: 1px solid rgba(255,255,255,0.08);
            border-radius: 0 24px 24px 0;
            transition: left 0.35s cubic-bezier(0.2, 0.8, 0.2, 1); 
            z-index: 102; padding: 25px; overflow-y: auto; 
            box-shadow: 10px 0 30px rgba(0,0,0,0.5); display: flex; flex-direction: column;
        }
        #drawer.open { left: 0; }
        .drawer-top-bar {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 30px; padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .drawer-close-btn { 
            font-size: 1.2rem; cursor: pointer; color: var(--text-2); 
            padding: 8px; border-radius: 50%; background: rgba(0,0,0,0.2);
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
        }
        .drawer-section { margin-bottom: 30px; }
        .drawer-header { 
            font-size: 0.85rem; margin-bottom: 15px; color: var(--accent); 
            font-weight: 700; letter-spacing: 1.2px; text-transform: uppercase;
        }
        .setting-row { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 18px; color: var(--text-1); font-size: 0.95rem;
        }
        /* 2.1. Labels de Accesibilidad */
        .setting-row label {
            cursor: pointer; flex: 1;
        }

        input[type="checkbox"] {
            appearance: none; -webkit-appearance: none; width: 42px; height: 24px;
            background: #334155; border-radius: 50px; position: relative; cursor: pointer;
            transition: background 0.3s; outline: none;
        }
        input[type="checkbox"]::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px;
            background: #fff; border-radius: 50%; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(18px); }
        
        input[type="range"] {
            width: 100%; height: 4px; background: #334155; border-radius: 2px; appearance: none; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 18px; height: 18px; background: var(--accent);
            border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }

        .level-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .lvl-btn {
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            color: var(--text-2); padding: 12px 0; border-radius: 10px; cursor: pointer;
            font-size: 0.9rem; text-align: center; font-weight: 600; transition: all 0.2s;
        }
        .lvl-btn:disabled { opacity: 0.2; cursor: not-allowed; }
        .lvl-btn.unlocked { background: rgba(96, 165, 250, 0.15); border-color: rgba(96, 165, 250, 0.3); color: var(--accent-2); }
        .lvl-btn.completed { background: var(--accent); border-color: var(--accent); color: #064E3B; }
        #next-canvas { display: block; margin: 0 auto; filter: drop-shadow(0 0 5px rgba(0,0,0,0.3)); }

        body.gameplay-mode * {
            animation: none !important;
            transition: none !important;
        }
        body.gameplay-mode #tetris-canvas {
            box-shadow: none !important;
        }
        body.gameplay-mode .screen.active {
            display: flex !important;
        }

    </style>
</head>
<body>

    <a href="#game-container" class="skip-link">Saltar al juego</a>

    <canvas id="bg-canvas"></canvas>

    <div id="drawer-toggle">☰</div>
    <div id="drawer-overlay"></div>

    <aside id="drawer">
        <div class="drawer-top-bar">
            <span style="font-weight:800; font-size:1.4rem; color:var(--text-1);">Ajustes</span>
            <div class="drawer-close-btn" id="drawer-close">✕</div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Sistema</div>
            <div class="setting-row">
                <label for="toggle-music">Música</label>
                <input type="checkbox" id="toggle-music" checked>
            </div>
            <div class="setting-row">
                <label for="toggle-sfx">Efectos de Sonido</label>
                <input type="checkbox" id="toggle-sfx" checked>
            </div>
            <div class="setting-row">
                <label for="toggle-haptics" style="opacity:0.5; text-decoration:line-through;">Vibración (Off)</label>
                <input type="checkbox" id="toggle-haptics" disabled>
            </div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Juego</div>
            <div class="setting-row">
                <label for="toggle-ghost">Pieza Fantasma</label>
                <input type="checkbox" id="toggle-ghost" checked>
            </div>
            <div class="setting-row" style="flex-direction:column; align-items:flex-start;">
                <div style="display:flex; justify-content:space-between; width:100%; margin-bottom:8px;">
                    <label for="slider-sens">Sensibilidad Touch</label>
                    <span id="sens-val" style="color:var(--accent)">5</span>
                </div>
                <input type="range" id="slider-sens" min="1" max="10" value="5">
            </div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Niveles</div>
            <div class="level-grid" id="level-grid"></div>
        </div>
        
        <div style="margin-top:auto; font-size:0.75rem; color:var(--text-2); text-align:center; padding-top:20px;">
            Tetris Neo Optimized v2.0
        </div>
    </aside>

    <div id="game-container">
        <div id="screen-start" class="screen active">
            <div class="title">
                <span class="t-let">T</span><span class="t-let">E</span><span class="t-let">T</span><span class="t-let">R</span><span class="t-let">I</span><span class="t-let">S</span>
            </div>
            <p style="color:var(--text-2); margin-bottom:30px; letter-spacing:2px; font-size:0.9rem;">NEO ARCADE EDITION</p>
            
            <button id="btn-start" class="btn btn-green pulse">JUGAR NIVEL 1</button>
            <a href="../index.html" class="btn btn-red">SALIR</a>
        </div>

        <div id="screen-game" class="screen">
            <div id="game-ui">
                <div class="hud-top">
                    <div class="hud-box">
                        <div class="hud-label">MOVS</div>
                        <div class="hud-value" id="hud-moves">0</div>
                    </div>
                    <div class="hud-box" style="flex:2;">
                        <div class="hud-label" id="hud-obj-label">OBJETIVO</div>
                        <div class="hud-value" id="hud-obj-val">--</div>
                    </div>
                    <div class="hud-box">
                        <div class="hud-label">SIG</div>
                        <canvas id="next-canvas" width="60" height="60"></canvas>
                    </div>
                </div>
                <div id="btn-pause">||</div>
            </div>
            <canvas id="tetris-canvas"></canvas>
        </div>

        <div id="screen-pause" class="screen overlay">
            <h2>PAUSA</h2>
            <button id="btn-resume" class="btn btn-green">CONTINUAR</button>
            <button id="btn-quit-level" class="btn btn-orange">MENÚ PRINCIPAL</button>
        </div>

        <div id="screen-gameover" class="screen overlay">
            <h2 style="color:var(--danger)">GAME OVER</h2>
            <p id="go-reason">Inténtalo de nuevo</p>
            <button id="btn-retry" class="btn btn-green">REINTENTAR</button>
            <button id="btn-go-menu" class="btn btn-red">SALIR</button>
        </div>

        <div id="screen-win" class="screen overlay">
            <h2 style="color:var(--accent)">¡NIVEL COMPLETADO!</h2>
            <div style="text-align:center; margin-bottom:30px;">
                <p style="font-size:1.3rem; margin-bottom:5px; color:var(--text-1);">Puntuación: <span id="win-score" style="font-weight:800;">0</span></p>
                <p style="color:var(--accent-2); font-size:1rem;">Monedas: +<span id="win-coins">0</span></p>
            </div>
            <button id="btn-next-level" class="btn btn-green">SIGUIENTE</button>
            <button id="btn-win-menu" class="btn btn-orange">MENÚ</button>
        </div>
    </div>

     <script src="../js/app.js"></script>
    <script>
        // ===========================================
        // CONFIGURACIÓN OPTIMIZADA
        // ===========================================
        const CONFIG = {
            GRID_W: 10, GRID_H: 20, 
            STORAGE_KEY: "tetris_progress_v2", SETTINGS_KEY: "tetris_settings_v2",
            DROP_INTERVAL: 1000,
            MAX_PARTICLES: 120, 
            BG_FPS: 12 
        };

        const COLORS = {
            I: "#22d3ee", J: "#3b82f6", L: "#fb923c", O: "#facc15",
            S: "#4ade80", T: "#a855f7", Z: "#f87171",
            GHOST: "rgba(255, 255, 255, 0.1)", 
            BG_DARK: "transparent", BG_LIGHT: "transparent" 
        };

        const SHAPES = {
            I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
            J: [[1,0,0], [1,1,1], [0,0,0]],
            L: [[0,0,1], [1,1,1], [0,0,0]],
            O: [[1,1], [1,1]],
            S: [[0,1,1], [1,1,0], [0,0,0]],
            T: [[0,1,0], [1,1,1], [0,0,0]],
            Z: [[1,1,0], [0,1,1], [0,0,0]]
        };
        const SHAPE_KEYS = Object.keys(SHAPES);

        // ===========================================
        // OPTIMIZACIÓN DE RENDER: CACHE DE PIEZAS
        // ===========================================
        const PIECE_CACHE = {}; 
        let cellSize = 30; 

        const LEVELS = [
            { id:1,  name:"Nivel 1", obj:{type:"lines", val:5},   moves:50,  coins:5 }, 
            { id:2,  name:"Nivel 2", obj:{type:"points", val:2000}, moves:60,  coins:10 },
            { id:3,  name:"Nivel 3", obj:{type:"lines", val:10},  moves:70,  coins:15 },
            { id:4,  name:"Nivel 4", obj:{type:"points", val:5000}, moves:80, coins:20 },
            { id:5,  name:"Nivel 5", obj:{type:"lines", val:15},  moves:90, coins:25 },
            { id:6,  name:"Nivel 6", obj:{type:"points", val:10000}, moves:100, coins:30 },
            { id:7,  name:"Nivel 7", obj:{type:"lines", val:20},  moves:110, coins:40 },
            { id:8,  name:"Nivel 8", obj:{type:"points", val:20000}, moves:120, coins:50 },
            { id:9,  name:"Nivel 9", obj:{type:"lines", val:30},  moves:140, coins:75 },
            { id:10, name:"MAESTRO", obj:{type:"lines", val:40},  moves:160, coins:100 }
        ];

        let canvas, ctx, nextCanvas, nextCtx, bgCanvas, bgCtx;
        let lastTime = 0;
        let dropCounter = 0;
        let currentLevelIdx = 0;
        let isPaused = false;
        let gameActive = false;
        
        let grid = [];
        let player = { matrix: null, pos: {x:0, y:0}, type: null, score: 0, lines: 0, movesLeft: 0, objRemaining: 0 };
        let nextPieceType = null;
        let particles = [];
        
        let settings = { music: true, sfx: true, ghost: true, touchSens: 5, haptics: false };
        let progress = { unlocked: [1], coins: 0, scores: {}, rewardsClaimed: [] };

        // Audio System
        let audioCtx = null;
        let gainMaster = null;
        let soundBuffers = {};
        let musicPlayer = null;

        let hudCache = { moves: -1, obj: "" };

        window.onload = () => {
            initDOM();
            loadStorage();
            initBgAnimation();
            resize();
            window.addEventListener('resize', resize);
            renderMenuLevels();
        };

        function initDOM() {
            canvas = document.getElementById('tetris-canvas');
            ctx = canvas.getContext('2d', { alpha: true });
            nextCanvas = document.getElementById('next-canvas');
            nextCtx = nextCanvas.getContext('2d', { alpha: true });
            
            document.getElementById('drawer-toggle').onclick = toggleDrawer;
            document.getElementById('drawer-close').onclick = toggleDrawer;
            document.getElementById('drawer-overlay').onclick = toggleDrawer;

            document.getElementById('btn-start').onclick = () => startGame(currentLevelIdx);
            
            document.getElementById('btn-pause').onclick = togglePause;
            document.getElementById('btn-resume').onclick = togglePause;
            document.getElementById('btn-quit-level').onclick = showMainMenu;
            
            document.getElementById('btn-retry').onclick = () => startGame(currentLevelIdx);
            document.getElementById('btn-go-menu').onclick = showMainMenu;
            
            document.getElementById('btn-next-level').onclick = () => {
                if(currentLevelIdx < LEVELS.length -1) startGame(currentLevelIdx + 1);
                else showMainMenu();
            };
            document.getElementById('btn-win-menu').onclick = showMainMenu;

            document.getElementById('toggle-music').onchange = (e) => { settings.music = e.target.checked; updateMusicState(); saveSettings(); };
            document.getElementById('toggle-sfx').onchange = (e) => { settings.sfx = e.target.checked; saveSettings(); };
            document.getElementById('toggle-ghost').onchange = (e) => { settings.ghost = e.target.checked; saveSettings(); };
            
            document.getElementById('toggle-haptics').onchange = (e) => { 
                settings.haptics = false; e.target.checked = false; saveSettings(); 
            };
            
            const slider = document.getElementById('slider-sens');
            slider.oninput = (e) => {
                settings.touchSens = parseInt(e.target.value);
                document.getElementById('sens-val').innerText = settings.touchSens;
                saveSettings();
            };
            
            document.addEventListener('keydown', handleKey);
            setupTouch(canvas);
        }

        async function initMusic() {
            if (!musicPlayer) {
                musicPlayer = new Audio("../assets/music/retro-arcade-music-8f2d3a.ogg");
                musicPlayer.loop = true;
                musicPlayer.preload = "none"; 
                musicPlayer.volume = 0.6;
            }
        }

        function generatePieceCache() {
            const size = cellSize;
            const pad = 2;
            for (let key in COLORS) {
                if(key === 'GHOST' || key === 'BG_DARK' || key === 'BG_LIGHT') continue;
                const c = document.createElement('canvas');
                c.width = size;
                c.height = size;
                const cx = c.getContext('2d');
                cx.fillStyle = COLORS[key];
                cx.beginPath();
                cx.roundRect(pad, pad, size - pad*2, size - pad*2, 6);
                cx.fill();
                cx.fillStyle = "rgba(255,255,255,0.2)";
                cx.beginPath();
                cx.roundRect(pad, pad, size - pad*2, (size - pad*2) * 0.4, [6, 6, 0, 0]);
                cx.fill();
                cx.fillStyle = "rgba(0,0,0,0.1)";
                cx.beginPath();
                cx.roundRect(pad, size - 8, size - pad*2, 6, [0, 0, 6, 6]);
                cx.fill();
                PIECE_CACHE[key] = c;
            }
        }

        function enableAudioGlobal() {
            if(!audioCtx) initAudioSystem();
            if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        }

        function loadStorage() {
            const savedSet = localStorage.getItem(CONFIG.SETTINGS_KEY);
            if(savedSet) {
                settings = Object.assign(settings, JSON.parse(savedSet));
                document.getElementById('toggle-music').checked = settings.music;
                document.getElementById('toggle-sfx').checked = settings.sfx;
                document.getElementById('toggle-ghost').checked = settings.ghost;
                document.getElementById('toggle-haptics').checked = false; 
                settings.haptics = false;
                document.getElementById('slider-sens').value = settings.touchSens;
                document.getElementById('sens-val').innerText = settings.touchSens;
            }
            const savedProg = localStorage.getItem(CONFIG.STORAGE_KEY);
            if(savedProg) progress = Object.assign(progress, JSON.parse(savedProg));

            const maxUnlocked = Math.max(...progress.unlocked);
            const nextLvl = LEVELS.find(l => l.id === maxUnlocked);
            if(nextLvl) {
                currentLevelIdx = LEVELS.indexOf(nextLvl);
                document.getElementById('btn-start').innerText = "JUGAR " + nextLvl.name;
            }
        }

        function saveSettings() { localStorage.setItem(CONFIG.SETTINGS_KEY, JSON.stringify(settings)); }
        function saveProgress() { localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(progress)); }

        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, 1.25);
            const containerH = window.innerHeight;
            const containerW = window.innerWidth;
            let cs = Math.floor((containerH * 0.75) / CONFIG.GRID_H);
            if(cs * CONFIG.GRID_W > containerW * 0.9) cs = Math.floor((containerW * 0.9) / CONFIG.GRID_W);
            
            if(cs !== cellSize) {
                cellSize = cs;
                generatePieceCache(); 
            }

            const w = CONFIG.GRID_W * cellSize;
            const h = CONFIG.GRID_H * cellSize;
            canvas.width = w * dpr; canvas.height = h * dpr;
            canvas.style.width = w + "px"; canvas.style.height = h + "px";
            ctx.resetTransform(); ctx.scale(dpr, dpr);

            const bgC = document.getElementById('bg-canvas');
            bgC.width = containerW * dpr; bgC.height = containerH * dpr;
            bgC.style.width = containerW + "px"; bgC.style.height = containerH + "px";
            const bgCtx = bgC.getContext('2d');
            bgCtx.scale(dpr, dpr);
            
            if(!gameActive) draw(); 
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMatrix(grid, {x:0, y:0});
            if(gameActive && !isPaused && player.matrix) {
                if(settings.ghost) {
                    const ghostPos = { ...player.pos };
                    while(!collide(grid, {matrix:player.matrix, pos:ghostPos})) ghostPos.y+=2;
                    ghostPos.y-=2;
                    while(!collide(grid, {matrix:player.matrix, pos:ghostPos})) ghostPos.y++;
                    ghostPos.y--;
                    ctx.globalAlpha = 0.25; 
                    drawMatrix(player.matrix, ghostPos, true);
                    ctx.globalAlpha = 1.0;
                }
                drawMatrix(player.matrix, player.pos);
            }
            if(particles.length > 0) {
                for(let i=0; i<particles.length; i++) {
                    const p = particles[i];
                    ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }

        function drawMatrix(matrix, offset, isGhost = false) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const drawX = (x + offset.x) * cellSize;
                        const drawY = (y + offset.y) * cellSize;
                        if(isGhost) {
                            ctx.strokeStyle = COLORS[value]; 
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.roundRect(drawX + 2, drawY + 2, cellSize - 4, cellSize - 4, 4);
                            ctx.stroke();
                        } else {
                            if(PIECE_CACHE[value]) {
                                ctx.drawImage(PIECE_CACHE[value], drawX, drawY);
                            }
                        }
                    }
                });
            });
        }
        
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            if(!nextPieceType) return;
            const matrix = SHAPES[nextPieceType];
            const boxSize = 12;
            const w = matrix[0].length * boxSize;
            const h = matrix.length * boxSize;
            const offX = (nextCanvas.width - w) / 2;
            const offY = (nextCanvas.height - h) / 2;
            nextCtx.fillStyle = COLORS[nextPieceType];
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if(val) {
                        nextCtx.beginPath();
                        nextCtx.roundRect(offX + x*boxSize, offY + y*boxSize, boxSize-1, boxSize-1, 2);
                        nextCtx.fill();
                    }
                });
            });
        }

        function startGame(levelIndex) {
            currentLevelIdx = levelIndex;
            const lvlData = LEVELS[currentLevelIdx];
            grid = createGrid(CONFIG.GRID_W, CONFIG.GRID_H);
            player = {
                matrix: null, pos: {x:0, y:0}, type: null,
                score: 0, lines: 0,
                movesLeft: lvlData.moves,
                objRemaining: lvlData.obj.val
            };
            particles = [];
            isGameOver = false; isPaused = false; gameActive = true;
            nextPieceType = getRandomPiece();
            
            dropCounter = 0;
            document.body.classList.add('gameplay-mode');
            playerReset();
            
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-game').classList.add('active');
            document.getElementById('game-ui').style.display = 'flex';
            document.getElementById('drawer-toggle').style.display = 'none';
            toggleDrawer(false);
            
            hudCache = { moves: -1, obj: "" }; 
            updateHUD();

            initMusic().then(() => {
                enableAudioGlobal();
                updateMusicState();
            });
            
            lastTime = performance.now();
            requestAnimationFrame(update);
        }

        function createGrid(w, h) {
            const m = [];
            while (h--) m.push(new Array(w).fill(0));
            return m;
        }

        function update(time) {
            if(!gameActive || isPaused) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > CONFIG.DROP_INTERVAL) {
                playerDrop();
                dropCounter = 0;
            }
            if(particles.length > CONFIG.MAX_PARTICLES) {
                particles.splice(0, particles.length - CONFIG.MAX_PARTICLES);
            }
            updateParticles(deltaTime);
            draw();
            requestAnimationFrame(update);
        }

        function updateParticles(dt) {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= dt * 0.003; 
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function playerReset() {
            const piece = nextPieceType;
            nextPieceType = getRandomPiece();
            drawNextPiece();
            player.matrix = JSON.parse(JSON.stringify(SHAPES[piece]));
            player.type = piece;
            player.matrix.forEach((row, y) => row.forEach((val, x) => {
                if(val!==0) player.matrix[y][x] = piece; 
            }));
            player.pos.y = 0;
            player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(grid, player)) gameOver("Tablero bloqueado");
        }

        function getRandomPiece() { return SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)]; }

        function playerDrop() {
            player.pos.y++;
            if (collide(grid, player)) {
                player.pos.y--;
                merge(grid, player);
                playSound('drop');
                triggerHaptic(null);
                decrementMoves();
                sweep();
                playerReset();
            }
        }
        
        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(grid, player)) {
                player.pos.x -= dir;
            } else {
                playSound('move');
            }
        }

        function playerRotate() {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix);
            while (collide(grid, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -1);
                    player.pos.x = pos;
                    return;
                }
            }
            playSound('rotate');
        }

        function rotate(matrix, dir = 1) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function collide(arena, p) {
            const m = p.matrix; const o = p.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(arena, p) {
            p.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + p.pos.y][x + p.pos.x] = value;
                });
            });
        }

        function sweep() {
            let rowCount = 0;
            outer: for (let y = grid.length -1; y > 0; --y) {
                for (let x = 0; x < grid[y].length; ++x) {
                    if (grid[y][x] === 0) continue outer;
                }
                const row = grid.splice(y, 1)[0].fill(0);
                grid.unshift(row);
                ++y;
                rowCount++;
                createExplosion(y * cellSize, CONFIG.GRID_W * cellSize);
            }
            if(rowCount > 0) {
                playSound('clear');
                triggerHaptic(null);
                const points = rowCount * 1000 * rowCount;
                player.score += points;
                player.lines += rowCount;
                const lvl = LEVELS[currentLevelIdx];
                if(lvl.obj.type === 'lines') player.objRemaining -= rowCount;
                if(lvl.obj.type === 'points') player.objRemaining = lvl.obj.val - player.score;
                checkWin();
                updateHUD();
            }
        }
        
        function decrementMoves() {
            player.movesLeft--;
            updateHUD();
            if(player.movesLeft <= 0) gameOver("Sin movimientos");
        }

        function updateHUD() {
            const lvl = LEVELS[currentLevelIdx];
            if (hudCache.moves !== player.movesLeft) {
                document.getElementById('hud-moves').innerText = player.movesLeft;
                hudCache.moves = player.movesLeft;
            }
            let val = Math.max(0, player.objRemaining);
            let strVal = (lvl.obj.type==='lines' ? val + " L" : val);
            if (hudCache.obj !== strVal) {
                document.getElementById('hud-obj-val').innerText = strVal;
                hudCache.obj = strVal;
            }
        }

        function createExplosion(y, width) {
            const count = 15; 
            for(let i=0; i<count; i++) {
                particles.push({
                    x: Math.random() * width, y: y + Math.random() * 20,
                    vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                    life: 0.8, color: `hsl(${Math.random()*360}, 100%, 70%)`, 
                    size: Math.random() * 4 + 1
                });
            }
        }

        function checkWin() {
            if(player.objRemaining <= 0) {
                endGameplay();
                const lvl = LEVELS[currentLevelIdx];
                const nextId = lvl.id + 1;
                let coinsWon = 0;
                
                // === INTEGRACIÓN DE MONEDAS UNIVERSAL ===
                // Verificar si este nivel ya se ha pagado antes
                if(!progress.rewardsClaimed.includes(lvl.id)) {
                    progress.rewardsClaimed.push(lvl.id);
                    progress.coins += lvl.coins; // Monedas visuales del juego
                    coinsWon = lvl.coins;

                    // Conexión con app.js (Sistema Global)
                    if (window.GameCenter && typeof window.GameCenter.completeLevel === 'function') {
                        // Enviamos: ID Juego ('tetris'), ID Nivel ('lvl_1'), Cantidad (coinsWon)
                        window.GameCenter.completeLevel('tetris', 'lvl_' + lvl.id, coinsWon);
                        console.log(`[Tetris] Enviando ${coinsWon} monedas al sistema global.`);
                    } else {
                        console.warn("[Tetris] Sistema GameCenter no encontrado. Las monedas no se guardaron globalmente.");
                    }
                }
                // ========================================

                if(!progress.unlocked.includes(nextId)) progress.unlocked.push(nextId);
                if(!progress.scores[lvl.id] || player.score > progress.scores[lvl.id]) progress.scores[lvl.id] = player.score;
                saveProgress();
                document.getElementById('win-score').innerText = player.score;
                document.getElementById('win-coins').innerText = coinsWon;
                document.getElementById('screen-win').classList.add('active');
                playSound('win');
            }
        }

        function gameOver(reason) {
            endGameplay();
            document.getElementById('go-reason').innerText = reason;
            document.getElementById('screen-gameover').classList.add('active');
            playSound('lose');
            triggerHaptic(null);
        }

        function endGameplay() {
            gameActive = false;
            document.body.classList.remove('gameplay-mode');
        }

        function handleKey(event) {
            if(!gameActive || isPaused) {
                if(event.key.toLowerCase() === 'p') togglePause();
                return;
            }
            if (event.keyCode === 37) playerMove(-1);
            else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop();
            else if (event.keyCode === 38) playerRotate();
            else if (event.keyCode === 32) hardDrop();
            else if (event.key.toLowerCase() === 'p') togglePause();
        }
        
        function hardDrop() {
            while (!collide(grid, player)) player.pos.y++;
            player.pos.y--;
            merge(grid, player);
            playSound('drop');
            triggerHaptic(null);
            decrementMoves(); 
            createExplosion(player.pos.y * cellSize, CONFIG.GRID_W * cellSize);
            sweep();
            playerReset();
            dropCounter = 0;
        }

        function setupTouch(element) {
            let startX = 0, startY = 0;
            let lastX = 0;
            let touchAccumulatorX = 0;
            let isVerticalGesture = false;

            element.addEventListener('pointerdown', e => {
                if(!gameActive || isPaused) return;
                e.preventDefault();
                startX = e.clientX;
                startY = e.clientY;
                lastX = e.clientX;
                touchAccumulatorX = 0;
                isVerticalGesture = false; 
            }, {passive:false});

            element.addEventListener('pointermove', e => {
                if(!gameActive || isPaused || startX === 0) return;
                e.preventDefault();
                const totalDx = e.clientX - startX;
                const totalDy = e.clientY - startY;
                if (!isVerticalGesture) {
                    if (totalDy > 20 && totalDy > Math.abs(totalDx) * 1.5) {
                        isVerticalGesture = true;
                    }
                }
                if (isVerticalGesture) return; 
                const dx = e.clientX - lastX;
                lastX = e.clientX; 
                const sens = Math.max(10, 35 - (settings.touchSens * 2.5));
                touchAccumulatorX += dx;
                while(Math.abs(touchAccumulatorX) > sens) {
                    if(touchAccumulatorX > 0) {
                        playerMove(1);
                        touchAccumulatorX -= sens;
                    } else {
                        playerMove(-1);
                        touchAccumulatorX += sens;
                    }
                }
            });

            element.addEventListener('pointerup', e => {
                if(!gameActive || isPaused || startX === 0) return;
                const totalDx = e.clientX - startX;
                const totalDy = e.clientY - startY;
                if (isVerticalGesture && totalDy > 60) hardDrop();
                else if (!isVerticalGesture && Math.abs(totalDx) < 20 && Math.abs(totalDy) < 30) playerRotate();
                else if (totalDy > 50 && !isVerticalGesture) { playerDrop(); dropCounter = 0; }
                startX = 0; startY = 0; isVerticalGesture = false;
            });
            
            element.addEventListener('pointerleave', () => { startX = 0; isVerticalGesture = false; });
        }
        
        function triggerHaptic(pattern) { return; }

        function initAudioSystem() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            gainMaster = audioCtx.createGain();
            gainMaster.connect(audioCtx.destination);
            gainMaster.gain.value = 0.3;
            soundBuffers['move'] = createBuffer(300, 100, 0.05, 'triangle');
            soundBuffers['rotate'] = createBuffer(400, 600, 0.08, 'sine');
            soundBuffers['drop'] = createBuffer(150, 50, 0.1, 'square');
            soundBuffers['clear'] = createBuffer(400, 1200, 0.2, 'sine');
            soundBuffers['lose'] = createBuffer(200, 50, 0.5, 'sawtooth');
        }

        function createBuffer(freqStart, freqEnd, duration, type) {
            if(!audioCtx) return null;
            const sampleRate = audioCtx.sampleRate;
            const frames = sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, frames, sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < frames; i++) {
                const progress = i / frames;
                const currentFreq = freqStart + (freqEnd - freqStart) * progress;
                const t = i / sampleRate;
                let val = 0;
                if(type === 'sine') val = Math.sin(2 * Math.PI * currentFreq * t);
                else if(type === 'square') val = Math.sin(2 * Math.PI * currentFreq * t) > 0 ? 1 : -1;
                else if(type === 'triangle') val = Math.asin(Math.sin(2 * Math.PI * currentFreq * t)) * (2/Math.PI);
                else if(type === 'sawtooth') val = 2 * (t * currentFreq - Math.floor(t * currentFreq + 0.5));
                data[i] = val * (1 - progress); 
            }
            return buffer;
        }

        function playSound(type) {
            if(!settings.sfx || !audioCtx) return;
            if(soundBuffers[type]) {
                const source = audioCtx.createBufferSource();
                source.buffer = soundBuffers[type];
                source.connect(gainMaster);
                source.start();
            } else if (type === 'win') {
                const now = audioCtx.currentTime;
                [523, 659, 784, 1046].forEach((f, i) => {
                    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                    o.connect(g); g.connect(gainMaster); o.type = 'triangle'; o.frequency.value = f;
                    g.gain.setValueAtTime(0.1, now + i*0.1); g.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.3);
                    o.start(now + i*0.1); o.stop(now + i*0.1 + 0.3);
                });
            }
        }

        function updateMusicState() {
            if (musicPlayer && settings.music && gameActive && !isPaused) {
                musicPlayer.play().catch(()=>{});
            } else if (musicPlayer) {
                musicPlayer.pause();
            }
        }

        function togglePause() {
            if(!gameActive) return;
            isPaused = !isPaused;
            const pScreen = document.getElementById('screen-pause');
            if(isPaused) {
                pScreen.classList.add('active');
                document.body.classList.remove('gameplay-mode');
            } else {
                pScreen.classList.remove('active');
                document.body.classList.add('gameplay-mode');
                lastTime = performance.now(); 
                requestAnimationFrame(update);
            }
            updateMusicState();
        }

        function showMainMenu() {
            endGameplay();
            if(musicPlayer) {
                musicPlayer.pause();
                musicPlayer.currentTime = 0;
            }
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-start').classList.add('active');
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('drawer-toggle').style.display = 'block';
            loadStorage();
            renderMenuLevels();
        }

        function toggleDrawer(forceOpen = null) {
            const d = document.getElementById('drawer');
            const o = document.getElementById('drawer-overlay');
            const isOpen = d.classList.contains('open');
            if(forceOpen === false || isOpen) {
                d.classList.remove('open'); o.classList.remove('visible');
            } else {
                d.classList.add('open'); o.classList.add('visible');
            }
        }

        function renderMenuLevels() {
            const container = document.getElementById('level-grid');
            container.innerHTML = '';
            LEVELS.forEach((lvl, idx) => {
                const btn = document.createElement('div');
                const isUnlocked = progress.unlocked.includes(lvl.id);
                const isCompleted = progress.scores[lvl.id] !== undefined;
                let cls = 'lvl-btn';
                if(isUnlocked) cls += ' unlocked';
                if(isCompleted) cls += ' completed'; 
                btn.className = cls; btn.innerText = lvl.id;
                if(isUnlocked) {
                    btn.onclick = () => { startGame(idx); toggleDrawer(false); };
                } else btn.setAttribute('disabled', true);
                container.appendChild(btn);
            });
        }
        
        function initBgAnimation() {
            bgCanvas = document.getElementById('bg-canvas');
            bgCtx = bgCanvas.getContext('2d', { alpha: true });
            const shapes = [];
            const possibleShapes = Object.values(SHAPES);
            const dpr = Math.min(window.devicePixelRatio || 1, 1.25);
            for(let i=0; i<20; i++) { 
                shapes.push({
                    x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight,
                    speed: (0.01 + Math.random() * 0.04), scale: 1.0 + Math.random() * 1.0,
                    matrix: possibleShapes[Math.floor(Math.random()*possibleShapes.length)]
                });
            }
            let lastBgFrame = 0;
            function loop(time) {
                if (time - lastBgFrame >= 1000 / CONFIG.BG_FPS) {
                    bgCtx.setTransform(1,0,0,1,0,0);
                    bgCtx.clearRect(0,0,bgCanvas.width, bgCanvas.height);
                    bgCtx.scale(dpr, dpr);
                    bgCtx.fillStyle = "rgba(255,255,255,0.05)";
                    shapes.forEach(s => {
                        s.x += s.speed;
                        if(s.x > window.innerWidth) s.x = -100; 
                        s.matrix.forEach((row, ry) => {
                            row.forEach((val, rx) => {
                                if(val) bgCtx.fillRect(s.x + rx * (10 * s.scale), s.y + ry * (10 * s.scale), (10 * s.scale), (10 * s.scale));
                            });
                        });
                    });
                    lastBgFrame = time;
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
