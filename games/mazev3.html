<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Laberinto Arcade Pro</title>
    <style>
        :root {
            --bg-deep: #020617;
            --wall: #334155;
            --path-visited: #1e293b;
            --player: #38bdf8;
            --player-glow: rgba(56, 189, 248, 0.4);
            --goal: #fbbf24;
            --ui-glass: rgba(255, 255, 255, 0.1);
            --danger: #ef4444;
        }

        /* RESET & BASE */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-deep);
            color: white; font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden; touch-action: none;
            display: flex; flex-direction: column; height: 100vh; width: 100vw;
        }

        /* UI SUPERIOR */
        .top-hud {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 15px; display: flex; justify-content: space-between; align-items: center;
            pointer-events: none; z-index: 20;
        }
        .hud-group { display: flex; gap: 10px; pointer-events: auto; }
        
        .btn-glass {
            background: var(--ui-glass); backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1); color: white;
            padding: 8px 12px; border-radius: 20px; text-decoration: none;
            display: flex; align-items: center; justify-content: center; gap: 6px; 
            font-weight: 600; font-size: 14px; min-width: 40px;
            cursor: pointer; transition: 0.2s;
        }
        .btn-glass:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }
        .lvl-badge { background: var(--player); color: #000; font-weight: 800; border:none; box-shadow: 0 0 15px var(--player-glow); }
        
        /* ICONOS SVG */
        .icon { width: 20px; height: 20px; stroke: currentColor; stroke-width: 2.5; fill: none; stroke-linecap: round; stroke-linejoin: round; }

        /* AREA DE JUEGO */
        #game-viewport {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; background: var(--bg-deep);
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* TUTORIAL OVERLAY */
        #tutorial {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 50; pointer-events: none;
            animation: fadeOut 0.5s ease 4s forwards;
            text-align: center;
        }
        .tut-hand { animation: swipeAnim 2s infinite; opacity: 0.9; margin-bottom: 20px; }
        @keyframes swipeAnim { 
            0% { transform: translateY(20px); opacity: 0; } 
            50% { transform: translateY(-20px); opacity: 1; } 
            100% { transform: translateY(-40px); opacity: 0; } 
        }

        /* CONTROLES TÁCTILES */
        .input-zone-left { position: absolute; top: 0; left: 0; bottom: 0; width: 50%; z-index: 10; cursor: default; }
        .input-zone-right { position: absolute; top: 0; right: 0; bottom: 0; width: 50%; z-index: 10; cursor: default; }
        
        .nipple-base {
            position: absolute; width: 100px; height: 100px;
            border-radius: 50%; background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            display: none; pointer-events: none;
            transform: translate(-50%, -50%); z-index: 15;
            transition: opacity 0.2s;
        }
        .nipple-stick {
            position: absolute; width: 40px; height: 40px;
            border-radius: 50%; background: var(--player);
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 20px var(--player);
        }

        /* MODALES */
        .modal-overlay {
            position: fixed; inset: 0; z-index: 100;
            background: rgba(2,6,23,0.95);
            display: none; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-box {
            background: #1e293b; padding: 30px; border-radius: 24px;
            text-align: center; max-width: 350px; width: 90%;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            transform: scale(0.9); animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        .modal-box h2 { color: var(--goal); font-size: 2rem; margin: 10px 0; text-transform: uppercase; letter-spacing: 1px; }
        .btn-primary {
            background: var(--player); color: #020617; border: none;
            padding: 16px 32px; border-radius: 50px; font-weight: 800; font-size: 1.1rem;
            width: 100%; margin-top: 25px; cursor: pointer;
            box-shadow: 0 4px 20px rgba(56, 189, 248, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn-primary:active { transform: scale(0.96); box-shadow: 0 2px 10px rgba(56, 189, 248, 0.2); }

        /* LOADING SPINNER */
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(56, 189, 248, 0.3);
            border-top-color: var(--player); border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }

        @keyframes fadeOut { to { opacity: 0; visibility: hidden; } }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes popIn { to { transform: scale(1); } }
    </style>
</head>
<body>

    <div class="top-hud">
        <div class="hud-group">
            <a href="../index.html" class="btn-glass" title="Salir">
                <svg class="icon" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
            </a>
            <div class="btn-glass" onclick="game.toggleMute()" id="mute-btn" title="Silenciar">
                <svg class="icon" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
            </div>
        </div>
        <div class="btn-glass lvl-badge" id="lvl-display">NV 1</div>
    </div>

    <div id="game-viewport">
        <canvas id="canvas"></canvas>
    </div>

    <div id="tutorial">
        <svg class="tut-hand" width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
        </svg>
        <p style="font-weight:bold; font-size: 1.2rem; margin:0;">DESLIZA PARA MOVERTE</p>
        <p style="font-size:0.9rem; opacity:0.7; margin-top:5px;">PC: Usa las flechas o WASD</p>
    </div>

    <div class="input-zone-left" id="zone-joy"></div>
    <div class="input-zone-right" id="zone-swipe"></div>

    <div class="nipple-base" id="joy-ui">
        <div class="nipple-stick" id="joy-stick"></div>
    </div>

    <div id="win-modal" class="modal-overlay">
        <div class="modal-box">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#fbbf24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-bottom:10px">
                <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/>
            </svg>
            <h2>¡Victoria!</h2>
            <p id="win-msg" style="color:#94a3b8; font-size: 1.1rem; margin-bottom: 5px;">Nivel Completado</p>
            <button class="btn-primary" onclick="game.nextLevel()">Siguiente Nivel</button>
        </div>
    </div>

    <div id="loading-modal" class="modal-overlay" style="background:black;">
        <div style="color:var(--player); font-family:monospace; display:flex; flex-direction:column; align-items:center;">
            <div class="spinner"></div>
            GENERANDO LABERINTO...
        </div>
    </div>

    <script src="../js/app.js"></script>

    <script>
        const LEVEL_CONFIG = {
            1:  { size: 9,  minSteps: 12 },
            5:  { size: 15, minSteps: 40 },
            10: { size: 21, minSteps: 80 },
            12: { size: 25, minSteps: 100 },
            13: { size: 29, minSteps: 120 },
            14: { size: 31, minSteps: 150 },
            15: { size: 35, minSteps: 180 }
        };
        const MAX_LEVEL = 15;

        class AudioSys {
            constructor() {
                this.ctx = null;
                this.muted = false;
            }
            init() {
                if (!this.ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (AC) this.ctx = new AC();
                }
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            }
            toggle() {
                this.muted = !this.muted;
                return this.muted;
            }
            play(type) {
                if (this.muted || !this.ctx) return;
                const t = this.ctx.currentTime;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.connect(g); g.connect(this.ctx.destination);

                if(type === 'step') {
                    o.frequency.setValueAtTime(120, t);
                    o.frequency.exponentialRampToValueAtTime(40, t + 0.05);
                    g.gain.setValueAtTime(0.05, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.05);
                    o.start(t); o.stop(t + 0.05);
                } else if (type === 'bump') { 
                    o.type = 'square';
                    o.frequency.setValueAtTime(80, t);
                    o.frequency.exponentialRampToValueAtTime(20, t + 0.1);
                    g.gain.setValueAtTime(0.02, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.1);
                    o.start(t); o.stop(t + 0.1);
                } else if (type === 'win') {
                    o.type = 'triangle';
                    o.frequency.setValueAtTime(440, t);
                    o.frequency.linearRampToValueAtTime(880, t + 0.1);
                    g.gain.setValueAtTime(0.1, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.5);
                    o.start(t); o.stop(t + 0.5);
                }
            }
        }

        class MazeGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false }); 
                this.audio = new AudioSys();
                
                this.state = { lvl: 1, p: {x:0,y:0}, g: {x:0,y:0}, active: false };
                this.grid = [];
                
                // CÁMARA FLUIDA CORREGIDA
                // camPos: Posición real de la cámara en el mundo (en pixeles)
                this.camPos = { x: 0, y: 0 }; 
                this.camZoom = 1;
                
                this.drawP = { x: 0, y: 0 }; 
                this.cellSize = 40;
                this.visited = new Set();
                this.shake = 0; 

                this.staticCanvas = document.createElement('canvas');
                this.staticCtx = this.staticCanvas.getContext('2d');

                const saved = localStorage.getItem('maze_pro_v2');
                if(saved) this.state.lvl = Math.min(parseInt(saved) || 1, MAX_LEVEL);

                this.setupInputs();
                window.addEventListener('resize', () => this.resize());
                
                this.initLevel();
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            toggleMute() {
                const isMuted = this.audio.toggle();
                const btn = document.getElementById('mute-btn');
                btn.innerHTML = isMuted 
                    ? '<svg class="icon" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>'
                    : '<svg class="icon" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>';
                btn.style.opacity = isMuted ? 0.5 : 1;
            }

            async initLevel() {
                if(this.state.lvl > MAX_LEVEL) { 
                    alert("¡Juego Completado! Reiniciando..."); 
                    this.state.lvl = 1; 
                }
                
                const loader = document.getElementById('loading-modal');
                loader.style.display = 'flex';
                this.state.active = false;
                
                setTimeout(() => {
                    const fallbackSize = 9 + Math.floor(this.state.lvl * 1.5);
                    const cfg = LEVEL_CONFIG[this.state.lvl] || { size: fallbackSize, minSteps: fallbackSize * 2 };
                    document.getElementById('lvl-display').innerText = `NV ${this.state.lvl}`;
                    
                    let bestGrid = null, bestLen = 0, attempts = 0;
                    const MAX_ATTEMPTS = 50;

                    while(attempts < MAX_ATTEMPTS) {
                        attempts++;
                        let temp = this.generateMaze(cfg.size);
                        const sol = this.solveBFS({x:0,y:0}, {x:cfg.size-1, y:cfg.size-1}, temp);
                        if(sol) {
                            if(sol.dist >= cfg.minSteps) { bestGrid = temp; break; }
                            if(sol.dist > bestLen) { bestLen = sol.dist; bestGrid = temp; }
                        }
                    }

                    this.grid = bestGrid; 
                    this.state.p = {x:0, y:0};
                    this.state.g = {x:cfg.size-1, y:cfg.size-1};
                    
                    this.renderStaticLayer();
                    
                    this.state.active = true;
                    this.drawP = { ...this.state.p };
                    
                    // Centrar cámara inmediatamente al iniciar
                    this.camPos.x = this.state.p.x * this.cellSize + this.cellSize/2;
                    this.camPos.y = this.state.p.y * this.cellSize + this.cellSize/2;

                    this.visited = new Set(['0,0']);
                    this.resize();
                    
                    loader.style.display = 'none';
                    if(this.state.lvl > 1) document.getElementById('tutorial').style.display = 'none';
                }, 50);
            }

            generateMaze(size) {
                let grid = Array(size).fill().map((_,y) => Array(size).fill().map((_,x) => ({x,y, w:{t:1,r:1,b:1,l:1}, v:false})));
                let stack = [grid[0][0]];
                grid[0][0].v = true;

                while(stack.length) {
                    let currIdx = stack.length - 1;
                    if(Math.random() > 0.75) currIdx = Math.floor(Math.random() * stack.length);
                    let curr = stack[currIdx];
                    let neighbors = [[0,-1,'t','b'],[1,0,'r','l'],[0,1,'b','t'],[-1,0,'l','r']]
                        .map(d => ({x:curr.x+d[0], y:curr.y+d[1], w1:d[2], w2:d[3]}))
                        .filter(p => p.x>=0 && p.x<size && p.y>=0 && p.y<size && !grid[p.y][p.x].v);

                    if(neighbors.length) {
                        let n = neighbors[Math.floor(Math.random() * neighbors.length)];
                        let next = grid[n.y][n.x];
                        curr.w[n.w1] = 0; next.w[n.w2] = 0; next.v = true;
                        stack.push(next);
                    } else stack.splice(currIdx, 1);
                }
                if(this.state.lvl > 8) {
                    for(let i=0; i<size/2; i++) {
                        let rx = Math.floor(Math.random()*(size-2))+1;
                        let ry = Math.floor(Math.random()*(size-2))+1;
                        grid[ry][rx].w[['t','r','b','l'][Math.floor(Math.random()*4)]] = 0;
                    }
                }
                return grid;
            }

            solveBFS(start, end, grid) {
                let q = [{...start, dist:0}], visited = new Set([`${start.x},${start.y}`]);
                let ops = 0;
                while(q.length && ops++ < 5000) {
                    let curr = q.shift();
                    if(curr.x === end.x && curr.y === end.y) return curr;
                    const cell = grid[curr.y][curr.x];
                    [[0,-1,'t'],[1,0,'r'],[0,1,'b'],[-1,0,'l']].forEach(d => {
                        if(!cell.w[d[2]]) {
                            let nx = curr.x+d[0], ny = curr.y+d[1];
                            let key = `${nx},${ny}`;
                            if(!visited.has(key)) { visited.add(key); q.push({x:nx, y:ny, dist: curr.dist+1}); }
                        }
                    });
                }
                return null;
            }

            renderStaticLayer() {
                const s = this.grid.length;
                const cs = this.cellSize;
                this.staticCanvas.width = s * cs;
                this.staticCanvas.height = s * cs;
                const ctx = this.staticCtx;
                ctx.clearRect(0, 0, s*cs, s*cs);
                ctx.strokeStyle = '#334155'; 
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                this.grid.forEach(row => row.forEach(c => {
                    let x=c.x*cs, y=c.y*cs;
                    if(c.w.t) { ctx.moveTo(x,y); ctx.lineTo(x+cs,y); }
                    if(c.w.l) { ctx.moveTo(x,y); ctx.lineTo(x,y+cs); }
                    if(c.x===this.grid.length-1 && c.w.r) { ctx.moveTo(x+cs,y); ctx.lineTo(x+cs,y+cs); }
                    if(c.y===this.grid.length-1 && c.w.b) { ctx.moveTo(x,y+cs); ctx.lineTo(x+cs,y+cs); }
                }));
                ctx.stroke();
            }

            setupInputs() {
                const zone = document.getElementById('zone-joy');
                const base = document.getElementById('joy-ui');
                const stick = document.getElementById('joy-stick');
                let sx, sy, active = false;

                const start = (cx, cy) => {
                    this.audio.init(); active = true; sx = cx; sy = cy;
                    base.style.display = 'block'; base.style.left = sx+'px'; base.style.top = sy+'px';
                    stick.style.transform = `translate(-50%,-50%)`;
                };
                const move = (cx, cy) => {
                    if(!active) return;
                    const dx = cx - sx, dy = cy - sy;
                    const dist = Math.min(40, Math.hypot(dx, dy));
                    const ang = Math.atan2(dy, dx);
                    stick.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
                    if(dist > 15) {
                        if(Math.abs(dx)>Math.abs(dy)) this.move(dx>0?1:-1, 0);
                        else this.move(0, dy>0?1:-1);
                    }
                };
                const end = () => { active = false; base.style.display = 'none'; };

                zone.addEventListener('touchstart', e => { e.preventDefault(); start(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
                zone.addEventListener('touchmove', e => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
                zone.addEventListener('touchend', end);
                
                zone.addEventListener('mousedown', e => start(e.clientX, e.clientY));
                window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
                window.addEventListener('mouseup', end);

                const szone = document.getElementById('zone-swipe');
                let ssx, ssy, st;
                szone.addEventListener('touchstart', e => { this.audio.init(); ssx=e.touches[0].clientX; ssy=e.touches[0].clientY; st=Date.now(); }, {passive:true});
                szone.addEventListener('touchend', e => {
                    const dx = e.changedTouches[0].clientX - ssx, dy = e.changedTouches[0].clientY - ssy;
                    if(Math.abs(dx)<20 && Math.abs(dy)<20) return;
                    const mx = Math.abs(dx)>Math.abs(dy) ? (dx>0?1:-1) : 0;
                    const my = Math.abs(dx)>Math.abs(dy) ? 0 : (dy>0?1:-1);
                    this.move(mx, my, (Date.now() - st) < 250);
                });

                window.addEventListener('keydown', e => {
                    if(!this.state.active) return;
                    this.audio.init();
                    switch(e.key) {
                        case 'ArrowUp': case 'w': this.move(0, -1); break;
                        case 'ArrowDown': case 's': this.move(0, 1); break;
                        case 'ArrowLeft': case 'a': this.move(-1, 0); break;
                        case 'ArrowRight': case 'd': this.move(1, 0); break;
                    }
                });
            }

            move(dx, dy, dash = false) {
                if(!this.state.active || !this.grid.length) return;
                const now = Date.now();
                if(!dash && now - (this.lastMove || 0) < 110) return; 
                this.lastMove = now;

                const step = () => {
                    const {x, y} = this.state.p;
                    if(!this.grid[y] || !this.grid[y][x]) return false;
                    const c = this.grid[y][x];
                    
                    let blocked = false;
                    if(dy===-1 && c.w.t) blocked = true;
                    if(dx===1 && c.w.r) blocked = true;
                    if(dy===1 && c.w.b) blocked = true;
                    if(dx===-1 && c.w.l) blocked = true;

                    if(blocked) {
                        if(!dash) { 
                            this.shake = 5; 
                            this.audio.play('bump');
                        }
                        return false;
                    }
                    
                    this.state.p.x += dx; this.state.p.y += dy;
                    this.visited.add(`${this.state.p.x},${this.state.p.y}`);
                    if(!dash) this.audio.play('step');

                    if(this.state.p.x === this.state.g.x && this.state.p.y === this.state.g.y) {
                        this.win(); return false;
                    }
                    return true;
                };

                if(dash) {
                    let s = 0;
                    const iv = setInterval(() => { if(!step() || s++ > 40 || !this.state.active) clearInterval(iv); }, 30);
                } else step();
            }

            win() {
                if(!this.state.active) return;
                this.state.active = false;
                this.audio.play('win');
                
                const reward = 50 + ((this.state.lvl-1)*10);
                let msg = "Nivel Completado";
                if(window.GameCenter && typeof window.GameCenter.completeLevel === 'function') {
                    const r = window.GameCenter.completeLevel('maze', this.state.lvl, reward);
                    if(r && r.paid) msg = `<strong style="color:#10b981">+${reward} Monedas</strong>`;
                }
                document.getElementById('win-msg').innerHTML = msg;
                document.getElementById('win-modal').style.display = 'flex';
            }

            nextLevel() {
                this.state.lvl++;
                localStorage.setItem('maze_pro_v2', this.state.lvl);
                document.getElementById('win-modal').style.display = 'none';
                this.initLevel();
            }

            resize() {
                const p = document.getElementById('game-viewport');
                if(!p) return;
                this.canvas.width = p.clientWidth;
                this.canvas.height = p.clientHeight;
                if(this.grid.length) {
                    const baseV = window.innerWidth < 600 ? 9 : 14;
                    this.camZoom = this.canvas.width / ((baseV + Math.floor(this.state.lvl/3)) * this.cellSize);
                }
            }

            loop() {
                if (!this.grid.length) { requestAnimationFrame(this.loop); return; }

                // 1. Interpolación de JUGADOR (Sprite)
                this.drawP.x += (this.state.p.x - this.drawP.x) * 0.3;
                this.drawP.y += (this.state.p.y - this.drawP.y) * 0.3;

                // 2. Interpolación de CÁMARA (Suavizado extremo)
                // Objetivo: Centrar en el jugador
                const targetCamX = this.drawP.x * this.cellSize + this.cellSize/2;
                const targetCamY = this.drawP.y * this.cellSize + this.cellSize/2;
                
                // Mover cámara suavemente hacia el objetivo (factor 0.1 es muy suave)
                this.camPos.x += (targetCamX - this.camPos.x) * 0.1;
                this.camPos.y += (targetCamY - this.camPos.y) * 0.1;

                const w = this.canvas.width;
                const h = this.canvas.height;
                const scale = this.camZoom || 1;
                const cs = this.cellSize;

                // 3. Calcular renderizado
                let tx = w/2 - this.camPos.x * scale;
                let ty = h/2 - this.camPos.y * scale;
                
                // SHAKE (Vibración simple)
                if(this.shake > 0) {
                    tx += (Math.random()-0.5) * this.shake * 2;
                    ty += (Math.random()-0.5) * this.shake * 2;
                    this.shake *= 0.85; 
                    if(this.shake < 0.5) this.shake = 0;
                }

                const ctx = this.ctx;
                
                ctx.fillStyle = '#020617';
                ctx.fillRect(0,0,w,h);

                ctx.save();
                ctx.translate(tx, ty);
                ctx.scale(scale, scale);

                // Suelo visitado
                ctx.fillStyle = '#1e293b'; 
                for (const k of this.visited) {
                    const [vx, vy] = k.split(',');
                    ctx.fillRect(vx*cs, vy*cs, cs+0.5, cs+0.5); 
                }

                // Paredes (Pre-renderizadas)
                ctx.drawImage(this.staticCanvas, 0, 0);

                // Meta
                const time = Date.now()/300;
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#fbbf24'; ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.state.g.x*cs+cs/2, this.state.g.y*cs+cs/2, cs/4 + Math.sin(time)*2, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Jugador
                ctx.fillStyle = '#38bdf8';
                ctx.shadowColor = '#38bdf8'; ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.drawP.x*cs+cs/2, this.drawP.y*cs+cs/2, cs/3, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.restore();
                requestAnimationFrame(this.loop);
            }
        }

        window.onload = () => { window.game = new MazeGame(); };
    </script>
</body>
</html>
