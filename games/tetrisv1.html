<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Crystal | Love Arcade</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* --- 1. Variables & Reset --- */
        :root {
            --bg-deep: #050505;
            --glass-panel: rgba(30, 35, 50, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent: #facc15;
            --accent-glow: 0 0 15px rgba(250, 204, 21, 0.4);
            --text-main: #ffffff;
            --text-muted: #94a3b8;
            
            /* Tetris Colors */
            --c-cyan: #06b6d4; --c-blue: #3b82f6; --c-orange: #f97316;
            --c-yellow: #eab308; --c-green: #22c55e; --c-purple: #a855f7; --c-red: #ef4444;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-deep);
            background-image: radial-gradient(circle at 50% 0%, #1e1b4b 0%, #000 80%);
            color: var(--text-main);
            font-family: 'Segoe UI', system-ui, sans-serif;
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* --- 2. Layout Principal --- */
        #app-container {
            display: grid;
            grid-template-rows: 60px 1fr auto;
            height: 100%; width: 100%;
            max-width: 600px; margin: 0 auto;
            position: relative;
        }

        /* Header */
        header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--glass-border);
            z-index: 20;
        }
        .logo { font-weight: 900; font-size: 1.2rem; letter-spacing: 1px; text-shadow: 0 0 10px rgba(255,255,255,0.2); }
        .btn-icon {
            background: rgba(255,255,255,0.1); border: 1px solid var(--glass-border);
            color: white; padding: 8px; border-radius: 12px; cursor: pointer;
            transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        .btn-icon:active { background: var(--accent); color: black; }

        /* Game Area */
        .game-area {
            position: relative;
            display: flex; justify-content: center; align-items: center;
            padding: 10px; overflow: hidden;
        }

        /* Canvas Wrapper para mantener aspect ratio 1:2 */
        .canvas-wrapper {
            position: relative;
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI Overlay (Stats) */
        .stats-overlay {
            position: absolute; top: 10px; left: 10px;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none;
        }
        .stat-box {
            background: var(--glass-panel); border: 1px solid var(--glass-border);
            padding: 8px 12px; border-radius: 12px; backdrop-filter: blur(8px);
            text-align: left; min-width: 80px;
        }
        .stat-label { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; font-weight: bold; }
        .stat-val { font-size: 1.1rem; font-weight: 800; color: #fff; }
        .stat-val.gold { color: var(--accent); text-shadow: var(--accent-glow); }

        /* Next Piece Overlay */
        .next-overlay {
            position: absolute; top: 10px; right: 10px;
            background: var(--glass-panel); border: 1px solid var(--glass-border);
            padding: 8px; border-radius: 12px; backdrop-filter: blur(8px);
            pointer-events: none;
        }
        #next-canvas { width: 50px; height: 50px; display: block; }

        /* --- 3. Controles --- */
        #touch-zone {
            position: absolute; inset: 0; z-index: 10;
        }

        .controls-bar {
            padding: 20px; display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            z-index: 20; pointer-events: none;
        }
        .control-group { pointer-events: auto; display: flex; gap: 15px; }
        
        .c-btn {
            width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(5px); color: white;
            display: flex; align-items: center; justify-content: center;
            transition: 0.1s; cursor: pointer;
        }
        .c-btn:active { background: var(--accent); color: black; transform: scale(0.9); }
        .c-btn.large { width: 75px; height: 75px; background: rgba(139, 92, 246, 0.2); border-color: #8b5cf6; }

        /* --- 4. Modales --- */
        .modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; opacity: 0; pointer-events: none; transition: 0.3s;
        }
        .modal.visible { opacity: 1; pointer-events: auto; }
        
        .modal-card {
            background: #1e1e24; border: 1px solid var(--glass-border);
            padding: 30px; border-radius: 24px; text-align: center;
            width: 90%; max-width: 350px; box-shadow: 0 0 50px rgba(0,0,0,0.5);
            transform: translateY(20px); transition: 0.3s;
        }
        .modal.visible .modal-card { transform: translateY(0); }

        .btn-primary {
            background: var(--accent); color: black; border: none;
            width: 100%; padding: 15px; border-radius: 12px;
            font-weight: 800; font-size: 1.1rem; cursor: pointer;
            margin-top: 20px; box-shadow: var(--accent-glow);
        }
        .btn-primary:active { transform: scale(0.96); }
        .btn-sec {
            background: transparent; border: 1px solid var(--glass-border);
            color: var(--text-muted); width: 100%; padding: 10px;
            border-radius: 12px; margin-top: 10px; cursor: pointer;
        }

        /* --- 5. Debug Console (Hidden) --- */
        #debug-console {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 150px;
            background: rgba(0,0,0,0.9); color: #00ff00; font-family: monospace;
            font-size: 10px; padding: 10px; overflow-y: auto; z-index: 9999;
            display: none; border-top: 1px solid #00ff00;
        }

        /* --- 6. FX --- */
        .flash { animation: flash 0.1s; }
        @keyframes flash { 0% { background: white; } 100% { background: transparent; } }
        
        .toast {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            background: var(--success); color: black; padding: 8px 16px;
            border-radius: 20px; font-weight: bold; z-index: 200;
            opacity: 0; transition: 0.3s; pointer-events: none;
        }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(10px); }

    </style>
</head>
<body>

    <div id="app-container">
        <header>
            <button class="btn-icon" id="btn-back">
                <i data-lucide="arrow-left" size="20"></i>
            </button>
            <div class="logo">TETRIS CRYSTAL</div>
            <div style="display:flex; gap:10px;">
                <button class="btn-icon" id="btn-debug"><i data-lucide="terminal" size="18"></i></button>
                <button class="btn-icon" id="btn-sound"><i data-lucide="volume-2" size="20"></i></button>
                <button class="btn-icon" id="btn-pause"><i data-lucide="pause" size="20"></i></button>
            </div>
        </header>

        <div class="game-area" id="game-area">
            <div class="canvas-wrapper" id="canvas-wrapper">
                <canvas id="game-canvas"></canvas>
                <div id="flash-overlay" style="position:absolute; inset:0; pointer-events:none;"></div>
            </div>

            <div class="stats-overlay">
                <div class="stat-box">
                    <div class="stat-label">Puntos</div>
                    <div class="stat-val gold" id="ui-score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Nivel</div>
                    <div class="stat-val" id="ui-level">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Líneas</div>
                    <div class="stat-val" id="ui-lines">0</div>
                </div>
            </div>

            <div class="next-overlay">
                <div class="stat-label" style="margin-bottom:4px; text-align:center;">SIG.</div>
                <canvas id="next-canvas" width="60" height="60"></canvas>
            </div>
        </div>

        <div class="controls-bar">
            <div class="control-group">
                <button class="c-btn" id="btn-left"><i data-lucide="chevron-left"></i></button>
                <button class="c-btn" id="btn-down"><i data-lucide="chevron-down"></i></button>
                <button class="c-btn" id="btn-right"><i data-lucide="chevron-right"></i></button>
            </div>
            <div class="control-group">
                <button class="c-btn large" id="btn-rotate"><i data-lucide="rotate-cw" size="32"></i></button>
            </div>
        </div>

        <div id="touch-zone"></div>
    </div>

    <div id="modal-start" class="modal visible">
        <div class="modal-card">
            <h2 style="color:var(--accent); margin:0;">TETRIS CRYSTAL</h2>
            <p style="color:var(--text-muted); margin-bottom:20px;">Rompe récords y gana monedas.</p>
            <div class="stat-label">Récord Actual</div>
            <div class="stat-val gold" id="modal-hs">0</div>
            <button class="btn-primary" id="btn-start">JUGAR AHORA</button>
            <button class="btn-sec" id="btn-rules">Instrucciones</button>
        </div>
    </div>

    <div id="modal-gameover" class="modal">
        <div class="modal-card">
            <h2 style="color:#ef4444; margin:0;">GAME OVER</h2>
            <p style="color:var(--text-muted);">Buen intento.</p>
            <div class="stat-label">Puntuación Final</div>
            <div class="stat-val gold" id="final-score" style="font-size:2rem; margin:10px 0;">0</div>
            <button class="btn-primary" id="btn-restart">REINTENTAR</button>
            <button class="btn-sec" onclick="window.location.href='../index.html'">Salir</button>
        </div>
    </div>

    <div id="modal-rules" class="modal">
        <div class="modal-card" style="text-align:left;">
            <h3 style="color:var(--accent);">Controles</h3>
            <ul style="padding-left:20px; color:var(--text-muted); font-size:0.9rem; line-height:1.6;">
                <li><strong>Deslizar lados:</strong> Mover pieza</li>
                <li><strong>Toque corto:</strong> Rotar</li>
                <li><strong>Deslizar abajo:</strong> Caída rápida</li>
                <li><strong>Botones:</strong> Usa los botones en pantalla si prefieres.</li>
            </ul>
            <h3 style="color:var(--accent); margin-top:15px;">Monedas</h3>
            <p style="color:var(--text-muted); font-size:0.9rem;">Gana <strong>1,000 monedas</strong> por cada 1,000 puntos (Máx 10k).</p>
            <button class="btn-primary" onclick="document.getElementById('modal-rules').classList.remove('visible')">ENTENDIDO</button>
        </div>
    </div>

    <div id="toast" class="toast">Notificación</div>

    <div id="debug-console"></div>

    <script src="../js/app.js"></script>
    <script>
        /**
         * ===============================================================
         * MODULE: DEBUG SYSTEM
         * ===============================================================
         */
        const Debug = {
            enabled: false,
            el: document.getElementById('debug-console'),
            init() {
                // Global error handler
                window.onerror = (msg, src, line, col, error) => {
                    this.error('GLOBAL', msg, { src, line, error });
                };
            },
            toggle() {
                this.enabled = !this.enabled;
                this.el.style.display = this.enabled ? 'block' : 'none';
                this.log('SYS', `Debug mode: ${this.enabled}`);
            },
            log(section, msg, data = null) {
                if (!this.enabled) return;
                const time = new Date().toLocaleTimeString();
                const logLine = `[${time}] [${section}] ${msg}`;
                console.log(logLine, data || '');
                
                const div = document.createElement('div');
                div.textContent = logLine;
                this.el.prepend(div);
            },
            error(section, msg, data = null) {
                console.error(`[${section}] ${msg}`, data);
                if (this.enabled) {
                    const div = document.createElement('div');
                    div.style.color = '#ef4444';
                    div.textContent = `[ERR][${section}] ${msg}`;
                    this.el.prepend(div);
                }
            },
            snapshot(state) {
                if (!this.enabled) return;
                console.group('GAME SNAPSHOT');
                console.table(state);
                console.groupEnd();
            }
        };

        /**
         * ===============================================================
         * MODULE: CONFIG & CONSTANTS
         * ===============================================================
         */
        const Config = {
            COLS: 10,
            ROWS: 20,
            ASPECT_RATIO: 0.5, // 10 / 20
            COLORS: [null, '#06b6d4', '#3b82f6', '#f97316', '#eab308', '#22c55e', '#a855f7', '#ef4444'],
            SHAPES: [
                [], 
                [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], // I
                [[2,0,0],[2,2,2],[0,0,0]], // J
                [[0,0,3],[3,3,3],[0,0,0]], // L
                [[4,4],[4,4]], // O
                [[0,5,5],[5,5,0],[0,0,0]], // S
                [[0,6,0],[6,6,6],[0,0,0]], // T
                [[7,7,0],[0,7,7],[0,0,0]]  // Z
            ],
            REWARD_RATE: 1000, // 1 coin per X points logic -> No, user wants 1k coins per 1k points
            MAX_COINS: 10000
        };

        /**
         * ===============================================================
         * MODULE: STORAGE
         * ===============================================================
         */
        const Storage = {
            key: 'tetris_v_final',
            data: {
                highScore: 0,
                coinsEarned: 0, // Total coins awarded historically
                savedGame: null
            },
            init() {
                try {
                    const s = localStorage.getItem(this.key);
                    if (s) this.data = JSON.parse(s);
                } catch (e) { Debug.error('STORAGE', 'Corrupt data', e); }
            },
            save() {
                try { localStorage.setItem(this.key, JSON.stringify(this.data)); } 
                catch (e) { Debug.error('STORAGE', 'Save failed', e); }
            },
            getHighScore() { return this.data.highScore; },
            setHighScore(score) { 
                if (score > this.data.highScore) {
                    this.data.highScore = score; 
                    this.save(); 
                }
            },
            // Reward Logic: 1k coins every 1000 points in a single game session?
            // Or cumulative? "1k de monedas cada 1,000 puntos en el juego, hasta llegar al tope de 10,000"
            // Interpreted as: Cumulative global earnings.
            checkRewards(currentScore) {
                if (this.data.coinsEarned >= Config.MAX_COINS) return;

                // Calculate total potential coins from this score
                const potential = Math.floor(currentScore / 1000) * 1000;
                
                // We need a session tracker so we don't award twice for same 1000 points in same game
                // Simplified: Pass the delta to external handler or just return value
                return potential;
            }
        };

        /**
         * ===============================================================
         * MODULE: AUDIO SYSTEM (WebAudio)
         * ===============================================================
         */
        const AudioSys = {
            ctx: null,
            muted: false,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            play(type) {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                // Filter for "muffled" glass effect
                const filter = this.ctx.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                
                if (type === 'move') {
                    osc.type = 'triangle'; filter.type = 'lowpass'; filter.frequency.value = 800;
                    osc.frequency.setValueAtTime(200, now); gain.gain.setValueAtTime(0.05, now);
                    osc.start(now); osc.stop(now+0.05);
                } else if (type === 'rotate') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
                    gain.gain.setValueAtTime(0.05, now); osc.start(now); osc.stop(now+0.05);
                } else if (type === 'drop') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(100, now);
                    gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now+0.1);
                } else if (type === 'clear') {
                    osc.type = 'triangle'; osc.frequency.linearRampToValueAtTime(800, now+0.3);
                    gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now+0.3);
                } else if (type === 'gameover') {
                    osc.type = 'sawtooth'; osc.frequency.linearRampToValueAtTime(50, now+1);
                    gain.gain.setValueAtTime(0.2, now); osc.start(now); osc.stop(now+1);
                }
            },
            toggle() {
                this.muted = !this.muted;
                const icon = this.muted ? 'volume-x' : 'volume-2';
                document.getElementById('btn-sound').innerHTML = `<i data-lucide="${icon}" size="20"></i>`;
                lucide.createIcons();
                this.init();
            }
        };

        /**
         * ===============================================================
         * MODULE: RENDERER (Glass Canvas)
         * ===============================================================
         */
        const Renderer = {
            canvas: document.getElementById('game-canvas'),
            ctx: document.getElementById('game-canvas').getContext('2d'),
            nextCanvas: document.getElementById('next-canvas'),
            nextCtx: document.getElementById('next-canvas').getContext('2d'),
            blockSize: 0,

            resize() {
                const wrapper = document.getElementById('canvas-wrapper');
                const maxH = wrapper.clientHeight;
                const maxW = wrapper.clientWidth;

                // Calculate Dimensions (Keep 1:2 ratio)
                let h = maxH;
                let w = h * Config.ASPECT_RATIO;

                if (w > maxW) {
                    w = maxW;
                    h = w / Config.ASPECT_RATIO;
                }

                // Apply logic size
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = w * dpr;
                this.canvas.height = h * dpr;
                
                // CSS size
                this.canvas.style.width = `${w}px`;
                this.canvas.style.height = `${h}px`;

                // Scale context
                this.ctx.scale(dpr, dpr);
                this.blockSize = w / Config.COLS;

                Debug.log('RENDER', 'Resized', { w, h, bs: this.blockSize });
            },

            drawBoard(grid) {
                // Clear
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // Transparent for CSS background

                // Grid Lines (Subtle)
                this.ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for (let x = 0; x <= Config.COLS; x++) {
                    this.ctx.moveTo(x * this.blockSize, 0);
                    this.ctx.lineTo(x * this.blockSize, Config.ROWS * this.blockSize);
                }
                for (let y = 0; y <= Config.ROWS; y++) {
                    this.ctx.moveTo(0, y * this.blockSize);
                    this.ctx.lineTo(Config.COLS * this.blockSize, y * this.blockSize);
                }
                this.ctx.stroke();

                // Draw Grid Blocks
                grid.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) this.drawBlock(this.ctx, x, y, value);
                    });
                });
            },

            drawPiece(piece, ghostY = null) {
                // Draw Ghost first
                if (ghostY !== null) {
                    this.ctx.globalAlpha = 0.2;
                    piece.matrix.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value !== 0) {
                                this.drawBlock(this.ctx, x + piece.x, y + ghostY, value, true);
                            }
                        });
                    });
                    this.ctx.globalAlpha = 1.0;
                }

                // Draw Active
                piece.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            this.drawBlock(this.ctx, x + piece.x, y + piece.y, value);
                        }
                    });
                });
            },

            drawBlock(ctx, x, y, colorIndex, isGhost = false) {
                const s = this.blockSize;
                const color = Config.COLORS[colorIndex];
                const px = x * s;
                const py = y * s;
                const gap = 1;

                // Glass/Neon Style
                if (isGhost) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(px + gap, py + gap, s - gap*2, s - gap*2);
                } else {
                    // Base
                    ctx.fillStyle = color;
                    ctx.fillRect(px + gap, py + gap, s - gap*2, s - gap*2);
                    
                    // Highlight (Top/Left)
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.fillRect(px + gap, py + gap, s - gap*2, s * 0.2);
                    
                    // Shadow (Bottom/Right)
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(px + gap, py + s - (s*0.2), s - gap*2, s * 0.2);
                    
                    // Glow border
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(px + gap, py + gap, s - gap*2, s - gap*2);
                }
            },

            drawNext(type) {
                const ctx = this.nextCtx;
                const w = this.nextCanvas.width;
                const h = this.nextCanvas.height;
                const bs = w / 5; // Mini block size

                ctx.clearRect(0, 0, w, h);
                const matrix = Config.SHAPES[type];
                
                // Center offset
                const offsetX = (5 - matrix[0].length) / 2;
                const offsetY = (5 - matrix.length) / 2;

                matrix.forEach((row, y) => {
                    row.forEach((val, x) => {
                        if (val !== 0) {
                            ctx.fillStyle = Config.COLORS[val];
                            ctx.fillRect((x + offsetX) * bs, (y + offsetY) * bs, bs - 1, bs - 1);
                        }
                    });
                });
            },

            flash() {
                const el = document.getElementById('flash-overlay');
                el.classList.remove('flash');
                void el.offsetWidth;
                el.classList.add('flash');
            }
        };

        /**
         * ===============================================================
         * MODULE: ENGINE (Logic)
         * ===============================================================
         */
        const Engine = {
            grid: [],
            player: { pos: {x:0, y:0}, matrix: null, score: 0, level: 1, lines: 0 },
            nextPieceType: 0,
            
            // State
            dropCounter: 0,
            dropInterval: 1000,
            lastTime: 0,
            isRunning: false,
            isPaused: false,
            inputLock: false, // Spawn delay
            
            // Rewards tracking for current session
            sessionRewardTracker: 0,

            init() {
                Debug.log('ENGINE', 'Initializing');
                this.grid = this.createMatrix(Config.COLS, Config.ROWS);
                Storage.init();
                
                // Setup resize listener
                window.addEventListener('resize', () => {
                    Renderer.resize();
                    if (!this.isRunning && !this.isPaused) this.draw(); // Redraw if idle
                });
                Renderer.resize();
                
                UI.updateStats(0, 1, 0, Storage.getHighScore());
            },

            createMatrix(w, h) {
                const matrix = [];
                while (h--) matrix.push(new Array(w).fill(0));
                return matrix;
            },

            start() {
                Debug.log('ENGINE', 'Start Game');
                this.grid = this.createMatrix(Config.COLS, Config.ROWS);
                this.player.score = 0;
                this.player.lines = 0;
                this.player.level = 1;
                this.sessionRewardTracker = 0;
                this.dropInterval = 1000;
                this.dropCounter = 0;
                
                this.nextPieceType = this.randomPiece();
                this.playerReset();
                
                this.isRunning = true;
                this.isPaused = false;
                this.lastTime = 0;
                
                AudioSys.init(); // Unlock audio context
                UI.hideModals();
                
                requestAnimationFrame(this.update.bind(this));
            },

            update(time = 0) {
                if (!this.isRunning) return;
                
                if (!this.isPaused) {
                    const deltaTime = time - this.lastTime;
                    this.lastTime = time;
                    this.dropCounter += deltaTime;

                    if (this.dropCounter > this.dropInterval) {
                        this.playerDrop();
                    }
                }

                this.draw();
                requestAnimationFrame(this.update.bind(this));
            },

            draw() {
                Renderer.drawBoard(this.grid);
                
                // Ghost
                let ghostY = this.player.pos.y;
                while (!this.collide(this.grid, { x: this.player.pos.x, y: ghostY + 1 }, this.player.matrix)) {
                    ghostY++;
                }
                
                Renderer.drawPiece({
                    x: this.player.pos.x,
                    y: this.player.pos.y,
                    matrix: this.player.matrix
                }, ghostY);
            },

            playerReset() {
                const type = this.nextPieceType;
                this.nextPieceType = this.randomPiece();
                Renderer.drawNext(this.nextPieceType);

                this.player.matrix = Config.SHAPES[type];
                this.player.pos.y = 0;
                this.player.pos.x = (this.grid[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);

                // Spawn Lock
                this.inputLock = true;
                setTimeout(() => this.inputLock = false, 300);

                if (this.collide(this.grid, this.player.pos, this.player.matrix)) {
                    this.gameOver();
                }
            },

            playerDrop() {
                if (this.inputLock) return;
                this.player.pos.y++;
                if (this.collide(this.grid, this.player.pos, this.player.matrix)) {
                    this.player.pos.y--;
                    this.merge(this.grid, this.player);
                    this.arenaSweep();
                    this.playerReset();
                }
                this.dropCounter = 0;
            },

            playerMove(dir) {
                if (this.isPaused || !this.isRunning || this.inputLock) return;
                this.player.pos.x += dir;
                if (this.collide(this.grid, this.player.pos, this.player.matrix)) {
                    this.player.pos.x -= dir;
                } else {
                    AudioSys.play('move');
                }
            },

            playerRotate(dir = 1) {
                if (this.isPaused || !this.isRunning || this.inputLock) return;
                const pos = this.player.pos.x;
                let offset = 1;
                this.rotateMatrix(this.player.matrix, dir);
                while (this.collide(this.grid, this.player.pos, this.player.matrix)) {
                    this.player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > this.player.matrix[0].length) {
                        this.rotateMatrix(this.player.matrix, -dir);
                        this.player.pos.x = pos;
                        return;
                    }
                }
                AudioSys.play('rotate');
            },

            rotateMatrix(matrix, dir) {
                for (let y = 0; y < matrix.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                    }
                }
                if (dir > 0) matrix.forEach(row => row.reverse());
                else matrix.reverse();
            },

            collide(arena, pos, matrix) {
                for (let y = 0; y < matrix.length; ++y) {
                    for (let x = 0; x < matrix[y].length; ++x) {
                        if (matrix[y][x] !== 0 &&
                           (arena[y + pos.y] && arena[y + pos.y][x + pos.x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            },

            merge(arena, player) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            arena[y + player.pos.y][x + player.pos.x] = value;
                        }
                    });
                });
                AudioSys.play('drop');
            },

            arenaSweep() {
                let rowCount = 0;
                outer: for (let y = this.grid.length - 1; y > 0; --y) {
                    for (let x = 0; x < this.grid[y].length; ++x) {
                        if (this.grid[y][x] === 0) continue outer;
                    }
                    const row = this.grid.splice(y, 1)[0].fill(0);
                    this.grid.unshift(row);
                    ++y;
                    rowCount++;
                }

                if (rowCount > 0) {
                    AudioSys.play('clear');
                    Renderer.flash();
                    
                    const points = [0, 40, 100, 300, 1200];
                    const gainedScore = points[rowCount] * this.player.level;
                    this.player.score += gainedScore;
                    this.player.lines += rowCount;
                    this.player.level = Math.floor(this.player.lines / 10) + 1;
                    this.dropInterval = Math.max(100, 1000 - (this.player.level * 50));

                    // Reward System Check (1k coins per 1k points)
                    // Logic: Check if we crossed a 1000 threshold
                    const totalPoints = this.player.score;
                    const milestones = Math.floor(totalPoints / 1000);
                    const newMilestones = milestones - this.sessionRewardTracker;
                    
                    if (newMilestones > 0) {
                        const earnedCoins = newMilestones * 1000;
                        this.sessionRewardTracker = milestones;
                        
                        // Storage Check
                        const currentTotalCoins = Storage.data.coinsEarned;
                        if (currentTotalCoins + earnedCoins <= Config.MAX_COINS) {
                            Storage.data.coinsEarned += earnedCoins;
                            Storage.save();
                            UI.showToast(`+${earnedCoins} Monedas!`, 'success');
                            
                            // Integration with Parent System
                            if (window.GameCenter) {
                                window.GameCenter.completeLevel('tetris_milestone', milestones, earnedCoins);
                            }
                        }
                    }

                    Storage.setHighScore(this.player.score);
                    UI.updateStats(this.player.score, this.player.level, this.player.lines, Storage.getHighScore());
                }
            },

            gameOver() {
                this.isRunning = false;
                AudioSys.play('gameover');
                Debug.log('ENGINE', 'Game Over', { score: this.player.score });
                Storage.setHighScore(this.player.score);
                UI.showModal('gameover', this.player.score);
            },

            togglePause() {
                if (!this.isRunning) return;
                this.isPaused = !this.isPaused;
                if (this.isPaused) UI.showModal('pause');
                else UI.hideModals();
            },

            randomPiece() {
                return (Math.random() * 7 | 0) + 1;
            },

            hardDrop() { // Now behaves as soft drop boost
                this.dropInterval = 50; 
            },
            resetDropSpeed() {
                this.dropInterval = Math.max(100, 1000 - (this.player.level * 50));
            }
        };

        /**
         * ===============================================================
         * MODULE: INPUT
         * ===============================================================
         */
        const Input = {
            touch: { sx: 0, sy: 0, lastX: 0 },
            
            init() {
                // Keyboard
                document.addEventListener('keydown', e => {
                    if (e.code === 'ArrowLeft') Engine.playerMove(-1);
                    else if (e.code === 'ArrowRight') Engine.playerMove(1);
                    else if (e.code === 'ArrowDown') Engine.playerDrop();
                    else if (e.code === 'ArrowUp') Engine.playerRotate();
                    else if (e.code === 'Escape') Engine.togglePause();
                });

                // Touch (Swipe)
                const zone = document.getElementById('touch-zone');
                
                zone.addEventListener('touchstart', e => {
                    // Safe zone check: Don't swipe if touching controls
                    if (e.target.closest('button')) return;
                    e.preventDefault();
                    this.touch.sx = e.touches[0].clientX;
                    this.touch.sy = e.touches[0].clientY;
                    AudioSys.init();
                }, {passive:false});

                zone.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - this.touch.sx;
                    const dy = e.touches[0].clientY - this.touch.sy;

                    if (Math.abs(dx - this.touch.lastX) > 25) {
                        Engine.playerMove(dx > this.touch.lastX ? 1 : -1);
                        this.touch.lastX = dx;
                    }
                    if (dy > 60) Engine.playerDrop();
                }, {passive:false});

                zone.addEventListener('touchend', e => {
                    const dx = e.changedTouches[0].clientX - this.touch.sx;
                    const dy = e.changedTouches[0].clientY - this.touch.sy;
                    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) Engine.playerRotate();
                    this.touch.lastX = 0;
                });

                // On Screen Buttons
                this.bindBtn('btn-left', () => Engine.playerMove(-1));
                this.bindBtn('btn-right', () => Engine.playerMove(1));
                this.bindBtn('btn-down', () => Engine.playerDrop());
                this.bindBtn('btn-rotate', () => Engine.playerRotate());
                
                document.getElementById('btn-back').onclick = () => window.location.href = '../index.html';
                document.getElementById('btn-pause').onclick = () => Engine.togglePause();
                document.getElementById('btn-debug').onclick = () => Debug.toggle();
            },

            bindBtn(id, action) {
                const btn = document.getElementById(id);
                if (!btn) return;
                let interval;
                const start = (e) => {
                    e.preventDefault();
                    action();
                    interval = setInterval(action, 120);
                };
                const end = (e) => {
                    e.preventDefault();
                    clearInterval(interval);
                };
                btn.addEventListener('touchstart', start, {passive:false});
                btn.addEventListener('touchend', end);
                btn.addEventListener('mousedown', start);
                btn.addEventListener('mouseup', end);
            }
        };

        /**
         * ===============================================================
         * MODULE: UI Helpers
         * ===============================================================
         */
        const UI = {
            updateStats(s, l, li, hs) {
                document.getElementById('ui-score').textContent = s;
                document.getElementById('ui-level').textContent = l;
                document.getElementById('ui-lines').textContent = li;
                document.getElementById('modal-hs').textContent = hs;
            },
            showModal(type, score=0, cb) {
                const m = document.getElementById(type === 'gameover' ? 'modal-gameover' : 'modal-start');
                document.querySelectorAll('.modal').forEach(x => x.classList.remove('visible'));
                
                if (type === 'pause') return; // Pause logic handled inside Engine toggle

                if (type === 'gameover') {
                    document.getElementById('final-score').textContent = score;
                    const btn = document.getElementById('btn-restart');
                    btn.onclick = cb;
                } else if (type === 'start') {
                    const btn = document.getElementById('btn-start');
                    btn.onclick = cb;
                }
                
                m.classList.add('visible');
            },
            hideModals() {
                document.querySelectorAll('.modal').forEach(x => x.classList.remove('visible'));
            },
            showToast(msg) {
                const t = document.getElementById('toast');
                t.textContent = msg;
                t.classList.add('show');
                setTimeout(() => t.classList.remove('show'), 3000);
            }
        };

        // --- INIT ---
        window.onload = () => {
            Debug.init();
            Engine.init();
            Input.init();
            lucide.createIcons();
        };

    </script>
</body>
</html>
