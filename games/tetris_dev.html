<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Neo Debug</title>
    <style>
        :root { --bg-1: #10141B; --bg-2: #161C24; --panel: #1F2732; --accent: #4ADE80; --accent-2: #60A5FA; --danger: #F87171; --text-1: #E2E8F0; --text-2: #94A3B8; --font-main: "Inter", system-ui, sans-serif; --glass-bg: rgba(255, 255, 255, 0.05); --glass-border: 1px solid rgba(255, 255, 255, 0.1); }
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; outline: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: var(--font-main); background: linear-gradient(180deg, var(--bg-1), var(--bg-2)); color: var(--text-1); }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--accent); color: #000; padding: 8px; z-index: 1000; transition: top 0.2s; }
        .skip-link:focus { top: 0; }
        #bg-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; opacity: 0.1; pointer-events: none; }
        #game-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 10; transition: opacity 0.2s ease; }
        .screen.active { display: flex; animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .overlay { background: rgba(16, 20, 27, 0.85); backdrop-filter: blur(12px); border-radius: 20px; padding: 40px 20px; }
        .overlay h2 { font-size: 2.2rem; margin-bottom: 10px; color: var(--text-1); text-align: center; }
        .overlay p { font-size: 1.1rem; color: var(--text-2); margin-bottom: 30px; }
        .title { font-size: 4rem; font-weight: 900; margin-bottom: 3rem; display: flex; gap: 2px; z-index: 2; }
        .t-let:nth-child(1) { color: #22d3ee; } .t-let:nth-child(2) { color: #3b82f6; } .t-let:nth-child(3) { color: #fb923c; } .t-let:nth-child(4) { color: #facc15; } .t-let:nth-child(5) { color: #4ade80; } .t-let:nth-child(6) { color: #a855f7; }
        .btn { border: none; padding: 16px 32px; font-size: 1.15rem; font-weight: 600; border-radius: 14px; cursor: pointer; margin: 12px; min-width: 200px; text-decoration: none; text-align: center; box-shadow: 0 4px 14px rgba(0,0,0,0.25); transition: transform 0.1s; position: relative; overflow: hidden; }
        .btn:active { transform: scale(0.96); }
        .btn-green { background: linear-gradient(135deg, #4ADE80, #22C55E); color: #064E3B; }
        .btn-orange { background: linear-gradient(135deg, #60A5FA, #3B82F6); color: #EFF6FF; }
        .btn-red { background: linear-gradient(135deg, #F87171, #EF4444); color: #FEF2F2; }
        .pulse { animation: softPulse 2s infinite ease-in-out; }
        @keyframes softPulse { 0% { transform: scale(1); } 50% { transform: scale(1.03); } 100% { transform: scale(1); } }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; flex-direction: column; padding: 15px; z-index: 20; }
        .hud-top { display: flex; justify-content: center; width: 100%; max-width: 420px; margin: 0 auto; gap: 12px; pointer-events: auto; }
        .hud-box { background: var(--glass-bg); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); border-radius: 14px; display: flex; flex-direction: column; flex: 1; text-align: center; padding: 8px 0; }
        .hud-label { font-size: 0.7rem; color: var(--text-2); font-weight: 600; letter-spacing: 1px; margin-bottom: 2px; }
        .hud-value { font-size: 1.3rem; font-weight: 700; color: var(--text-1); }
        #btn-pause { position: absolute; top: 20px; right: 20px; width: 44px; height: 44px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; pointer-events: auto; cursor: pointer; z-index: 50; color: var(--text-1); }
        #tetris-canvas { display: block; margin: auto; border-radius: 14px; box-shadow: 0 0 40px rgba(0,0,0,0.65); background: linear-gradient(180deg, #0f141a, #161c24); }
        #drawer-toggle { position: absolute; top: 20px; left: 20px; font-size: 1.5rem; cursor: pointer; z-index: 100; color: var(--text-1); width: 44px; height: 44px; text-align: center; line-height: 44px; background: rgba(255,255,255,0.05); border-radius: 12px; backdrop-filter: blur(5px); display: block; }
        #drawer-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 101; display: none; opacity: 0; transition: opacity 0.3s; }
        #drawer-overlay.visible { display: block; opacity: 1; }
        #drawer { position: fixed; top: 0; left: -340px; width: 300px; height: 100%; background: var(--panel); border-right: 1px solid rgba(255,255,255,0.08); border-radius: 0 24px 24px 0; transition: left 0.35s; z-index: 102; padding: 25px; overflow-y: auto; display: flex; flex-direction: column; }
        #drawer.open { left: 0; }
        .drawer-top-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; border-bottom: 1px solid rgba(255,255,255,0.08); padding-bottom: 15px; }
        .drawer-section { margin-bottom: 30px; }
        .drawer-header { font-size: 0.85rem; margin-bottom: 15px; color: var(--accent); font-weight: 700; text-transform: uppercase; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 18px; color: var(--text-1); font-size: 0.95rem; }
        input[type="checkbox"] { appearance: none; width: 42px; height: 24px; background: #334155; border-radius: 50px; position: relative; cursor: pointer; transition: background 0.3s; }
        input[type="checkbox"]::after { content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: #fff; border-radius: 50%; transition: transform 0.3s; }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(18px); }
        .level-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .lvl-btn { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); color: var(--text-2); padding: 12px 0; border-radius: 10px; cursor: pointer; text-align: center; font-size: 0.9rem; font-weight: 600; }
        .lvl-btn:disabled { opacity: 0.2; cursor: not-allowed; }
        .lvl-btn.unlocked { background: rgba(96, 165, 250, 0.15); border-color: rgba(96, 165, 250, 0.3); color: var(--accent-2); }
        .lvl-btn.completed { background: var(--accent); border-color: var(--accent); color: #064E3B; }
        #next-canvas { display: block; margin: 0 auto; filter: drop-shadow(0 0 5px rgba(0,0,0,0.3)); }
        body.gameplay-mode * { animation: none !important; transition: none !important; }
    </style>
</head>
<body>

    <a href="#game-container" class="skip-link">Saltar al juego</a>
    <canvas id="bg-canvas"></canvas>

    <div id="drawer-toggle">☰</div>
    <div id="drawer-overlay"></div>

    <aside id="drawer">
        <div class="drawer-top-bar">
            <span>Ajustes</span>
            <div id="drawer-close" style="cursor:pointer;">✕</div>
        </div>
        <div class="drawer-section">
            <div class="drawer-header">Audio</div>
            <div class="setting-row"><label>Música</label><input type="checkbox" id="toggle-music" checked></div>
            <div class="setting-row"><label>SFX</label><input type="checkbox" id="toggle-sfx" checked></div>
        </div>
        <div class="drawer-section">
            <div class="drawer-header">Juego</div>
            <div class="setting-row"><label>Fantasma</label><input type="checkbox" id="toggle-ghost" checked></div>
            <div class="setting-row" style="flex-direction:column; align-items:flex-start;">
                <label>Sensibilidad: <span id="sens-val">5</span></label>
                <input type="range" id="slider-sens" min="1" max="10" value="5" style="width:100%">
            </div>
        </div>
        <div class="drawer-section">
            <div class="drawer-header">Niveles</div>
            <div class="level-grid" id="level-grid"></div>
        </div>
    </aside>

    <div id="game-container">
        <div id="screen-start" class="screen active">
            <div class="title"><span class="t-let">T</span>ETRIS</div>
            <p style="color:var(--text-2); margin-bottom:30px;">NEO ARCADE</p>
            <button id="btn-start" class="btn btn-green pulse">JUGAR</button>
            <a href="../index.html" class="btn btn-red">SALIR</a>
        </div>

        <div id="screen-game" class="screen">
            <div id="game-ui">
                <div class="hud-top">
                    <div class="hud-box"><div class="hud-label">MOVS</div><div class="hud-value" id="hud-moves">0</div></div>
                    <div class="hud-box" style="flex:2;"><div class="hud-label">OBJETIVO</div><div class="hud-value" id="hud-obj-val">--</div></div>
                    <div class="hud-box"><div class="hud-label">SIG</div><canvas id="next-canvas" width="60" height="60"></canvas></div>
                </div>
                <div id="btn-pause">||</div>
            </div>
            <canvas id="tetris-canvas"></canvas>
        </div>

        <div id="screen-pause" class="screen overlay">
            <h2>PAUSA</h2>
            <button id="btn-resume" class="btn btn-green">CONTINUAR</button>
            <button id="btn-quit-level" class="btn btn-orange">MENÚ</button>
        </div>
        <div id="screen-gameover" class="screen overlay">
            <h2 style="color:var(--danger)">GAME OVER</h2>
            <p id="go-reason">Inténtalo de nuevo</p>
            <button id="btn-retry" class="btn btn-green">REINTENTAR</button>
            <button id="btn-go-menu" class="btn btn-red">SALIR</button>
        </div>
        <div id="screen-win" class="screen overlay">
            <h2 style="color:var(--accent)">¡COMPLETADO!</h2>
            <p>Puntos: <span id="win-score">0</span></p>
            <p style="color:var(--accent-2)">Monedas: +<span id="win-coins">0</span></p>
            <button id="btn-next-level" class="btn btn-green">SIGUIENTE</button>
            <button id="btn-win-menu" class="btn btn-orange">MENÚ</button>
        </div>
    </div>

    <script src="../js/app.js" defer></script>

    <script>
        const CONFIG = { GRID_W: 10, GRID_H: 20, STORAGE_KEY: "tetris_final_fix", SETTINGS_KEY: "tetris_set_fix", DROP_INTERVAL: 1000, BG_FPS: 12 };
        const COLORS = { I:"#22d3ee", J:"#3b82f6", L:"#fb923c", O:"#facc15", S:"#4ade80", T:"#a855f7", Z:"#f87171", GHOST:"rgba(255,255,255,0.1)" };
        const SHAPES = { I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], J:[[1,0,0],[1,1,1],[0,0,0]], L:[[0,0,1],[1,1,1],[0,0,0]], O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0],[0,0,0]], T:[[0,1,0],[1,1,1],[0,0,0]], Z:[[1,1,0],[0,1,1],[0,0,0]] };
        const SHAPE_KEYS = Object.keys(SHAPES);
        const PIECE_CACHE = {}; let cellSize = 30;

        const LEVELS = [
            { id:1, name:"Nivel 1", obj:{type:"lines", val:1}, moves:50, coins:100 },
            { id:2, name:"Nivel 2", obj:{type:"points", val:2000}, moves:60, coins:10 },
            { id:3, name:"Nivel 3", obj:{type:"lines", val:10}, moves:70, coins:15 },
            { id:4, name:"Nivel 4", obj:{type:"points", val:5000}, moves:80, coins:20 },
            { id:5, name:"Nivel 5", obj:{type:"lines", val:15}, moves:90, coins:25 },
            { id:6, name:"Nivel 6", obj:{type:"points", val:10000}, moves:100, coins:30 },
            { id:7, name:"Nivel 7", obj:{type:"lines", val:20}, moves:110, coins:40 },
            { id:8, name:"Nivel 8", obj:{type:"points", val:20000}, moves:120, coins:50 },
            { id:9, name:"Nivel 9", obj:{type:"lines", val:30}, moves:140, coins:75 },
            { id:10, name:"MAESTRO", obj:{type:"lines", val:40}, moves:160, coins:100 }
        ];

        let canvas, ctx, nextCanvas, nextCtx, bgCanvas, bgCtx;
        let lastTime = 0, dropCounter = 0, currentLevelIdx = 0, isPaused = false, gameActive = false;
        let grid = [], player = {}, nextPieceType = null, particles = [];
        let settings = { music: true, sfx: true, ghost: true, touchSens: 5 };
        let progress = { unlocked: [1], coins: 0, scores: {}, rewardsClaimed: [] };
        let musicPlayer = null, audioCtx = null, gainMaster = null, soundBuffers = {};
        let hudCache = { moves: -1, obj: "" };

        window.onload = () => {
            initDOM(); loadStorage(); initBgAnimation(); resize();
            window.addEventListener('resize', resize);
            renderMenuLevels();
        };

        function initDOM() {
            canvas = document.getElementById('tetris-canvas'); ctx = canvas.getContext('2d', {alpha:true});
            nextCanvas = document.getElementById('next-canvas'); nextCtx = nextCanvas.getContext('2d', {alpha:true});
            
            document.getElementById('drawer-toggle').onclick = toggleDrawer;
            document.getElementById('drawer-close').onclick = toggleDrawer;
            document.getElementById('drawer-overlay').onclick = toggleDrawer;
            
            document.getElementById('btn-start').onclick = () => startGame(currentLevelIdx);
            document.getElementById('btn-pause').onclick = togglePause;
            document.getElementById('btn-resume').onclick = togglePause;
            document.getElementById('btn-quit-level').onclick = showMainMenu;
            document.getElementById('btn-retry').onclick = () => startGame(currentLevelIdx);
            document.getElementById('btn-go-menu').onclick = showMainMenu;
            document.getElementById('btn-next-level').onclick = () => { if(currentLevelIdx < LEVELS.length-1) startGame(currentLevelIdx+1); else showMainMenu(); };
            document.getElementById('btn-win-menu').onclick = showMainMenu;

            document.getElementById('toggle-music').onchange = (e) => { settings.music = e.target.checked; updateMusicState(); saveSettings(); };
            document.getElementById('toggle-sfx').onchange = (e) => { settings.sfx = e.target.checked; saveSettings(); };
            document.getElementById('toggle-ghost').onchange = (e) => { settings.ghost = e.target.checked; saveSettings(); };
            document.getElementById('slider-sens').oninput = (e) => { settings.touchSens = parseInt(e.target.value); document.getElementById('sens-val').innerText = settings.touchSens; saveSettings(); };

            document.addEventListener('keydown', handleKey);
            setupTouch(canvas);
        }

        async function initMusic() {
            if (!musicPlayer) {
                musicPlayer = new Audio("../assets/music/retro-arcade-music-8f2d3a.ogg");
                musicPlayer.loop = true; musicPlayer.volume = 0.6;
            }
        }

        function generatePieceCache() {
            const size = cellSize, pad = 2;
            for(let key in COLORS) {
                if(key.length > 2) continue;
                const c = document.createElement('canvas'); c.width = size; c.height = size;
                const cx = c.getContext('2d');
                cx.fillStyle = COLORS[key]; cx.beginPath(); cx.roundRect(pad, pad, size-pad*2, size-pad*2, 6); cx.fill();
                cx.fillStyle = "rgba(255,255,255,0.2)"; cx.beginPath(); cx.roundRect(pad, pad, size-pad*2, (size-pad*2)*0.4, [6,6,0,0]); cx.fill();
                PIECE_CACHE[key] = c;
            }
        }

        function enableAudioGlobal() {
            if(!audioCtx) {
                const AC = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AC(); gainMaster = audioCtx.createGain(); gainMaster.connect(audioCtx.destination); gainMaster.gain.value = 0.3;
                // Buffers simples
                soundBuffers['drop'] = createBuffer(150, 50, 0.1, 'square');
                soundBuffers['clear'] = createBuffer(400, 1200, 0.2, 'sine');
                soundBuffers['win'] = createBuffer(500, 800, 0.5, 'triangle');
            }
            if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        }

        function createBuffer(fs, fe, dur, type) {
            if(!audioCtx) return null;
            const rate = audioCtx.sampleRate, frames = rate * dur, buf = audioCtx.createBuffer(1, frames, rate), d = buf.getChannelData(0);
            for(let i=0; i<frames; i++) {
                const t = i/rate, p = i/frames, f = fs + (fe-fs)*p;
                d[i] = (type==='sine'?Math.sin(2*Math.PI*f*t):type==='square'?(Math.sin(2*Math.PI*f*t)>0?1:-1):Math.random()*2-1) * (1-p);
            }
            return buf;
        }

        function playSound(type) {
            if(!settings.sfx || !audioCtx) return;
            const src = audioCtx.createBufferSource();
            if(type === 'win') {
                [523, 659, 784].forEach((f, i) => {
                    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                    o.connect(g); g.connect(gainMaster); o.type='triangle'; o.frequency.value=f;
                    g.gain.value=0.1; g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.5);
                    o.start(audioCtx.currentTime + i*0.1); o.stop(audioCtx.currentTime + i*0.1 + 0.5);
                });
            } else if(soundBuffers[type]) {
                src.buffer = soundBuffers[type]; src.connect(gainMaster); src.start();
            }
        }

        function loadStorage() {
            try {
                const sS = localStorage.getItem(CONFIG.SETTINGS_KEY);
                if(sS) { settings = Object.assign(settings, JSON.parse(sS)); document.getElementById('slider-sens').value=settings.touchSens; }
                const sP = localStorage.getItem(CONFIG.STORAGE_KEY);
                if(sP) progress = Object.assign(progress, JSON.parse(sP));
                const max = Math.max(...progress.unlocked);
                const nxt = LEVELS.find(l=>l.id===max);
                if(nxt) { currentLevelIdx = LEVELS.indexOf(nxt); document.getElementById('btn-start').innerText = "JUGAR "+nxt.name; }
            } catch(e){}
        }
        function saveSettings() { localStorage.setItem(CONFIG.SETTINGS_KEY, JSON.stringify(settings)); }
        function saveProgress() { localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(progress)); }

        function resize() {
            const dpr = Math.min(window.devicePixelRatio||1, 1.25);
            let cs = Math.floor((window.innerHeight*0.75)/CONFIG.GRID_H);
            if(cs*CONFIG.GRID_W > window.innerWidth*0.9) cs = Math.floor((window.innerWidth*0.9)/CONFIG.GRID_W);
            if(cs!==cellSize) { cellSize=cs; generatePieceCache(); }
            const w=CONFIG.GRID_W*cellSize, h=CONFIG.GRID_H*cellSize;
            canvas.width=w*dpr; canvas.height=h*dpr; canvas.style.width=w+"px"; canvas.style.height=h+"px";
            ctx.resetTransform(); ctx.scale(dpr,dpr);
            const bg = document.getElementById('bg-canvas'); bg.width=window.innerWidth*dpr; bg.height=window.innerHeight*dpr;
            bg.style.width=window.innerWidth+"px"; bg.style.height=window.innerHeight+"px";
            bg.getContext('2d').scale(dpr,dpr);
            if(!gameActive) draw();
        }

        function draw() {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawMatrix(grid, {x:0,y:0});
            if(gameActive && !isPaused && player.matrix) {
                if(settings.ghost) {
                    const gp = {...player.pos};
                    while(!collide(grid, {matrix:player.matrix, pos:gp})) gp.y++;
                    gp.y--; ctx.globalAlpha=0.25; drawMatrix(player.matrix, gp, true); ctx.globalAlpha=1.0;
                }
                drawMatrix(player.matrix, player.pos);
            }
            particles.forEach(p=>{
                ctx.fillStyle=p.color; ctx.globalAlpha=p.life; ctx.beginPath();
                ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2); ctx.fill();
            }); ctx.globalAlpha=1.0;
        }

        function drawMatrix(m, o, ghost=false) {
            m.forEach((r,y)=>r.forEach((v,x)=>{
                if(v!==0) {
                    const dx=(x+o.x)*cellSize, dy=(y+o.y)*cellSize;
                    if(ghost) { ctx.strokeStyle=COLORS[v]; ctx.lineWidth=2; ctx.beginPath(); ctx.roundRect(dx+2,dy+2,cellSize-4,cellSize-4,4); ctx.stroke(); }
                    else if(PIECE_CACHE[v]) ctx.drawImage(PIECE_CACHE[v], dx, dy);
                }
            }));
        }

        function startGame(idx) {
            currentLevelIdx = idx;
            const lvl = LEVELS[currentLevelIdx];
            grid = Array(CONFIG.GRID_H).fill().map(()=>Array(CONFIG.GRID_W).fill(0));
            player = { matrix:null, pos:{x:0,y:0}, score:0, lines:0, movesLeft:lvl.moves, objRemaining:lvl.obj.val };
            particles=[]; gameActive=true; isPaused=false; nextPieceType=getRandomPiece();
            dropCounter=0; document.body.classList.add('gameplay-mode');
            playerReset();
            document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active'));
            document.getElementById('screen-game').classList.add('active');
            document.getElementById('game-ui').style.display='flex';
            toggleDrawer(false);
            updateHUD();
            initMusic().then(()=>{enableAudioGlobal(); updateMusicState();});
            lastTime=performance.now(); requestAnimationFrame(update);
        }

        function update(t) {
            if(!gameActive || isPaused) return;
            const dt = t - lastTime; lastTime = t;
            dropCounter+=dt; if(dropCounter>CONFIG.DROP_INTERVAL) { playerDrop(); dropCounter=0; }
            for(let i=particles.length-1; i>=0; i--) {
                let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=dt*0.003; if(p.life<=0) particles.splice(i,1);
            }
            draw(); requestAnimationFrame(update);
        }

        function playerReset() {
            const p = nextPieceType; nextPieceType=getRandomPiece();
            // Draw Next
            nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
            const m = SHAPES[nextPieceType], bs=12, ox=(60-m[0].length*bs)/2, oy=(60-m.length*bs)/2;
            nextCtx.fillStyle=COLORS[nextPieceType];
            m.forEach((r,y)=>r.forEach((v,x)=>{ if(v) { nextCtx.beginPath(); nextCtx.roundRect(ox+x*bs, oy+y*bs, bs-1, bs-1, 2); nextCtx.fill(); }}));
            
            player.matrix = JSON.parse(JSON.stringify(SHAPES[p]));
            player.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) player.matrix[y][x]=p; }));
            player.pos.y=0; player.pos.x = (grid[0].length/2|0)-(player.matrix[0].length/2|0);
            if(collide(grid, player)) gameOver("Tablero Bloqueado");
        }

        function getRandomPiece() { return SHAPE_KEYS[Math.floor(Math.random()*SHAPE_KEYS.length)]; }
        function collide(g, p) {
            const m=p.matrix, o=p.pos;
            for(let y=0; y<m.length; ++y) for(let x=0; x<m[y].length; ++x)
                if(m[y][x]!==0 && (g[y+o.y] && g[y+o.y][x+o.x])!==0) return true;
            return false;
        }
        function merge(g, p) { p.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) g[y+p.pos.y][x+p.pos.x]=v; })); }
        
        function playerDrop() {
            player.pos.y++;
            if(collide(grid, player)) {
                player.pos.y--; merge(grid, player); playSound('drop'); 
                player.movesLeft--; updateHUD();
                if(player.movesLeft<=0) gameOver("Sin Movimientos");
                sweep(); playerReset();
            }
        }
        function playerMove(d) { player.pos.x+=d; if(collide(grid, player)) player.pos.x-=d; else playSound('move'); }
        function playerRotate() {
            const pos=player.pos.x; let off=1; rotate(player.matrix);
            while(collide(grid, player)) {
                player.pos.x+=off; off=-(off+(off>0?1:-1));
                if(off>player.matrix[0].length) { rotate(player.matrix, -1); player.pos.x=pos; return; }
            } playSound('rotate');
        }
        function rotate(m, d=1) {
            for(let y=0;y<m.length;++y)for(let x=0;x<y;++x)[m[x][y],m[y][x]]=[m[y][x],m[x][y]];
            if(d>0) m.forEach(r=>r.reverse()); else m.reverse();
        }

        function sweep() {
            let c=0;
            outer: for(let y=grid.length-1; y>0; --y) {
                for(let x=0; x<grid[y].length; ++x) if(grid[y][x]===0) continue outer;
                grid.splice(y,1); grid.unshift(Array(CONFIG.GRID_W).fill(0)); ++y; c++;
                for(let i=0;i<10;i++) particles.push({x:Math.random()*CONFIG.GRID_W*cellSize, y:y*cellSize, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, life:1, color:`hsl(${Math.random()*360},100%,70%)`, size:Math.random()*5});
            }
            if(c>0) {
                playSound('clear');
                const pts = c*1000*c; player.score+=pts; player.lines+=c;
                const lvl = LEVELS[currentLevelIdx];
                if(lvl.obj.type==='lines') player.objRemaining-=c;
                else player.objRemaining = lvl.obj.val - player.score;
                checkWin(); updateHUD();
            }
        }

        function checkWin() {
            if(player.objRemaining <= 0) {
                endGameplay();
                const lvl = LEVELS[currentLevelIdx];
                const nextId = lvl.id+1;
                let coinsWon = lvl.coins;

                // --- INTEGRACIÓN FORZADA Y DEPURACIÓN ---
                if (window.GameCenter && typeof window.GameCenter.completeLevel === 'function') {
                    // Generamos ID único por timestamp para OBLIGAR a que app.js lo acepte siempre (Modo Test)
                    // Una vez veas que funciona, puedes quitar el Date.now()
                    const uniqueID = `lvl_${lvl.id}_${Date.now()}`;
                    
                    window.GameCenter.completeLevel('tetris', uniqueID, coinsWon);
                    alert(`✅ CONEXIÓN EXITOSA\nEnviadas ${coinsWon} monedas a Love Arcade.\nID: ${uniqueID}`);
                } else {
                    alert("❌ ERROR CRÍTICO\nNo se encuentra window.GameCenter.\nVerifica que app.js se cargó correctamente.");
                }
                // ------------------------------------------

                if(!progress.unlocked.includes(nextId)) progress.unlocked.push(nextId);
                saveProgress();
                document.getElementById('win-score').innerText = player.score;
                document.getElementById('win-coins').innerText = coinsWon;
                document.getElementById('screen-win').classList.add('active');
                playSound('win');
            }
        }

        function gameOver(r) { endGameplay(); document.getElementById('go-reason').innerText=r; document.getElementById('screen-gameover').classList.add('active'); playSound('lose'); }
        function endGameplay() { gameActive=false; document.body.classList.remove('gameplay-mode'); }
        function updateHUD() {
            if(hudCache.moves!==player.movesLeft) { document.getElementById('hud-moves').innerText=player.movesLeft; hudCache.moves=player.movesLeft; }
            let v = Math.max(0, player.objRemaining); let s = (LEVELS[currentLevelIdx].obj.type==='lines'?v+" L":v);
            if(hudCache.obj!==s) { document.getElementById('hud-obj-val').innerText=s; hudCache.obj=s; }
        }
        function togglePause() { if(!gameActive) return; isPaused=!isPaused; document.getElementById('screen-pause').classList.toggle('active', isPaused); updateMusicState(); }
        function showMainMenu() { endGameplay(); if(musicPlayer){musicPlayer.pause(); musicPlayer.currentTime=0;} document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active')); document.getElementById('screen-start').classList.add('active'); document.getElementById('game-ui').style.display='none'; toggleDrawer(false); loadStorage(); renderMenuLevels(); }
        function updateMusicState() { if(musicPlayer && settings.music && gameActive && !isPaused) musicPlayer.play().catch(()=>{}); else if(musicPlayer) musicPlayer.pause(); }
        function toggleDrawer(f) { const d=document.getElementById('drawer'), o=document.getElementById('drawer-overlay'); if(f===false || d.classList.contains('open')) {d.classList.remove('open'); o.classList.remove('visible');} else {d.classList.add('open'); o.classList.add('visible');} }
        function handleKey(e) { if(!gameActive) return; if(e.keyCode==37) playerMove(-1); else if(e.keyCode==39) playerMove(1); else if(e.keyCode==40) playerDrop(); else if(e.keyCode==38) playerRotate(); else if(e.keyCode==32) hardDrop(); else if(e.key.toLowerCase()=='p') togglePause(); }
        function setupTouch(el) {
            let sx=0, sy=0, lx=0, acc=0, vert=false;
            el.addEventListener('pointerdown', e=>{if(!gameActive||isPaused)return; e.preventDefault(); sx=e.clientX; sy=e.clientY; lx=e.clientX; acc=0; vert=false;}, {passive:false});
            el.addEventListener('pointermove', e=>{
                if(!gameActive||isPaused||sx===0)return; e.preventDefault();
                const dy=e.clientY-sy; if(!vert && dy>20 && dy>Math.abs(e.clientX-sx)*1.5) vert=true;
                if(vert) return;
                const dx=e.clientX-lx; lx=e.clientX; acc+=dx; const sens=Math.max(10, 35-settings.touchSens*2.5);
                while(Math.abs(acc)>sens) { playerMove(acc>0?1:-1); acc-=(acc>0?sens:-sens); }
            });
            el.addEventListener('pointerup', e=>{
                if(!gameActive||isPaused||sx===0)return;
                const dy=e.clientY-sy, dx=e.clientX-sx;
                if(vert && dy>60) hardDrop(); else if(!vert && Math.abs(dx)<20 && Math.abs(dy)<30) playerRotate(); else if(dy>50 && !vert) {playerDrop(); dropCounter=0;}
                sx=0;
            });
        }
        function initBgAnimation() {
            const c=document.getElementById('bg-canvas'), cx=c.getContext('2d', {alpha:true}), shapes=[];
            for(let i=0;i<20;i++) shapes.push({x:Math.random()*window.innerWidth, y:Math.random()*window.innerHeight, s:0.01+Math.random()*0.04, sc:1+Math.random()});
            let lf=0;
            function l(t) {
                if(t-lf>=1000/CONFIG.BG_FPS) {
                    cx.clearRect(0,0,c.width,c.height); cx.fillStyle="rgba(255,255,255,0.05)";
                    shapes.forEach(s=>{ s.x+=s.s; if(s.x>window.innerWidth) s.x=-100; cx.fillRect(s.x, s.y, 10*s.sc, 10*s.sc); });
                    lf=t;
                } requestAnimationFrame(l);
            } requestAnimationFrame(l);
        }
    </script>
</body>
</html>
