<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Runner: Versión Final</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');

        :root {
            --c-neon: #0ff;
            --c-danger: #ff2a2a;
            --c-warn: #ffaa00;
            --c-gold: #ffd700;
            --c-dark: #050508;
            --c-ui-bg: rgba(5, 5, 8, 0.95);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--c-dark);
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
            cursor: default;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI LAYOUT --- */
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            max-width: 600px;
            text-align: center;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            transform: translate(-50%, -40%) scale(0.95) !important;
        }

        /* --- TYPOGRAPHY --- */
        h1 {
            font-size: 3.5rem;
            margin: 0;
            color: #fff;
            text-shadow: 0 0 20px var(--c-neon);
            font-weight: 900;
            letter-spacing: 4px;
            font-style: italic;
            text-transform: uppercase;
        }

        h2 {
            font-size: 3rem;
            color: var(--c-danger);
            text-shadow: 0 0 20px var(--c-danger);
            margin: 0 0 20px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        p {
            color: #aaa;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            margin: 10px 0;
        }

        .sub-label {
            font-size: 0.9rem;
            color: var(--c-neon);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
        }

        /* --- HUD --- */
        #hud-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 80px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .hud-group {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .hud-stat {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .hud-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hud-value {
            font-size: 1.5rem;
            color: #fff;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .val-dist { color: var(--c-neon); }
        .val-speed { color: var(--c-warn); }

        /* --- BUTTONS --- */
        .icon-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 44px;
            height: 44px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--c-neon);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .icon-btn svg { width: 24px; height: 24px; fill: #fff; }

        .btn-main {
            margin-top: 30px;
            background: transparent;
            color: var(--c-neon);
            border: 2px solid var(--c-neon);
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            pointer-events: auto;
        }

        .btn-main:hover {
            background: var(--c-neon);
            color: #000;
            box-shadow: 0 0 30px var(--c-neon);
        }

        .btn-danger {
            border-color: var(--c-danger);
            color: var(--c-danger);
        }

        .btn-danger:hover {
            background: var(--c-danger);
            color: #000;
            box-shadow: 0 0 30px var(--c-danger);
        }

        .btn-exit-text {
            background: transparent;
            border: none;
            color: #666;
            font-family: 'Rajdhani', sans-serif;
            font-weight: bold;
            font-size: 1rem;
            margin-top: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 10px;
            transition: color 0.2s;
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .btn-exit-text:hover { color: #fff; }

        /* --- NOTIFICATIONS --- */
        #notification-area {
            position: absolute;
            top: 90px;
            right: 0;
            width: 300px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            padding-right: 20px;
            gap: 10px;
        }

        .toast {
            background: rgba(10, 10, 15, 0.95);
            border-left: 4px solid var(--c-neon);
            padding: 15px;
            width: 260px;
            color: #fff;
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: -5px 5px 20px rgba(0,0,0,0.5);
        }
        
        .toast.show { transform: translateX(0); }
        .toast-content h4 { margin: 0; color: var(--c-neon); font-size: 0.8rem; text-transform: uppercase; }
        .toast-content span { font-size: 0.9rem; font-family: 'Rajdhani', sans-serif; font-weight: bold; }
        .toast-coins { font-size: 1.2rem; color: #ffd700; font-weight: 900; }

        /* --- PAUSE STATS --- */
        .pause-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            width: 80%;
        }
        .mini-stat { text-align: left; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .mini-stat span { display: block; font-size: 0.8rem; color: #888; }
        .mini-stat strong { font-size: 1.2rem; color: #fff; }

        /* --- GAME OVER STATS (Animados) --- */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
            width: 100%;
        }
        .stat-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 15px 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        .stat-card.visible { opacity: 1; transform: translateY(0); }
        
        .stat-card small { display: block; color: #666; font-size: 0.7rem; text-transform: uppercase; margin-bottom: 5px; }
        .stat-card strong { display: block; color: #fff; font-size: 1.4rem; }

        @media (max-width: 500px) {
            .stats-grid { grid-template-columns: 1fr; gap: 10px; }
            .screen { max-width: 90%; }
        }

    </style>
</head>
<body>

    <!-- HUD -->
    <div id="uiLayer">
        <div id="hud-top" class="hidden-menu">
            <div class="hud-group">
                <button id="btnPause" class="icon-btn">
                    <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                </button>
                <div class="hud-stat">
                    <span class="hud-label">DISTANCIA</span>
                    <span class="hud-value val-dist"><span id="hudDist">0</span>m</span>
                </div>
                <div class="hud-stat">
                    <span class="hud-label">PUNTUACIÓN</span>
                    <span class="hud-value"><span id="hudScore">0</span></span>
                </div>
            </div>
            
            <div class="hud-group">
                <div class="hud-stat" style="text-align: right;">
                    <span class="hud-label">VELOCIDAD</span>
                    <span class="hud-value val-speed"><span id="hudSpeed">1.0</span>x</span>
                </div>
                <button id="btnMute" class="icon-btn">
                    <svg id="iconVolOn" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                    <svg id="iconVolOff" viewBox="0 0 24 24" style="display:none;"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
                </button>
            </div>
        </div>

        <!-- Notification Area -->
        <div id="notification-area"></div>

        <!-- START SCREEN -->
        <div id="startScreen" class="screen">
            <h1 style="font-size: 4rem;">NEON<br>RUNNER</h1>
            <div class="sub-label">SISTEMA SOBRECARGADO v1.1</div>
            <p style="font-size: 0.9rem; margin-top: 30px;">
                TAP para Saltar // DOBLE TAP para Impulso Aéreo<br>
                Evita las defensas del sistema
            </p>
            <button id="btnStart" class="btn-main">INICIAR SISTEMA</button>
            <button class="btn-exit-text" onclick="exitToArcade()">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/></svg>
                Volver a Love Arcade
            </button>
        </div>

        <!-- PAUSE OVERLAY -->
        <div id="pauseOverlay" class="screen hidden">
            <h1>PAUSA</h1>
            <p>SISTEMA SUSPENDIDO</p>
            
            <div class="pause-stats">
                <div class="mini-stat">
                    <span>Distancia Actual</span>
                    <strong id="pauseDist">0m</strong>
                </div>
                <div class="mini-stat">
                    <span>Puntuación</span>
                    <strong id="pauseScore">0</strong>
                </div>
            </div>

            <button id="btnResume" class="btn-main">REANUDAR</button>
            <button class="btn-exit-text" onclick="exitToArcade()">
                Volver a Love Arcade
            </button>
        </div>

        <!-- GAME OVER SCREEN -->
        <div id="gameOverScreen" class="screen hidden">
            <h2>CRASH</h2>
            <div class="stats-grid">
                <div class="stat-card" style="transition-delay: 0.1s;">
                    <small>DISTANCIA FINAL</small>
                    <strong id="finalDist">0m</strong>
                </div>
                <div class="stat-card" style="transition-delay: 0.3s;">
                    <small>VELOCIDAD MÁX</small>
                    <strong style="color: var(--c-warn);">x<span id="finalSpeed">1.0</span></strong>
                </div>
                <div class="stat-card" style="transition-delay: 0.5s;">
                    <small>GANANCIAS</small>
                    <strong style="color: var(--c-gold);">+<span id="finalCoins">0</span></strong>
                </div>
            </div>
            
            <p id="newRecordTag" class="hidden" style="color: #ffd700; font-weight: bold;">⚠️ NUEVO RÉCORD DEL SISTEMA ⚠️</p>
            
            <button id="btnRetry" class="btn-main btn-danger">REINICIAR</button>
            <button class="btn-exit-text" onclick="exitToArcade()">
                Volver a Love Arcade
            </button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script src="../../js/app.js"></script>

<script>
/**
 * ------------------------------------------------------------------
 * NEON RUNNER: GOLD MASTER 1.0.1
 * Optimization: Path2D, Object Pooling, Ambient Audio
 * ------------------------------------------------------------------
 */

// --- CONFIGURACIÓN ---
const CONFIG = {
    baseSpeed: 400, 
    maxSpeed: 1200,
    gravity: 2000,
    jumpForce: 750,
    floorHeightPct: 0.15,
    colors: {
        player: '#0ff',
        obstacleGround: '#ff3333',
        obstacleAir: '#ffaa00',
        bgTop: '#000000',
        bgBottom: '#050510' // Azul muy oscuro para el gradiente
    }
};

// --- ESTADO GLOBAL ---
const state = {
    screen: 'MENU', 
    isMuted: false,
    distance: 0,
    score: 0,
    speed: CONFIG.baseSpeed,
    sessionCoins: 0, 
    lastTime: 0,
    cameraShake: 0,
    gameTime: 0, // Tiempo acumulado para animaciones
    sessionClaimedIds: new Set()
};

// --- ECONOMÍA ---
const REWARDS = [
    { type: 'dist', val: 500, coins: 5, id: 'nr_d_500' },
    { type: 'dist', val: 1000, coins: 10, id: 'nr_d_1000' },
    { type: 'dist', val: 2000, coins: 15, id: 'nr_d_2000' },
    { type: 'dist', val: 3500, coins: 25, id: 'nr_d_3500' },
    { type: 'dist', val: 5000, coins: 40, id: 'nr_d_5000' },
    { type: 'speed', val: 1.5, coins: 5, id: 'nr_s_15' }, 
    { type: 'speed', val: 2.0, coins: 10, id: 'nr_s_20' },
    { type: 'speed', val: 2.5, coins: 20, id: 'nr_s_25' }
];

// --- SISTEMA DE AUDIO AVANZADO ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const AudioSys = {
    droneOsc: null,
    droneGain: null,
    lfoOsc: null,
    isInit: false,

    initDrone: () => {
        if (AudioSys.isInit) return;
        // Drone oscilador principal
        AudioSys.droneOsc = audioCtx.createOscillator();
        AudioSys.droneOsc.type = 'sawtooth';
        AudioSys.droneOsc.frequency.value = 55; // Bajo profundo

        // LFO para modular volumen (efecto respiración)
        AudioSys.lfoOsc = audioCtx.createOscillator();
        AudioSys.lfoOsc.type = 'sine';
        AudioSys.lfoOsc.frequency.value = 0.2; // Muy lento

        AudioSys.droneGain = audioCtx.createGain();
        AudioSys.droneGain.gain.value = 0.0;

        // Conexiones
        // LFO -> Gain param (modulación sutil)
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 0.02; 
        AudioSys.lfoOsc.connect(lfoGain);
        lfoGain.connect(AudioSys.droneGain.gain);

        AudioSys.droneOsc.connect(AudioSys.droneGain);
        AudioSys.droneGain.connect(audioCtx.destination);

        AudioSys.droneOsc.start();
        AudioSys.lfoOsc.start();
        AudioSys.isInit = true;
    },

    updateDrone: (speedRatio) => {
        if (!AudioSys.isInit || state.isMuted) return;
        
        // Pitch sube con la velocidad
        const targetFreq = 55 + (speedRatio * 30);
        AudioSys.droneOsc.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);

        // Volumen base sube con velocidad
        const targetVol = 0.03 + (speedRatio * 0.05);
        AudioSys.droneGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.1);
    },

    playSFX: (type) => {
        if (state.isMuted || audioCtx.state === 'suspended') return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if (type === 'jump') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, t);
            osc.frequency.exponentialRampToValueAtTime(600, t + 0.15);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            osc.start(t);
            osc.stop(t + 0.2);
        } else if (type === 'crash') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            osc.start(t);
            osc.stop(t + 0.5);
        } else if (type === 'milestone') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, t);
            osc.frequency.setValueAtTime(880, t + 0.1);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.4);
            osc.start(t);
            osc.stop(t + 0.4);
        } else if (type === 'ui') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, t);
            gain.gain.setValueAtTime(0.05, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.start(t);
            osc.stop(t + 0.1);
        }
    },

    stopAll: () => {
        if(AudioSys.droneGain) AudioSys.droneGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2);
    }
};

// --- PRE-CALCULATED SHAPES (Path2D Optimization) ---
const SHAPES = {
    player: new Path2D(),
    spike: new Path2D(),
    drone: new Path2D()
};

// Init Shapes
(function initShapes(){
    // Hex/Rhombus Player (Centered at 0,0, size ~30)
    let s = 30;
    SHAPES.player.moveTo(s, 0);
    SHAPES.player.lineTo(0, s);
    SHAPES.player.lineTo(-s, 0);
    SHAPES.player.lineTo(0, -s);
    SHAPES.player.closePath();

    // Spike (Pointing Up, base width ~40, height ~50)
    SHAPES.spike.moveTo(-20, 0); // Bottom Left relative to pivot
    SHAPES.spike.lineTo(0, -50); // Tip
    SHAPES.spike.lineTo(20, 0);  // Bottom Right
    SHAPES.spike.closePath();

    // Drone (Diamond)
    SHAPES.drone.moveTo(0, 20); // Bottom
    SHAPES.drone.lineTo(20, 0); // Right
    SHAPES.drone.lineTo(0, -20); // Top
    SHAPES.drone.lineTo(-20, 0); // Left
    SHAPES.drone.closePath();
})();


// --- CANVAS SETUP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); 
let width, height, floorY;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    floorY = height - (height * CONFIG.floorHeightPct);
}
window.addEventListener('resize', resize);
resize();

// --- OBSTACLE POOLING ---
class ObstaclePool {
    constructor(size) {
        this.pool = [];
        this.size = size;
        for(let i=0; i<size; i++) {
            this.pool.push({
                active: false,
                x: 0, y: 0, 
                type: 'spike',
                width: 40, height: 40,
                color: '#fff',
                rotation: 0 // For drones
            });
        }
    }

    spawn(speed) {
        let obs = this.pool.find(o => !o.active);
        if(!obs) return; // Pool empty (rare)

        obs.active = true;
        obs.x = width + 50;
        obs.rotation = 0;
        
        // Logic type
        obs.type = Math.random() > 0.4 ? 'spike' : 'drone';

        if (obs.type === 'spike') {
            obs.y = floorY;
            obs.color = CONFIG.colors.obstacleGround;
            obs.width = 40; 
            obs.height = 50;
        } else {
            obs.y = floorY - 90 - (Math.random() * 80); 
            obs.width = 40;
            obs.height = 40;
            obs.color = CONFIG.colors.obstacleAir;
        }
    }

    updateAndDraw(dt, playerX) {
        for(let obs of this.pool) {
            if(!obs.active) continue;

            obs.x -= state.speed * dt;
            if (obs.x < -100) obs.active = false;

            // Visual Logic
            let xOffset = 0;
            let yOffset = 0;

            if (obs.type === 'spike') {
                // Vibrate if close to player
                if (Math.abs(obs.x - playerX) < 200) {
                    xOffset = (Math.random() - 0.5) * 4;
                }
            } else {
                // Drone rotates
                obs.rotation += 2 * dt;
            }

            // Draw
            ctx.save();
            ctx.translate(obs.x + xOffset, obs.y + yOffset);
            
            ctx.fillStyle = '#000';
            ctx.strokeStyle = obs.color;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = obs.color;

            if (obs.type === 'spike') {
                // Spike path is defined relative to bottom center
                ctx.fill(SHAPES.spike);
                ctx.stroke(SHAPES.spike);
            } else {
                ctx.rotate(obs.rotation);
                ctx.fill(SHAPES.drone);
                ctx.stroke(SHAPES.drone);
                // Inner blink
                ctx.fillStyle = `rgba(255,255,255,${Math.sin(state.gameTime * 10) * 0.5 + 0.5})`;
                ctx.fillRect(-2, -2, 4, 4);
            }
            
            ctx.restore();
        }
    }

    getBounds(obs) {
        if (obs.type === 'spike') {
             return { x: obs.x - 20, y: obs.y - 50, w: 40, h: 50 };
        } else {
             return { x: obs.x - 20, y: obs.y - 20, w: 40, h: 40 };
        }
    }
}

const obstacles = new ObstaclePool(10); // 10 active max usually enough

// --- PLAYER ---
class Player {
    constructor() {
        this.size = 30;
        this.x = width * 0.15;
        this.y = floorY - this.size;
        this.dy = 0;
        this.jumps = 2;
        this.rotation = 0;
        this.trail = [];
        this.pulse = 0;
    }

    update(dt) {
        // Physics
        this.dy += CONFIG.gravity * dt;
        this.y += this.dy * dt;

        // Ground
        if (this.y + this.size > floorY) {
            this.y = floorY - this.size;
            this.dy = 0;
            this.jumps = 2;
            this.rotation = this.rotation * 0.8; 
        } else {
            this.rotation += 5 * dt;
        }

        // Pulse Animation (Heartbeat of the core)
        // Faster speed = Faster Pulse
        let pulseSpeed = 5 + (state.speed / CONFIG.baseSpeed) * 5;
        this.pulse = Math.sin(state.gameTime * pulseSpeed) * 0.15;

        // Trail
        if (state.screen === 'PLAYING') {
            this.trail.push({ x: this.x, y: this.y, rot: this.rotation });
            if (this.trail.length > 8) this.trail.shift();
        }
    }

    draw() {
        // Trail
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        this.trail.forEach((t, i) => {
            let alpha = (i / this.trail.length) * 0.4;
            ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.translate(t.x, t.y);
            ctx.rotate(t.rot);
            let s = 1.0 - ((this.trail.length - i) * 0.05);
            ctx.scale(s, s);
            ctx.stroke(SHAPES.player);
            ctx.setTransform(1,0,0,1,0,0); // Reset transform
        });
        ctx.restore();

        // Main Body
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Pulse Scale
        let s = 1 + this.pulse;
        ctx.scale(s, s);

        ctx.shadowBlur = 15 + (this.pulse * 10); // Breathing glow
        ctx.shadowColor = CONFIG.colors.player;
        ctx.fillStyle = '#000';
        ctx.strokeStyle = CONFIG.colors.player;
        ctx.lineWidth = 3;
        
        ctx.fill(SHAPES.player);
        ctx.stroke(SHAPES.player);

        // Core Center
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(0, 0, 5, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }

    jump() {
        if (this.jumps > 0) {
            this.dy = -CONFIG.jumpForce;
            this.jumps--;
            AudioSys.playSFX('jump');
        }
    }
}

// --- BACKGROUND ---
const stars = Array(40).fill().map(() => ({
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    s: Math.random() * 2,
    vx: Math.random() * 20 + 10
}));
const farStars = Array(20).fill().map(() => ({ // Capa de profundidad
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    s: Math.random() * 1,
    vx: Math.random() * 5 + 2 // Más lentas
}));
let gridOffset = 0;

function drawBackground(dt) {
    // 1. Gradient Background
    let grad = ctx.createLinearGradient(0, 0, 0, height);
    grad.addColorStop(0, CONFIG.colors.bgTop);
    grad.addColorStop(1, CONFIG.colors.bgBottom);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    // 2. Far Stars
    ctx.fillStyle = '#aaa';
    farStars.forEach(st => {
        st.x -= (st.vx + state.speed * 0.01) * dt; 
        if(st.x < 0) st.x = width;
        ctx.globalAlpha = 0.4;
        ctx.fillRect(st.x, st.y, st.s, st.s);
    });

    // 3. Near Stars
    ctx.fillStyle = '#fff';
    stars.forEach(st => {
        st.x -= (st.vx + state.speed * 0.05) * dt;
        if (st.x < 0) st.x = width;
        ctx.globalAlpha = Math.random() * 0.5 + 0.3;
        ctx.fillRect(st.x, st.y, st.s, st.s);
    });
    ctx.globalAlpha = 1.0;

    // 4. Grid Floor
    gridOffset = (gridOffset + state.speed * dt) % 100;
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    ctx.moveTo(0, floorY);
    ctx.lineTo(width, floorY);
    for (let i = 0; i < width + 100; i += 100) {
        let x = i - gridOffset;
        ctx.moveTo(x, floorY);
        ctx.lineTo(x - 300, height);
    }
    ctx.stroke();
    // Horizontal perspective lines
    for (let i = 0; i < height - floorY; i += 40) {
        ctx.beginPath();
        ctx.moveTo(0, floorY + i);
        ctx.lineTo(width, floorY + i);
        ctx.strokeStyle = `rgba(0, 255, 255, ${0.1 + (i/200)})`;
        ctx.stroke();
    }
    ctx.restore();
}

// --- GAME LOGIC ---
let player = new Player();
let nextSpawn = 0;

function resetGame() {
    state.distance = 0;
    state.score = 0;
    state.speed = CONFIG.baseSpeed;
    state.cameraShake = 0;
    state.sessionCoins = 0;
    state.gameTime = 0;
    state.sessionClaimedIds.clear();
    
    player = new Player();
    // Reset pool
    obstacles.pool.forEach(o => o.active = false);
    nextSpawn = 0;

    // Reset UI
    document.getElementById('hudDist').innerText = '0';
    document.getElementById('hudScore').innerText = '0';
    document.getElementById('hudSpeed').innerText = '1.0';
    document.getElementById('notification-area').innerHTML = '';
    
    // Hide stats cards for animation replay
    document.querySelectorAll('.stat-card').forEach(c => c.classList.remove('visible'));
    
    AudioSys.initDrone();
}

function update(dt) {
    state.gameTime += dt;

    if (state.speed < CONFIG.maxSpeed) {
        state.speed += (10 * dt);
    }
    
    // Audio Drone Update
    AudioSys.updateDrone(state.speed / CONFIG.baseSpeed);

    state.distance += state.speed * dt;
    state.score = Math.floor(state.distance / 100);

    // Camera Shake
    if (state.speed > CONFIG.maxSpeed * 0.8) {
        state.cameraShake = (Math.random() - 0.5) * 4;
    } else {
        state.cameraShake = 0;
    }

    player.update(dt);

    // Spawning
    nextSpawn -= (state.speed * dt);
    if (nextSpawn <= 0) {
        obstacles.spawn(state.speed);
        let safetyGap = 350 + (state.speed * 0.2); 
        nextSpawn = safetyGap + Math.random() * 400;
    }

    // Collision & Logic
    checkCollisions();
    checkMilestones();

    // UI Update
    document.getElementById('hudDist').innerText = Math.floor(state.distance / 100);
    document.getElementById('hudScore').innerText = state.score;
    document.getElementById('hudSpeed').innerText = (state.speed / CONFIG.baseSpeed).toFixed(1);
}

function checkCollisions() {
    const pBounds = { 
        x: player.x - player.size/2, 
        y: player.y - player.size/2, 
        w: player.size, h: player.size 
    };

    for(let obs of obstacles.pool) {
        if(!obs.active) continue;
        const oBounds = obstacles.getBounds(obs);

        if (pBounds.x < oBounds.x + oBounds.w &&
            pBounds.x + pBounds.w > oBounds.x &&
            pBounds.y < oBounds.y + oBounds.h &&
            pBounds.y + pBounds.h > oBounds.y) {
            
            gameOver();
            return;
        }
    }
}

function checkMilestones() {
    const distM = Math.floor(state.distance / 100);
    const speedM = state.speed / CONFIG.baseSpeed;

    REWARDS.forEach(r => {
        if (state.sessionClaimedIds.has(r.id)) return;

        let triggered = false;
        let title = "";
        let msg = "";

        if (r.type === 'dist' && distM >= r.val) {
            triggered = true;
            title = "SECTOR DESPEJADO";
            msg = `Alcanzados ${r.val}m`;
        } else if (r.type === 'speed' && speedM >= r.val) {
            triggered = true;
            title = "VELOCIDAD CRÍTICA";
            msg = `Aumento x${r.val}`;
        }

        if (triggered) {
            awardCoin(r.id, r.coins, title, msg);
        }
    });
}

function awardCoin(id, coins, title, msg) {
    state.sessionClaimedIds.add(id);
    state.sessionCoins += coins; 
    
    if (window.GameCenter && window.GameCenter.completeLevel) {
        window.GameCenter.completeLevel('neonrunner', id, coins);
    }
    
    AudioSys.playSFX('milestone');
    showToast(title, msg, coins);
}

function showToast(title, msg, coins) {
    const el = document.createElement('div');
    el.className = 'toast';
    el.innerHTML = `
        <div class="toast-content">
            <h4>${title}</h4>
            <span>${msg}</span>
        </div>
        <div class="toast-coins">+${coins}</div>
    `;
    document.getElementById('notification-area').appendChild(el);
    requestAnimationFrame(() => el.classList.add('show'));
    setTimeout(() => {
        el.classList.remove('show');
        setTimeout(() => el.remove(), 400);
    }, 3000);
}

function gameOver() {
    state.screen = 'GAMEOVER';
    AudioSys.playSFX('crash');
    AudioSys.stopAll();

    const finalDist = Math.floor(state.distance / 100);
    const oldBest = parseInt(localStorage.getItem('nr_best') || 0);
    let isNewRecord = false;
    
    if (finalDist > oldBest) {
        localStorage.setItem('nr_best', finalDist);
        isNewRecord = true;
    }

    document.getElementById('finalDist').innerText = finalDist + 'm';
    document.getElementById('finalSpeed').innerText = (state.speed / CONFIG.baseSpeed).toFixed(1);
    document.getElementById('finalCoins').innerText = state.sessionCoins;
    
    const recordTag = document.getElementById('newRecordTag');
    if (isNewRecord) recordTag.classList.remove('hidden');
    else recordTag.classList.add('hidden');

    toggleScreen('gameOverScreen');

    // Trigger stats animation
    setTimeout(() => {
        document.querySelectorAll('.stat-card').forEach(c => c.classList.add('visible'));
    }, 100);
}

// --- LOOP & CONTROL ---
function loop(timestamp) {
    if (!state.lastTime) state.lastTime = timestamp;
    const dt = (timestamp - state.lastTime) / 1000;
    state.lastTime = timestamp;

    if (state.screen === 'PLAYING') {
        update(Math.min(dt, 0.1));
    }

    ctx.save();
    if (state.cameraShake !== 0) ctx.translate(state.cameraShake, state.cameraShake);

    drawBackground(dt);
    obstacles.updateAndDraw(dt, player.x);
    player.draw(); 

    ctx.restore();
    requestAnimationFrame(loop);
}

function toggleScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('hud-top').classList.remove('hidden-menu');
    
    const target = document.getElementById(screenId);
    if (target) target.classList.remove('hidden');

    if (screenId === 'startScreen') document.getElementById('hud-top').classList.add('hidden-menu');
}

document.getElementById('btnStart').addEventListener('click', () => {
    resetGame();
    state.screen = 'PLAYING';
    AudioSys.playSFX('ui');
    if(audioCtx.state === 'suspended') audioCtx.resume();
    toggleScreen(null);
});

document.getElementById('btnRetry').addEventListener('click', () => {
    resetGame();
    state.screen = 'PLAYING';
    AudioSys.playSFX('ui');
    toggleScreen(null);
});

function togglePause() {
    AudioSys.playSFX('ui');
    if (state.screen === 'PLAYING') {
        state.screen = 'PAUSED';
        AudioSys.stopAll();
        
        // Update Pause Stats
        document.getElementById('pauseDist').innerText = Math.floor(state.distance/100) + 'm';
        document.getElementById('pauseScore').innerText = state.score;

        toggleScreen('pauseOverlay');
    } else if (state.screen === 'PAUSED') {
        state.screen = 'PLAYING';
        state.lastTime = performance.now(); 
        AudioSys.updateDrone(state.speed / CONFIG.baseSpeed); // Restore audio
        toggleScreen(null);
    }
}
document.getElementById('btnPause').addEventListener('click', togglePause);
document.getElementById('btnResume').addEventListener('click', togglePause);

document.getElementById('btnMute').addEventListener('click', () => {
    state.isMuted = !state.isMuted;
    const on = document.getElementById('iconVolOn');
    const off = document.getElementById('iconVolOff');
    if (state.isMuted) {
        on.style.display = 'none';
        off.style.display = 'block';
        AudioSys.stopAll();
    } else {
        on.style.display = 'block';
        off.style.display = 'none';
        AudioSys.updateDrone(state.speed / CONFIG.baseSpeed);
    }
    AudioSys.playSFX('ui');
});

window.exitToArcade = function() {
    window.location.href = '../../index.html';
};

function handleAction(e) {
    if (state.screen === 'PLAYING') {
        if (e.type === 'keydown' && e.code === 'Space') e.preventDefault();
        player.jump();
    }
}

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') handleAction(e);
    if (e.code === 'Escape') togglePause();
});
canvas.addEventListener('mousedown', handleAction);
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleAction(e); }, {passive: false});

// Init
toggleScreen('startScreen');
requestAnimationFrame(loop);

</script>
</body>
</html>


