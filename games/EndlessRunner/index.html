<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Runner - Prototipo Beta</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Previene zoom/scroll en móviles */
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .hidden {
            display: none !important;
        }
        h1 {
            color: #fff;
            text-shadow: 0 0 10px #0ff;
            font-size: 3rem;
            margin-bottom: 10px;
        }
        p {
            color: #ccc;
            font-size: 1.2rem;
            margin: 5px;
        }
        .btn {
            background: #0ff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            margin-top: 20px;
            box-shadow: 0 0 15px #0ff;
            transition: transform 0.1s;
            text-transform: uppercase;
        }
        .btn:active {
            transform: scale(0.95);
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            pointer-events: none;
        }
        .stat-box {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 5px;
            text-shadow: 1px 1px 0 #000;
        }
        .coin-text { color: #ffd700; }
        .dist-text { color: #0ff; }
        
        #reward-popup {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px #ffd700;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
        }
    </style>
</head>
<body>

    <!-- HUD durante el juego -->
    <div id="hud" class="hidden">
        <div class="stat-box dist-text">DIST: <span id="scoreDisplay">0</span>m</div>
        <div class="stat-box">VEL: <span id="speedDisplay">1.0</span>x</div>
    </div>

    <!-- Pantalla de Inicio -->
    <div id="uiLayer">
        <div id="startScreen">
            <h1>NEON RUNNER</h1>
            <p>BETA 0.1</p>
            <p>Salta obstáculos. Sobrevive.</p>
            <p style="font-size: 0.9rem; color: #888;">[ESPACIO] o [TAP] para Saltar<br>Doble salto disponible</p>
            <button class="btn" id="startBtn">JUGAR</button>
        </div>

        <!-- Pantalla Game Over -->
        <div id="gameOverScreen" class="hidden">
            <h1 style="color: #ff3333; text-shadow: 0 0 10px #ff0000;">CRASH!</h1>
            <div class="stat-box dist-text">Distancia: <span id="finalScore">0</span>m</div>
            <div class="stat-box coin-text">+<span id="coinsEarned">0</span> Monedas</div>
            <p style="margin-top: 15px; font-size: 0.9rem;">Total Monedas: <span id="totalWallet">0</span></p>
            <p style="color: #FFFF00; font-size: 0.9rem;" id="newRecordMsg" class="hidden">¡NUEVO RÉCORD!</p>
            <button class="btn" id="retryBtn" style="background: #ff3333; box-shadow: 0 0 15px #ff0000; color: white;">REINTENTAR</button>
        </div>
    </div>

    <div id="reward-popup"></div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * AUDIO SYSTEM (Web Audio API)
 * Genera sonidos sintetizados sin archivos externos.
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const playSound = (type) => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'jump') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'crash') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'coin') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.setValueAtTime(1800, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    }
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// UI Elements
const uiStart = document.getElementById('startScreen');
const uiGameOver = document.getElementById('gameOverScreen');
const uiHud = document.getElementById('hud');
const scoreDisplay = document.getElementById('scoreDisplay');
const speedDisplay = document.getElementById('speedDisplay');
const finalScoreDisplay = document.getElementById('finalScore');
const coinsEarnedDisplay = document.getElementById('coinsEarned');
const totalWalletDisplay = document.getElementById('totalWallet');
const newRecordMsg = document.getElementById('newRecordMsg');

// Estado del Juego
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
let frameCount = 0;
let score = 0; // Distancia
let gameSpeed = 6;
let initialSpeed = 6;
let highScore = localStorage.getItem('nr_highscore') || 0;
let wallet = parseInt(localStorage.getItem('nr_wallet')) || 0;

// Configuración del Mundo
let gravity = 0.6;
let floorHeight = 100;

// Entidades
let player;
let obstacles = [];
let particles = [];
let backgroundStars = [];

// Redimensionar Canvas
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    floorHeight = canvas.height * 0.15; // Suelo es el 15% inferior
    // Regenerar estrellas si cambia el tamaño
    backgroundStars = [];
    for(let i=0; i<50; i++) {
        backgroundStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * (canvas.height - floorHeight),
            size: Math.random() * 2,
            speed: Math.random() * 0.5 + 0.1
        });
    }
}
window.addEventListener('resize', resize);
resize();

// Clase Jugador
class Player {
    constructor() {
        this.width = 40;
        this.height = 40;
        this.x = canvas.width * 0.1; // Posición horizontal fija (10%)
        this.y = canvas.height - floorHeight - this.height;
        this.dy = 0;
        this.jumpForce = 12;
        this.grounded = true;
        this.color = '#0ff';
        this.jumpsLeft = 2; // Doble salto
        this.rotation = 0;
    }

    jump() {
        if (this.jumpsLeft > 0) {
            this.dy = -this.jumpForce;
            this.grounded = false;
            this.jumpsLeft--;
            playSound('jump');
            createParticles(this.x + this.width/2, this.y + this.height, 5, '#fff');
        }
    }

    update() {
        // Gravedad
        this.dy += gravity;
        this.y += this.dy;

        // Rotación visual al saltar
        if (!this.grounded) {
            this.rotation += 0.15;
        } else {
            // Alinear rotación al aterrizar
            this.rotation = Math.round(this.rotation / (Math.PI/2)) * (Math.PI/2); 
            // Interpolar suavemente hacia 0 para "resetear" visualmente (simplificado: resetear a 0)
            this.rotation = 0;
        }

        // Colisión con el suelo
        if (this.y + this.height > canvas.height - floorHeight) {
            this.y = canvas.height - floorHeight - this.height;
            this.dy = 0;
            this.grounded = true;
            this.jumpsLeft = 2; // Resetear saltos
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        ctx.rotate(this.rotation);
        
        // Efecto de neón
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        
        // Centro blanco
        ctx.fillStyle = '#fff';
        ctx.fillRect(-this.width/4, -this.height/4, this.width/2, this.height/2);
        
        ctx.restore();
    }
}

// Clase Obstáculo
class Obstacle {
    constructor() {
        this.width = 40;
        this.height = 40 + Math.random() * 30; // Altura variable
        this.x = canvas.width;
        this.markedForDeletion = false;
        
        // Tipo aleatorio: 0 = pincho suelo, 1 = bloque flotante
        this.type = Math.random() > 0.7 ? 'flying' : 'ground';

        if (this.type === 'ground') {
            this.y = canvas.height - floorHeight - this.height;
            this.color = '#ff3333'; // Rojo
        } else {
            this.y = canvas.height - floorHeight - 130; // Altura para saltar o agacharse (aquí solo saltar)
            this.height = 40;
            this.width = 60;
            this.color = '#ffaa00'; // Naranja
        }
    }

    update() {
        this.x -= gameSpeed;
        if (this.x + this.width < 0) this.markedForDeletion = true;
    }

    draw() {
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;

        if (this.type === 'ground') {
            // Dibujar triángulo (pincho)
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + this.height);
            ctx.lineTo(this.x + this.width/2, this.y);
            ctx.lineTo(this.x + this.width, this.y + this.height);
            ctx.closePath();
            ctx.fill();
        } else {
            // Dibujar bloque
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        ctx.restore();
    }
}

// Partículas
function createParticles(x, y, amount, color) {
    for (let i = 0; i < amount; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 1.0,
            color: color
        });
    }
}

function handleParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1.0;

        if (p.life <= 0) particles.splice(i, 1);
    }
}

// Fondo y Entorno
function drawBackground() {
    // Cielo oscuro
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Estrellas (parallax simple)
    ctx.fillStyle = '#fff';
    backgroundStars.forEach(star => {
        star.x -= star.speed * (gameSpeed * 0.1);
        if (star.x < 0) star.x = canvas.width;
        ctx.globalAlpha = Math.random() * 0.5 + 0.3;
        ctx.fillRect(star.x, star.y, star.size, star.size);
    });
    ctx.globalAlpha = 1.0;

    // Suelo (Grid Cyberpunk)
    ctx.beginPath();
    ctx.moveTo(0, canvas.height - floorHeight);
    ctx.lineTo(canvas.width, canvas.height - floorHeight);
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Líneas de perspectiva en el suelo
    let offset = (frameCount * gameSpeed) % 100;
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
    for (let i = 0; i < canvas.width + 100; i += 100) {
        // Líneas verticales que se mueven
        let x = i - offset;
        ctx.beginPath();
        ctx.moveTo(x, canvas.height - floorHeight);
        ctx.lineTo(x - 200, canvas.height); // Perspectiva falsa
        ctx.stroke();
    }
}

// Bucle Principal
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'PLAYING') {
        frameCount++;
        
        // 1. Dificultad Progresiva
        // Cada 500 frames, aumenta la velocidad
        if (frameCount % 500 === 0) {
            gameSpeed += 0.5;
            // Cap speed
            if (gameSpeed > 15) gameSpeed = 15;
        }

        score = Math.floor(frameCount / 5); // 1 metro cada 5 frames

        drawBackground();
        
        // 2. Gestionar Jugador
        player.update();
        player.draw();

        // 3. Gestionar Obstáculos
        // Spawnear aleatoriamente basado en la velocidad
        // Cuanto más rápido, más espacio necesitamos entre obstaculos, pero queremos que sea difícil
        let minSpawnRate = 60;
        let randomSpawn = Math.floor(Math.random() * 50);
        
        if (frameCount % minSpawnRate === 0 && randomSpawn > 10) {
            obstacles.push(new Obstacle());
        } else if (obstacles.length === 0) {
            // Asegurar que siempre hay algo eventualmente
            if (frameCount > 100 && frameCount % 100 === 0) obstacles.push(new Obstacle());
        }

        obstacles.forEach((obs, index) => {
            obs.update();
            obs.draw();

            // Detección de Colisión (AABB simple)
            // Hacemos el hitbox del jugador un poco más pequeño para ser benévolo (hitbox perdonador)
            let hitboxMargin = 10;
            if (
                player.x + hitboxMargin < obs.x + obs.width - hitboxMargin &&
                player.x + player.width - hitboxMargin > obs.x + hitboxMargin &&
                player.y + hitboxMargin < obs.y + obs.height - hitboxMargin &&
                player.y + player.height - hitboxMargin > obs.y + hitboxMargin
            ) {
                gameOver();
            }
        });

        // Eliminar obstáculos viejos
        obstacles = obstacles.filter(obs => !obs.markedForDeletion);

        // UI In-game
        scoreDisplay.innerText = score;
        speedDisplay.innerText = (gameSpeed / initialSpeed).toFixed(1);

    } else if (gameState === 'MENU' || gameState === 'GAMEOVER') {
        drawBackground();
        if (player) player.draw();
        obstacles.forEach(obs => obs.draw());
    }

    handleParticles();
    requestAnimationFrame(animate);
}

// Lógica de Juego
function startGame() {
    player = new Player();
    obstacles = [];
    particles = [];
    gameSpeed = initialSpeed;
    score = 0;
    frameCount = 0;
    
    gameState = 'PLAYING';
    
    uiStart.classList.add('hidden');
    uiGameOver.classList.add('hidden');
    uiHud.classList.remove('hidden');
    newRecordMsg.classList.add('hidden');
    
    audioCtx.resume();
}

function gameOver() {
    gameState = 'GAMEOVER';
    playSound('crash');
    createParticles(player.x, player.y, 30, '#0ff'); // Explosión del jugador

    // Cálculo de recompensas
    const coins = Math.floor(score / 20); // 1 moneda por cada 20m
    wallet += coins;
    localStorage.setItem('nr_wallet', wallet);

    // High Score
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('nr_highscore', highScore);
        newRecordMsg.classList.remove('hidden');
        // Bonus por récord? Podría ser, pero simplificamos por ahora
    }

    // Actualizar UI
    finalScoreDisplay.innerText = score;
    coinsEarnedDisplay.innerText = coins;
    totalWalletDisplay.innerText = wallet;

    uiHud.classList.add('hidden');
    uiGameOver.classList.remove('hidden');

    // Feedback sonoro de monedas (pequeño delay)
    if (coins > 0) {
        setTimeout(() => playSound('coin'), 500);
    }
}

// Input Handling
function handleInput(e) {
    if ((e.code === 'Space' || e.type === 'touchstart' || e.type === 'mousedown')) {
        // Prevenir scroll en espacio
        if (e.code === 'Space') e.preventDefault(); 

        if (gameState === 'PLAYING') {
            player.jump();
        } else if (gameState === 'MENU') {
            startGame();
        } else if (gameState === 'GAMEOVER') {
            // Breve cooldown para evitar reinicio accidental
            // Pero queremos arcade rápido, así que permitimos reinicio instantáneo si hacen clic en el botón
            // Si presionan espacio, reiniciamos
            startGame();
        }
    }
}

window.addEventListener('keydown', handleInput);
// Usamos el canvas para touch/click para saltar, pero los botones de la UI tienen sus propios listeners
canvas.addEventListener('mousedown', (e) => {
    if(gameState === 'PLAYING') player.jump();
});
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // prevenir comportamientos por defecto
    if(gameState === 'PLAYING') player.jump();
}, {passive: false});

// Botones UI
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('retryBtn').addEventListener('click', startGame);

// Iniciar Loop
animate();

</script>
</body>
</html>

