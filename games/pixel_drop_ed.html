<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Juego de bloques estilo neo optimizado.">
    
    <title>Pixel Drop: Performance Ed.</title>
    <style>
        /* =========================================
           VARIABLES Y OPTIMIZACIONES CSS
           ========================================= */
        :root {
            --bg-1: #10141B;
            --bg-2: #161C24;
            --panel: #1F2732;
            --accent: #4ADE80;
            --accent-2: #60A5FA;
            --danger: #F87171;
            --text-1: #E2E8F0;
            --text-2: #94A3B8;
            
            --font-main: "Inter", -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
            /* Fallback para low-end: color sólido en lugar de blur */
            --glass-bg: rgba(30, 40, 50, 0.95);
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Soporte para dispositivos capaces */
        @supports (backdrop-filter: blur(8px)) {
            @media (min-width: 768px) {
                :root {
                    --glass-bg: rgba(255, 255, 255, 0.05);
                }
            }
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; 
            font-family: var(--font-main);
            background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
            color: var(--text-1);
            touch-action: none;
            /* GPU Hint */
            transform: translateZ(0); 
        }

        .skip-link {
            position: absolute; top: -40px; left: 0;
            background: var(--accent); color: #000;
            padding: 8px; z-index: 1000;
            text-decoration: none; font-weight: bold;
            transition: top 0.2s;
        }
        .skip-link:focus { top: 0; }

        #bg-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 0; opacity: 0.1; 
            pointer-events: none;
            /* Optimización: layer separado */
            will-change: transform; 
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            touch-action: none;
        }

        /* PANTALLAS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column;
            align-items: center; justify-content: center; 
            z-index: 10;
        }
        .screen.active { display: flex; }

        /* Optimización: Eliminamos animaciones costosas en overlays */
        .overlay { 
            background: rgba(16, 20, 27, 0.95); 
            border-radius: 20px;
            padding: 40px 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        
        /* Solo aplicar blur en escritorio/gama alta */
        @media (min-width: 768px) {
            .overlay { 
                background: rgba(16, 20, 27, 0.85);
                backdrop-filter: blur(12px); 
                -webkit-backdrop-filter: blur(12px);
            }
        }

        .overlay h2 { 
            font-size: 2.2rem; font-weight: 800; margin-bottom: 10px; 
            color: var(--text-1); letter-spacing: -0.5px; text-align: center;
        }
        .overlay p { font-size: 1.1rem; color: var(--text-2); margin-bottom: 30px; }

        .title {
            font-size: 4rem; font-weight: 900; margin-bottom: 3rem;
            letter-spacing: -2px; display: flex; gap: 2px; z-index: 2;
        }
        .t-let:nth-child(1) { color: #22d3ee; }
        .t-let:nth-child(2) { color: #3b82f6; }
        .t-let:nth-child(3) { color: #fb923c; }
        .t-let:nth-child(4) { color: #facc15; }
        .t-let:nth-child(5) { color: #4ade80; }
        .t-let:nth-child(6) { color: #22d3ee; }
        .t-let:nth-child(7) { color: #3b82f6; }
        .t-let:nth-child(8) { color: #a855f7; }
        .t-let:nth-child(9) { color: #f87171; }
        .gap { margin-left: 14px; }

        .btn {
            border: none; padding: 16px 32px; 
            font-size: 1.15rem; font-weight: 600; border-radius: 14px;
            cursor: pointer; margin: 12px; min-width: 200px;
            text-decoration: none; text-align: center;
            /* Sombra simplificada para rendimiento */
            box-shadow: 0 4px 0 rgba(0,0,0,0.2); 
            position: relative; overflow: hidden; letter-spacing: 0.5px;
            transform: translateZ(0);
        }
        .btn:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.2); }
        .btn-green { background: #22C55E; color: #064E3B; }
        .btn-orange { background: #3B82F6; color: #EFF6FF; }
        .btn-red { background: #EF4444; color: #FEF2F2; }
        
        .pulse { animation: softPulse 2s infinite ease-in-out; }
        @keyframes softPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.03); opacity: 0.95; }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; flex-direction: column;
            padding: 15px; z-index: 20;
        }
        .hud-top {
            display: flex; justify-content: center; width: 100%;
            max-width: 420px; margin: 0 auto; gap: 12px; pointer-events: auto;
        }
        .hud-box {
            background: var(--glass-bg);
            /* Backdrop filter eliminado en CSS base para móviles */
            border: var(--glass-border); border-radius: 14px;
            display: flex; flex-direction: column; flex: 1; 
            text-align: center; padding: 8px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .hud-label {
            font-size: 0.7rem; color: var(--text-2); 
            font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
            margin-bottom: 2px;
        }
        .hud-value { font-size: 1.3rem; font-weight: 700; color: var(--text-1); }
        
        #btn-pause {
            position: absolute; top: 20px; right: 20px; width: 44px; height: 44px;
            background: rgba(255,255,255,0.1); 
            border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; pointer-events: auto; cursor: pointer; z-index: 50;
            color: var(--text-1);
        }

        #pixel-drop-canvas {
            display: block; margin: auto;
            border-radius: 14px; 
            background: #131820; 
            border: 2px solid rgba(255, 255, 255, 0.15); 
            /* Sombra reducida para evitar overdraw */
            box-shadow: 0 10px 20px rgba(0,0,0,0.5); 
            touch-action: none;
            /* Aceleración de hardware explícita */
            will-change: contents; 
            transform: translateZ(0);
        }

        #drawer-toggle {
            position: absolute; top: 20px; left: 20px; font-size: 1.5rem;
            cursor: pointer; z-index: 100; color: var(--text-1);
            width: 44px; height: 44px; text-align: center; line-height: 44px;
            background: rgba(255,255,255,0.05); border-radius: 12px; 
            display: block; 
        }
        #drawer-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); 
            z-index: 101; display: none; opacity: 0; transition: opacity 0.2s;
        }
        #drawer-overlay.visible { display: block; opacity: 1; }
        
        #drawer {
            position: fixed; top: 0; left: -320px; width: 300px; height: 100%;
            background: var(--panel); border-right: 1px solid rgba(255,255,255,0.08);
            border-radius: 0 24px 24px 0;
            transition: transform 0.3s ease-in-out; 
            transform: translateX(0);
            z-index: 102; padding: 25px; 
            box-shadow: 5px 0 15px rgba(0,0,0,0.3); display: flex; flex-direction: column;
            overflow-y: auto; 
            touch-action: pan-y;
        }
        /* Uso de transform en lugar de left para performance */
        #drawer.closed { transform: translateX(-100%); }
        #drawer.open { transform: translateX(320px); left: -320px; } /* Fallback logic ajustada en JS */

        .drawer-top-bar {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 30px; padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .drawer-close-btn { 
            font-size: 1.2rem; cursor: pointer; color: var(--text-2); 
            padding: 8px; border-radius: 50%; background: rgba(0,0,0,0.2);
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
        }
        .drawer-section { margin-bottom: 30px; }
        .drawer-header { 
            font-size: 0.85rem; margin-bottom: 15px; color: var(--accent); 
            font-weight: 700; letter-spacing: 1.2px; text-transform: uppercase;
        }
        .setting-row { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 18px; color: var(--text-1); font-size: 0.95rem;
        }
        .setting-row label { cursor: pointer; flex: 1; }

        input[type="checkbox"] {
            appearance: none; -webkit-appearance: none; width: 42px; height: 24px;
            background: #334155; border-radius: 50px; position: relative; cursor: pointer;
            transition: background 0.3s; outline: none;
        }
        input[type="checkbox"]::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px;
            background: #fff; border-radius: 50%; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type="checkbox"]:checked { background: var(--accent); }
        input[type="checkbox"]:checked::after { transform: translateX(18px); }
        
        input[type="range"] {
            width: 100%; height: 4px; background: #334155; border-radius: 2px; appearance: none; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 18px; height: 18px; background: var(--accent);
            border-radius: 50%; cursor: pointer;
        }

        .level-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .lvl-btn {
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            color: var(--text-2); padding: 12px 0; border-radius: 10px; cursor: pointer;
            font-size: 0.9rem; text-align: center; font-weight: 600;
        }
        .lvl-btn:disabled { opacity: 0.2; cursor: not-allowed; }
        .lvl-btn.unlocked { background: rgba(96, 165, 250, 0.15); border-color: rgba(96, 165, 250, 0.3); color: var(--accent-2); }
        .lvl-btn.completed { background: var(--accent); border-color: var(--accent); color: #064E3B; }
        #next-canvas { display: block; margin: 0 auto; }

    </style>
</head>
<body>

    <a href="#game-container" class="skip-link">Saltar al juego</a>

    <canvas id="bg-canvas"></canvas>

    <div id="drawer-toggle">☰</div>
    <div id="drawer-overlay"></div>

    <aside id="drawer" class="closed">
        <div class="drawer-top-bar">
            <span style="font-weight:800; font-size:1.4rem; color:var(--text-1);">Ajustes</span>
            <div class="drawer-close-btn" id="drawer-close">✕</div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Sistema</div>
            <div class="setting-row">
                <label for="toggle-music">Música</label>
                <input type="checkbox" id="toggle-music" checked>
            </div>
            <div class="setting-row">
                <label for="toggle-sfx">Efectos de Sonido</label>
                <input type="checkbox" id="toggle-sfx" checked>
            </div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Rendimiento</div>
            <div class="setting-row">
                <label for="toggle-ghost">Pieza Fantasma</label>
                <input type="checkbox" id="toggle-ghost" checked>
            </div>
            <div class="setting-row">
                <label for="toggle-particles">Partículas</label>
                <input type="checkbox" id="toggle-particles" checked>
            </div>
            <div class="setting-row" style="flex-direction:column; align-items:flex-start;">
                <div style="display:flex; justify-content:space-between; width:100%; margin-bottom:8px;">
                    <label for="slider-sens">Sensibilidad Touch</label>
                    <span id="sens-val" style="color:var(--accent)">5</span>
                </div>
                <input type="range" id="slider-sens" min="1" max="10" value="5">
            </div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">Niveles</div>
            <div class="level-grid" id="level-grid"></div>
        </div>
        
        <div style="margin-top:auto; font-size:0.75rem; color:var(--text-2); text-align:center; padding-top:20px;">
            Pixel Drop Lite v1.1
        </div>
    </aside>

    <div id="game-container">
        <div id="screen-start" class="screen active">
            <div class="title">
                <span class="t-let">P</span><span class="t-let">I</span><span class="t-let">X</span><span class="t-let">E</span><span class="t-let">L</span><span class="t-let gap">D</span><span class="t-let">R</span><span class="t-let">O</span><span class="t-let">P</span>
            </div>
            <p style="color:var(--text-2); margin-bottom:30px; letter-spacing:2px; font-size:0.9rem;">SPEED EDITION</p>
            
            <button id="btn-start" class="btn btn-green pulse">JUGAR NIVEL 1</button>
            <a href="../index.html" class="btn btn-red">SALIR</a>
        </div>

        <div id="screen-game" class="screen">
            <div id="game-ui">
                <div class="hud-top">
                    <div class="hud-box">
                        <div class="hud-label">MOVS</div>
                        <div class="hud-value" id="hud-moves">0</div>
                    </div>
                    <div class="hud-box" style="flex:2;">
                        <div class="hud-label" id="hud-obj-label">OBJETIVO</div>
                        <div class="hud-value" id="hud-obj-val">--</div>
                    </div>
                    <div class="hud-box">
                        <div class="hud-label">SIG</div>
                        <canvas id="next-canvas" width="60" height="60"></canvas>
                    </div>
                </div>
                <div id="btn-pause">||</div>
            </div>
            <canvas id="pixel-drop-canvas"></canvas>
        </div>

        <div id="screen-pause" class="screen overlay">
            <h2>PAUSA</h2>
            <button id="btn-resume" class="btn btn-green">CONTINUAR</button>
            <button id="btn-quit-level" class="btn btn-orange">MENÚ PRINCIPAL</button>
        </div>

        <div id="screen-gameover" class="screen overlay">
            <h2 style="color:var(--danger)">GAME OVER</h2>
            <p id="go-reason">Inténtalo de nuevo</p>
            <button id="btn-retry" class="btn btn-green">REINTENTAR</button>
            <button id="btn-go-menu" class="btn btn-red">SALIR</button>
        </div>

        <div id="screen-win" class="screen overlay">
            <h2 style="color:var(--accent)">¡NIVEL COMPLETADO!</h2>
            <div style="text-align:center; margin-bottom:30px;">
                <p style="font-size:1.3rem; margin-bottom:5px; color:var(--text-1);">Puntuación: <span id="win-score" style="font-weight:800;">0</span></p>
                <div id="win-coins-container">
                    <p style="color:var(--accent-2); font-size:1rem;">Monedas: +<span id="win-coins">0</span></p>
                </div>
            </div>
            <button id="btn-next-level" class="btn btn-green">SIGUIENTE</button>
            <button id="btn-win-menu" class="btn btn-orange">MENÚ</button>
        </div>
    </div>

    <script>
    (function() {
        
        // ===========================================
        // PERFORMANCE & CONFIG
        // ===========================================
        const GAME_CONFIG = {
            GRID_W: 10, GRID_H: 20, 
            STORAGE_KEY: "pixeldrop:progress:lite", SETTINGS_KEY: "pixeldrop:settings:lite",
            DROP_INTERVAL: 1000,
            PARTICLE_LIMIT: 100, // Hard limit para object pool
            BG_THROTTLE: 2, // Background updates every N frames
            LOW_END_DPR: 1.5 // Cap pixel ratio para salvar GPU
        };

        const COLORS = {
            I: "#22d3ee", J: "#3b82f6", L: "#fb923c", O: "#facc15",
            S: "#4ade80", T: "#a855f7", Z: "#f87171",
        };

        const SHAPES = {
            I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
            J: [[1,0,0], [1,1,1], [0,0,0]],
            L: [[0,0,1], [1,1,1], [0,0,0]],
            O: [[1,1], [1,1]],
            S: [[0,1,1], [1,1,0], [0,0,0]],
            T: [[0,1,0], [1,1,1], [0,0,0]],
            Z: [[1,1,0], [0,1,1], [0,0,0]]
        };
        const SHAPE_KEYS = Object.keys(SHAPES);

        // ===========================================
        // AUDIO VARIABLES
        // ===========================================
        let menuMusic = null;
        let gameMusic = null;
        let audioCtx = null;
        let gainMaster = null;
        let soundBuffers = {};

        // ===========================================
        // ENGINE VARIABLES
        // ===========================================
        const PIECE_CACHE = {}; 
        let cellSize = 30; 
        
        // Dirty Flags para Renderizado Selectivo
        let renderDirty = true; 
        let lastTime = 0;
        
        const LEVELS = [
          { id: 1,  name: "Nivel 1",  obj:{ type:"lines", val: 4  }, moves: 50,  coins: 5  },
          { id: 2,  name: "Nivel 2",  obj:{ type:"lines", val: 6  }, moves: 55,  coins: 8  },
          { id: 3,  name: "Nivel 3",  obj:{ type:"lines", val: 8  }, moves: 60,  coins: 12 },
          { id: 4,  name: "Nivel 4",  obj:{ type:"lines", val: 12 }, moves: 65,  coins: 18 },
          { id: 5,  name: "Nivel 5",  obj:{ type:"lines", val: 16 }, moves: 70,  coins: 25 },
          { id: 6,  name: "Nivel 6",  obj:{ type:"lines", val: 22 }, moves: 75,  coins: 35 },
          { id: 7,  name: "Nivel 7",  obj:{ type:"lines", val: 28 }, moves: 80,  coins: 50 },
          { id: 8,  name: "Nivel 8",  obj:{ type:"lines", val: 36 }, moves: 85,  coins: 70 },
          { id: 9,  name: "Nivel 9",  obj:{ type:"lines", val: 45 }, moves: 90,  coins: 90 },
          { id:10, name: "MAESTRO",  obj:{ type:"lines", val: 60 }, moves: 95,  coins: 120 }
        ];

        let canvas, ctx, nextCanvas, nextCtx, bgCanvas, bgCtx;
        let dropCounter = 0;
        let currentLevelIdx = 0;
        let isPaused = false;
        let gameActive = false;
        
        let grid = [];
        let player = { matrix: null, pos: {x:0, y:0}, type: null, score: 0, lines: 0, movesLeft: 0, objRemaining: 0 };
        let nextPieceType = null;
        
        // OBJECT POOLING FOR PARTICLES
        const particlePool = new Array(GAME_CONFIG.PARTICLE_LIMIT).fill(null).map(() => ({
            active: false, x:0, y:0, vx:0, vy:0, life:0, color: '#fff', size:0
        }));
        let activeParticleCount = 0;

        let settings = { music: true, sfx: true, ghost: true, touchSens: 5, particles: true };
        let progress = { unlocked: [1], coins: 0, scores: {}, rewardsClaimed: [] };
        
        let hudCache = { moves: -1, obj: "" };

        window.addEventListener('load', () => {
            initDOM();
            loadStorage();
            initBgAnimation();
            resize();
            window.addEventListener('resize', () => {
                // Debounce resize
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(resize, 200);
            });
            renderMenuLevels();
        });

        function initDOM() {
            canvas = document.getElementById('pixel-drop-canvas');
            // Disable alpha for main canvas to help compositor
            ctx = canvas.getContext('2d', { alpha: false });
            
            nextCanvas = document.getElementById('next-canvas');
            nextCtx = nextCanvas.getContext('2d', { alpha: true });
            
            document.getElementById('drawer-toggle').onclick = toggleDrawer;
            document.getElementById('drawer-close').onclick = toggleDrawer;
            document.getElementById('drawer-overlay').onclick = toggleDrawer;

            document.getElementById('btn-start').onclick = () => {
                initAudioAssets(); // Lazy load audio on first user interaction
                playMusic('menu');
                startGame(currentLevelIdx);
            };
            
            document.getElementById('btn-pause').onclick = togglePause;
            document.getElementById('btn-resume').onclick = togglePause;
            document.getElementById('btn-quit-level').onclick = showMainMenu;
            
            document.getElementById('btn-retry').onclick = () => startGame(currentLevelIdx);
            document.getElementById('btn-go-menu').onclick = showMainMenu;
            
            document.getElementById('btn-next-level').onclick = () => {
                if(currentLevelIdx < LEVELS.length -1) startGame(currentLevelIdx + 1);
                else showMainMenu();
            };
            document.getElementById('btn-win-menu').onclick = showMainMenu;

            // Settings Listeners
            document.getElementById('toggle-music').onchange = (e) => { 
                settings.music = e.target.checked; 
                saveSettings();
                if(settings.music) {
                    if(gameActive && !isPaused) playMusic('game');
                    else playMusic('menu');
                } else stopAllMusic();
            };
            document.getElementById('toggle-sfx').onchange = (e) => { settings.sfx = e.target.checked; saveSettings(); };
            document.getElementById('toggle-ghost').onchange = (e) => { settings.ghost = e.target.checked; renderDirty = true; saveSettings(); };
            document.getElementById('toggle-particles').onchange = (e) => { settings.particles = e.target.checked; saveSettings(); };
            
            const slider = document.getElementById('slider-sens');
            slider.oninput = (e) => {
                settings.touchSens = parseInt(e.target.value);
                document.getElementById('sens-val').innerText = settings.touchSens;
                saveSettings();
            };
            
            document.addEventListener('keydown', handleKey);
            setupTouch(canvas);
        }

        // ===========================================
        // SYSTEM: AUDIO
        // ===========================================
        function initAudioAssets() {
            if(menuMusic) return; // Ya inicializado
            menuMusic = new Audio("../assets/music/pixel_drop_menu.ogg");
            menuMusic.loop = true; menuMusic.volume = 0.6;
            gameMusic = new Audio("../assets/music/pixel_drop_game.ogg");
            gameMusic.loop = true; gameMusic.volume = 0.8;
            initAudioSystem();
        }

        function playMusic(type) {
            if(!settings.music || !menuMusic) return;
            if(type === 'menu') {
                gameMusic.pause(); gameMusic.currentTime = 0;
                menuMusic.play().catch(()=>{});
            } else {
                menuMusic.pause(); menuMusic.currentTime = 0;
                gameMusic.play().catch(()=>{});
            }
        }

        function stopAllMusic() {
            if(menuMusic) menuMusic.pause();
            if(gameMusic) gameMusic.pause();
        }

        function initAudioSystem() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if(!AudioContext) return;
            audioCtx = new AudioContext();
            gainMaster = audioCtx.createGain();
            gainMaster.connect(audioCtx.destination);
            gainMaster.gain.value = 0.5;
            // Generate buffers
            soundBuffers['move'] = createBuffer(300, 100, 0.05, 'triangle');
            soundBuffers['rotate'] = createBuffer(400, 600, 0.08, 'sine');
            soundBuffers['drop'] = createBuffer(150, 50, 0.1, 'square');
            soundBuffers['clear'] = createBuffer(400, 1200, 0.2, 'sine');
            soundBuffers['lose'] = createBuffer(200, 50, 0.5, 'sawtooth');
        }

        function createBuffer(freqStart, freqEnd, duration, type) {
            if(!audioCtx) return null;
            const sr = audioCtx.sampleRate;
            const frames = sr * duration;
            const buffer = audioCtx.createBuffer(1, frames, sr);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < frames; i++) {
                const p = i / frames;
                const freq = freqStart + (freqEnd - freqStart) * p;
                const t = i / sr;
                let val = 0;
                // Simple waveform math
                if(type === 'sine') val = Math.sin(6.28 * freq * t);
                else if(type === 'square') val = Math.sin(6.28 * freq * t) > 0 ? 0.5 : -0.5;
                else if(type === 'triangle') val = Math.asin(Math.sin(6.28 * freq * t)) * 0.6;
                else val = (2 * (t * freq - Math.floor(t * freq + 0.5))) * 0.5;
                data[i] = val * (1 - p); 
            }
            return buffer;
        }

        function playSound(type) {
            if(!settings.sfx || !audioCtx) return;
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            if(soundBuffers[type]) {
                const src = audioCtx.createBufferSource();
                src.buffer = soundBuffers[type];
                src.connect(gainMaster);
                src.start();
            } else if (type === 'win') {
                const now = audioCtx.currentTime;
                [523, 659, 784, 1046].forEach((f, i) => {
                    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                    o.connect(g); g.connect(gainMaster); o.type = 'triangle'; o.frequency.value = f;
                    g.gain.setValueAtTime(0.1, now + i*0.1); g.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.2);
                    o.start(now + i*0.1); o.stop(now + i*0.1 + 0.25);
                });
            }
        }

        // ===========================================
        // ENGINE: CACHE & STORAGE
        // ===========================================
        function generatePieceCache() {
            const size = cellSize;
            const pad = 2;
            for (let key in COLORS) {
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const cx = c.getContext('2d');
                cx.fillStyle = COLORS[key];
                cx.fillRect(pad, pad, size - pad*2, size - pad*2); // fillRect es más rápido que roundRect
                
                // Highlight simple
                cx.fillStyle = "rgba(255,255,255,0.3)";
                cx.fillRect(pad, pad, size - pad*2, 4);
                
                PIECE_CACHE[key] = c;
            }
        }

        function loadStorage() {
            try {
                const savedSet = localStorage.getItem(GAME_CONFIG.SETTINGS_KEY);
                if(savedSet) {
                    settings = Object.assign(settings, JSON.parse(savedSet));
                    document.getElementById('toggle-music').checked = settings.music;
                    document.getElementById('toggle-sfx').checked = settings.sfx;
                    document.getElementById('toggle-ghost').checked = settings.ghost;
                    document.getElementById('toggle-particles').checked = settings.particles;
                    document.getElementById('slider-sens').value = settings.touchSens;
                    document.getElementById('sens-val').innerText = settings.touchSens;
                }
                const savedProg = localStorage.getItem(GAME_CONFIG.STORAGE_KEY);
                if(savedProg) progress = Object.assign(progress, JSON.parse(savedProg));

                const maxUnlocked = Math.max(...progress.unlocked);
                const nextLvl = LEVELS.find(l => l.id === maxUnlocked);
                if(nextLvl) {
                    currentLevelIdx = LEVELS.indexOf(nextLvl);
                    document.getElementById('btn-start').innerText = "JUGAR " + nextLvl.name;
                }
            } catch(e) { console.warn("Storage access failed"); }
        }

        function saveSettings() { try{ localStorage.setItem(GAME_CONFIG.SETTINGS_KEY, JSON.stringify(settings)); }catch(e){} }
        function saveProgress() { try{ localStorage.setItem(GAME_CONFIG.STORAGE_KEY, JSON.stringify(progress)); }catch(e){} }

        function resize() {
            // OPTIMIZATION: Cap Pixel Ratio
            const dpr = Math.min(window.devicePixelRatio || 1, GAME_CONFIG.LOW_END_DPR);
            
            const containerH = window.innerHeight;
            const containerW = window.innerWidth;
            let cs = Math.floor((containerH * 0.75) / GAME_CONFIG.GRID_H);
            if(cs * GAME_CONFIG.GRID_W > containerW * 0.95) cs = Math.floor((containerW * 0.95) / GAME_CONFIG.GRID_W);
            
            if(cs !== cellSize) {
                cellSize = cs;
                generatePieceCache(); 
            }

            const w = GAME_CONFIG.GRID_W * cellSize;
            const h = GAME_CONFIG.GRID_H * cellSize;
            
            // Set canvas logic size
            canvas.style.width = w + "px"; canvas.style.height = h + "px";
            // Set canvas buffer size (capped DPR)
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.resetTransform(); ctx.scale(dpr, dpr);

            const bgC = document.getElementById('bg-canvas');
            bgC.width = containerW; bgC.height = containerH; // Background 1:1, no DPR scaling needed for blurry bg
            
            renderDirty = true;
            if(!gameActive) draw(); 
        }

        // ===========================================
        // ENGINE: RENDER LOOP (OPTIMIZED)
        // ===========================================
        function draw() {
            // Solo dibujar si es necesario
            if(!renderDirty && activeParticleCount === 0) return;

            // Fill with solid color is faster than clearRect on some mobile GPUs if strictly opaque
            ctx.fillStyle = '#131820'; 
            ctx.fillRect(0, 0, GAME_CONFIG.GRID_W * cellSize, GAME_CONFIG.GRID_H * cellSize);

            drawMatrix(grid, {x:0, y:0});
            
            if(gameActive && !isPaused && player.matrix) {
                if(settings.ghost) {
                    const ghostPos = { ...player.pos };
                    while(!collide(grid, {matrix:player.matrix, pos:ghostPos})) ghostPos.y+=2; // Skip steps opt
                    ghostPos.y-=2;
                    while(!collide(grid, {matrix:player.matrix, pos:ghostPos})) ghostPos.y++;
                    ghostPos.y--;
                    
                    ctx.globalAlpha = 0.2; 
                    drawMatrix(player.matrix, ghostPos, true);
                    ctx.globalAlpha = 1.0;
                }
                drawMatrix(player.matrix, player.pos);
            }
            
            if(activeParticleCount > 0) drawParticles();
            
            renderDirty = false;
        }

        function drawMatrix(matrix, offset, isGhost = false) {
            // Optimized loops
            const lenY = matrix.length;
            for (let y = 0; y < lenY; ++y) {
                const row = matrix[y];
                const lenX = row.length;
                for (let x = 0; x < lenX; ++x) {
                    const value = row[x];
                    if (value !== 0) {
                        const drawX = (x + offset.x) * cellSize;
                        const drawY = (y + offset.y) * cellSize;
                        
                        if(isGhost) {
                            ctx.fillStyle = COLORS[value];
                            // Simple rect for ghost is faster than stroke
                            ctx.fillRect(drawX + 2, drawY + 2, cellSize - 4, cellSize - 4);
                        } else {
                            if(PIECE_CACHE[value]) {
                                // Draw cached bitmap
                                ctx.drawImage(PIECE_CACHE[value], drawX, drawY);
                            }
                        }
                    }
                }
            }
        }
        
        function drawParticles() {
            if(!settings.particles) return;
            for(let i=0; i<GAME_CONFIG.PARTICLE_LIMIT; i++) {
                const p = particlePool[i];
                if(p.active) {
                    ctx.fillStyle = p.color; 
                    // ctx.globalAlpha is expensive, used sparingly or removed for pure perf
                    // ctx.globalAlpha = p.life; 
                    // Square particles are much faster than arc
                    const size = Math.max(1, p.size * p.life);
                    ctx.fillRect(p.x, p.y, size, size);
                }
            }
            // ctx.globalAlpha = 1.0;
        }

        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            if(!nextPieceType) return;
            const matrix = SHAPES[nextPieceType];
            const boxSize = 12;
            const w = matrix[0].length * boxSize;
            const h = matrix.length * boxSize;
            const offX = (nextCanvas.width - w) / 2;
            const offY = (nextCanvas.height - h) / 2;
            nextCtx.fillStyle = COLORS[nextPieceType];
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if(val) nextCtx.fillRect(offX + x*boxSize, offY + y*boxSize, boxSize-1, boxSize-1);
                });
            });
        }

        // ===========================================
        // ENGINE: LOGIC LOOP
        // ===========================================
        function startGame(levelIndex) {
            currentLevelIdx = levelIndex;
            const lvlData = LEVELS[currentLevelIdx];
            grid = createGrid(GAME_CONFIG.GRID_W, GAME_CONFIG.GRID_H);
            player = {
                matrix: null, pos: {x:0, y:0}, type: null,
                score: 0, lines: 0,
                movesLeft: lvlData.moves,
                objRemaining: lvlData.obj.val
            };
            
            // Reset particles
            particlePool.forEach(p => p.active = false);
            activeParticleCount = 0;

            isPaused = false; gameActive = true;
            nextPieceType = getRandomPiece();
            
            dropCounter = 0;
            playerReset();
            
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-game').classList.add('active');
            document.getElementById('game-ui').style.display = 'flex';
            document.getElementById('drawer-toggle').style.display = 'none';
            toggleDrawer(false);
            
            hudCache = { moves: -1, obj: "" }; 
            updateHUD();
            
            lastTime = performance.now();
            renderDirty = true;
            requestAnimationFrame(update);
        }

        function createGrid(w, h) {
            const m = [];
            while (h--) m.push(new Array(w).fill(0));
            return m;
        }

        function update(time) {
            if(!gameActive || isPaused) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > GAME_CONFIG.DROP_INTERVAL) {
                playerDrop();
                dropCounter = 0;
            }
            
            if(activeParticleCount > 0) {
                updateParticles(deltaTime);
                renderDirty = true;
            }

            draw();
            requestAnimationFrame(update);
        }

        function updateParticles(dt) {
            let stillActive = 0;
            const drag = 0.95; // Air resistance approx
            for(let i=0; i<GAME_CONFIG.PARTICLE_LIMIT; i++) {
                const p = particlePool[i];
                if(p.active) {
                    p.x += p.vx; 
                    p.y += p.vy;
                    p.vx *= drag; // Simple physics
                    p.vy += 0.5;  // Gravity
                    p.life -= 0.02; // Fixed decay
                    
                    if(p.life <= 0 || p.y > canvas.height/window.devicePixelRatio) {
                        p.active = false;
                    } else {
                        stillActive++;
                    }
                }
            }
            activeParticleCount = stillActive;
        }

        function spawnExplosion(cx, cy, colorBase) {
            if(!settings.particles) return;
            // Spawn 10 particles max per explosion for performance
            let spawned = 0;
            for(let i=0; i<GAME_CONFIG.PARTICLE_LIMIT; i++) {
                if(!particlePool[i].active) {
                    const p = particlePool[i];
                    p.active = true;
                    p.x = cx; p.y = cy;
                    const angle = Math.random() * 6.28;
                    const speed = Math.random() * 6;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 1.0;
                    p.size = Math.random() * 4 + 2;
                    p.color = `hsl(${Math.random()*360}, 80%, 60%)`;
                    spawned++;
                    activeParticleCount++;
                    if(spawned >= 10) break;
                }
            }
        }

        function playerReset() {
            const piece = nextPieceType;
            nextPieceType = getRandomPiece();
            drawNextPiece();
            player.matrix = JSON.parse(JSON.stringify(SHAPES[piece]));
            player.type = piece;
            player.matrix.forEach((row, y) => row.forEach((val, x) => {
                if(val!==0) player.matrix[y][x] = piece; 
            }));
            player.pos.y = 0;
            player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(grid, player)) gameOver("Tablero bloqueado");
            renderDirty = true;
        }

        function getRandomPiece() { return SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)]; }

        function playerDrop() {
            player.pos.y++;
            renderDirty = true;
            if (collide(grid, player)) {
                player.pos.y--;
                merge(grid, player);
                playSound('drop');
                decrementMoves();
                sweep();
                playerReset();
            }
        }
        
        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(grid, player)) {
                player.pos.x -= dir;
            } else {
                playSound('move');
                renderDirty = true;
            }
        }

        function playerRotate() {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix);
            while (collide(grid, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -1);
                    player.pos.x = pos;
                    return;
                }
            }
            playSound('rotate');
            renderDirty = true;
        }

        function rotate(matrix, dir = 1) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function collide(arena, p) {
            const m = p.matrix; const o = p.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(arena, p) {
            p.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + p.pos.y][x + p.pos.x] = value;
                });
            });
            renderDirty = true;
        }

        function sweep() {
            let rowCount = 0;
            outer: for (let y = grid.length -1; y > 0; --y) {
                for (let x = 0; x < grid[y].length; ++x) {
                    if (grid[y][x] === 0) continue outer;
                }
                const row = grid.splice(y, 1)[0].fill(0);
                grid.unshift(row);
                ++y;
                rowCount++;
                
                // Visual FX
                const py = y * cellSize;
                const px = (GAME_CONFIG.GRID_W * cellSize) / 2;
                spawnExplosion(px, py);
            }
            if(rowCount > 0) {
                playSound('clear');
                const points = rowCount * 1000 * rowCount;
                player.score += points;
                player.lines += rowCount;
                const lvl = LEVELS[currentLevelIdx];
                if(lvl.obj.type === 'lines') player.objRemaining -= rowCount;
                checkWin();
                updateHUD();
                renderDirty = true;
            }
        }
        
        function decrementMoves() {
            player.movesLeft--;
            updateHUD();
            if(player.movesLeft <= 0) gameOver("Sin movimientos");
        }

        function updateHUD() {
            const lvl = LEVELS[currentLevelIdx];
            if (hudCache.moves !== player.movesLeft) {
                document.getElementById('hud-moves').innerText = player.movesLeft;
                hudCache.moves = player.movesLeft;
            }
            let val = Math.max(0, player.objRemaining);
            let strVal = (lvl.obj.type==='lines' ? val + " L" : val);
            if (hudCache.obj !== strVal) {
                document.getElementById('hud-obj-val').innerText = strVal;
                hudCache.obj = strVal;
            }
        }

        function checkWin() {
            if(player.objRemaining <= 0) {
                endGameplay();
                const lvl = LEVELS[currentLevelIdx];
                const nextId = lvl.id + 1;
                let coinsWon = 0;

                if(!progress.rewardsClaimed.includes(lvl.id)) {
                    progress.rewardsClaimed.push(lvl.id);
                    coinsWon = lvl.coins;
                    progress.coins += coinsWon;
                }

                if(!progress.unlocked.includes(nextId)) progress.unlocked.push(nextId);
                if(!progress.scores[lvl.id] || player.score > progress.scores[lvl.id]) progress.scores[lvl.id] = player.score;
                saveProgress();

                document.getElementById('win-score').innerText = player.score;
                const coinContainer = document.getElementById('win-coins-container');
                if(coinsWon > 0) {
                    document.getElementById('win-coins').innerText = coinsWon;
                    coinContainer.style.display = 'block';
                } else {
                    coinContainer.style.display = 'none';
                }

                document.getElementById('screen-win').classList.add('active');
                playSound('win');
            }
        }

        function gameOver(reason) {
            endGameplay();
            document.getElementById('go-reason').innerText = reason;
            document.getElementById('screen-gameover').classList.add('active');
            playSound('lose');
        }

        function endGameplay() {
            gameActive = false;
            if(settings.music) playMusic('menu');
        }

        function handleKey(event) {
            if(!gameActive || isPaused) {
                if(event.key.toLowerCase() === 'p') togglePause();
                return;
            }
            if (event.keyCode === 37) playerMove(-1);
            else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop();
            else if (event.keyCode === 38) playerRotate();
            else if (event.keyCode === 32) hardDrop();
            else if (event.key.toLowerCase() === 'p') togglePause();
        }
        
        function hardDrop() {
            while (!collide(grid, player)) player.pos.y++;
            player.pos.y--;
            merge(grid, player);
            playSound('drop');
            decrementMoves(); 
            // Center explosion for hard drop
            spawnExplosion((player.pos.x + 1) * cellSize, player.pos.y * cellSize);
            sweep();
            playerReset();
            dropCounter = 0;
            renderDirty = true;
        }

        function setupTouch(element) {
            let startX = 0, startY = 0;
            let lastX = 0;
            let touchAccumulatorX = 0;
            let isVerticalGesture = false;

            element.addEventListener('pointerdown', e => {
                if(!gameActive || isPaused) return;
                e.preventDefault();
                startX = e.clientX;
                startY = e.clientY;
                lastX = e.clientX;
                touchAccumulatorX = 0;
                isVerticalGesture = false; 
            }, {passive:false});

            element.addEventListener('pointermove', e => {
                if(!gameActive || isPaused || startX === 0) return;
                e.preventDefault();
                const totalDx = e.clientX - startX;
                const totalDy = e.clientY - startY;
                if (!isVerticalGesture) {
                    // Mas tolerancia vertical
                    if (totalDy > 30 && totalDy > Math.abs(totalDx) * 1.5) {
                        isVerticalGesture = true;
                    }
                }
                if (isVerticalGesture) return; 
                
                const dx = e.clientX - lastX;
                lastX = e.clientX; 
                const sens = Math.max(10, 35 - (settings.touchSens * 2.5));
                touchAccumulatorX += dx;
                
                // Throttled moves
                while(Math.abs(touchAccumulatorX) > sens) {
                    if(touchAccumulatorX > 0) {
                        playerMove(1);
                        touchAccumulatorX -= sens;
                    } else {
                        playerMove(-1);
                        touchAccumulatorX += sens;
                    }
                }
            });

            element.addEventListener('pointerup', e => {
                if(!gameActive || isPaused || startX === 0) return;
                const totalDx = e.clientX - startX;
                const totalDy = e.clientY - startY;
                if (isVerticalGesture && totalDy > 60) hardDrop();
                else if (!isVerticalGesture && Math.abs(totalDx) < 20 && Math.abs(totalDy) < 30) playerRotate();
                else if (totalDy > 50 && !isVerticalGesture) { playerDrop(); dropCounter = 0; }
                startX = 0; startY = 0; isVerticalGesture = false;
            });
            
            element.addEventListener('pointerleave', () => { startX = 0; isVerticalGesture = false; });
        }
        
        function showMainMenu() {
            endGameplay();
            stopAllMusic();
            if(settings.music) playMusic('menu');
            
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-start').classList.add('active');
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('drawer-toggle').style.display = 'block';
            loadStorage();
            renderMenuLevels();
        }

        function toggleDrawer(forceOpen = null) {
            const d = document.getElementById('drawer');
            const o = document.getElementById('drawer-overlay');
            // Check logic using class
            const isClosed = d.classList.contains('closed');
            
            if (forceOpen === false || !isClosed) {
                d.classList.add('closed'); 
                d.classList.remove('open');
                o.classList.remove('visible');
            } else {
                d.classList.remove('closed');
                d.classList.add('open'); 
                o.classList.add('visible');
            }
        }
        
        function togglePause() {
            if(!gameActive) return;
            isPaused = !isPaused;
            const pScreen = document.getElementById('screen-pause');
            if(isPaused) {
                pScreen.classList.add('active');
                if(settings.music) gameMusic.pause();
            } else {
                pScreen.classList.remove('active');
                if(settings.music) gameMusic.play().catch(()=>{});
                lastTime = performance.now(); 
                requestAnimationFrame(update);
            }
        }

        function renderMenuLevels() {
            const container = document.getElementById('level-grid');
            container.innerHTML = '';
            LEVELS.forEach((lvl, idx) => {
                const btn = document.createElement('div');
                const isUnlocked = progress.unlocked.includes(lvl.id);
                const isCompleted = progress.scores[lvl.id] !== undefined;
                let cls = 'lvl-btn';
                if(isUnlocked) cls += ' unlocked';
                if(isCompleted) cls += ' completed'; 
                btn.className = cls; btn.innerText = lvl.id;
                if(isUnlocked) {
                    btn.onclick = () => { startGame(idx); toggleDrawer(false); };
                } else btn.setAttribute('disabled', true);
                container.appendChild(btn);
            });
        }
        
        function initBgAnimation() {
            bgCanvas = document.getElementById('bg-canvas');
            bgCtx = bgCanvas.getContext('2d', { alpha: false }); // No alpha for better perf
            
            const shapes = [];
            const possibleShapes = Object.values(SHAPES);
            
            // Reduced shape count for low-end
            for(let i=0; i<12; i++) { 
                shapes.push({
                    x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight,
                    speed: (0.2 + Math.random() * 0.5), scale: 0.5 + Math.random() * 0.5,
                    matrix: possibleShapes[Math.floor(Math.random()*possibleShapes.length)]
                });
            }
            
            let frameCount = 0;

            function loop() {
                frameCount++;
                // Throttle background framerate
                if (frameCount % GAME_CONFIG.BG_THROTTLE === 0) {
                    bgCtx.fillStyle = '#10141B'; // Clear with solid color (faster)
                    bgCtx.fillRect(0,0,bgCanvas.width, bgCanvas.height);
                    
                    bgCtx.fillStyle = "#1F2732"; // Dim shapes
                    
                    shapes.forEach(s => {
                        s.x += s.speed;
                        if(s.x > bgCanvas.width) s.x = -50; 
                        
                        // Manual matrix draw for speed
                        const m = s.matrix;
                        const sz = 10 * s.scale;
                        for(let y=0; y<m.length; y++) {
                            for(let x=0; x<m[y].length; x++) {
                                if(m[y][x]) bgCtx.fillRect(s.x + x*sz, s.y + y*sz, sz, sz);
                            }
                        }
                    });
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }
    })();
    </script>
</body>
</html>
