<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Arcade - Fixed Version</title>
    <style>
        /* =========================================
           ESTILOS CSS & PALETA DE COLORES
           ========================================= */
        :root {
            --blue-900: #071024;
            --blue-800: #0B2A47;
            --blue-700: #12385A;
            --blue-600: #1B5A7A;
            --accent-green: #34D399;
            --accent-red: #F87171;
            --white: #F8FAFC;
            --panel-dark: #081829;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; font-family: var(--font-main);
            background-color: var(--blue-900); color: var(--white);
            touch-action: none; /* Vital para controles táctiles */
        }

        /* Asegurar que el contenedor del juego no capture gestos del navegador */
        #game-container {
            position: relative; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            touch-action: none; 
        }

        .bg-pattern {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--blue-900);
            background-image: radial-gradient(rgba(11, 42, 71, 0.4) 1px, transparent 1px);
            background-size: 20px 20px; z-index: -1;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column;
            align-items: center; justify-content: center; z-index: 10;
        }
        .screen.active { display: flex; }

        .title {
            font-size: 3.5rem; font-weight: 900; margin-bottom: 2rem;
            text-transform: uppercase; letter-spacing: 4px;
            text-shadow: 0 0 15px rgba(255,255,255,0.4); display: flex; gap: 5px; z-index: 2;
        }
        .t-let:nth-child(1) { color: #00f0f0; } .t-let:nth-child(2) { color: #0000f0; }
        .t-let:nth-child(3) { color: #f0a000; } .t-let:nth-child(4) { color: #f0f000; }
        .t-let:nth-child(5) { color: #00f000; } .t-let:nth-child(6) { color: #a000f0; }

        #bg-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; opacity: 0.15; }

        .btn {
            background: linear-gradient(135deg, var(--blue-700), var(--blue-600));
            border: 2px solid rgba(255,255,255,0.2); color: var(--white);
            padding: 15px 30px; font-size: 1.2rem; border-radius: 8px;
            cursor: pointer; margin: 10px; font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, filter 0.2s;
            text-decoration: none; text-align: center; min-width: 180px;
            position: relative; overflow: hidden;
        }
        .btn:active { transform: scale(0.95); }
        .btn-green { background: linear-gradient(135deg, #10B981, var(--accent-green)); border-color: var(--white); }
        .pulse { animation: pulse-animation 2s infinite; }
        @keyframes pulse-animation {
            0% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(52, 211, 153, 0); }
            100% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0); }
        }
        .btn-red { background: linear-gradient(135deg, #EF4444, var(--accent-red)); font-size: 1rem; padding: 10px 20px; }
        .btn-orange { background: linear-gradient(135deg, #d97706, #f59e0b); }

        #game-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; flex-direction: column;
            padding: 10px; z-index: 20;
        }
        .hud-top {
            display: flex; justify-content: center; width: 100%;
            max-width: 500px; margin: 0 auto; gap: 10px; pointer-events: auto;
        }
        .hud-box {
            background-color: var(--panel-dark); border: 1px solid var(--blue-600);
            border-radius: 6px; overflow: hidden; display: flex;
            flex-direction: column; flex: 1; text-align: center; box-shadow: var(--shadow);
        }
        .hud-label {
            background-color: var(--blue-800); font-size: 0.65rem; padding: 4px;
            color: #aaa; text-transform: uppercase;
        }
        .hud-value { font-size: 1.1rem; font-weight: bold; padding: 6px; color: var(--white); }
        
        #btn-pause {
            position: absolute; top: 15px; right: 15px; width: 44px; height: 44px;
            background: var(--blue-700); border: 2px solid var(--white);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; pointer-events: auto; cursor: pointer; z-index: 50;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        #tetris-canvas {
            display: block; margin: auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
            touch-action: none; image-rendering: pixelated; 
        }

        .overlay { background: rgba(7, 16, 36, 0.95); backdrop-filter: blur(8px); }
        .overlay h2 { font-size: 2.5rem; margin-bottom: 20px; color: var(--white); }

        /* MENU LATERAL */
        #drawer-toggle {
            position: absolute; top: 15px; left: 15px; font-size: 2rem;
            cursor: pointer; z-index: 100; color: var(--white);
            width: 40px; height: 40px; text-align: center; line-height: 40px;
            background: rgba(0,0,0,0.2); border-radius: 8px; display: block; 
        }
        #drawer-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 101; display: none; opacity: 0; transition: opacity 0.3s;
        }
        #drawer-overlay.visible { display: block; opacity: 1; }
        #drawer {
            position: fixed; top: 0; left: -320px; width: 280px; height: 100%;
            background: var(--panel-dark); border-right: 2px solid var(--blue-600);
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 102;
            padding: 20px; overflow-y: auto; box-shadow: 5px 0 15px rgba(0,0,0,0.5);
            display: flex; flex-direction: column;
        }
        #drawer.open { left: 0; }
        .drawer-top-bar {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; border-bottom: 1px solid var(--blue-700); padding-bottom: 10px;
        }
        .drawer-close-btn { font-size: 1.5rem; cursor: pointer; color: var(--accent-red); font-weight: bold; padding: 5px 10px; }
        .drawer-section { margin-bottom: 25px; border-bottom: 1px solid var(--blue-700); padding-bottom: 15px; }
        .drawer-header { font-size: 1.1rem; margin-bottom: 15px; color: var(--accent-green); font-weight: bold; letter-spacing: 1px;}
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        input[type="checkbox"] { transform: scale(1.3); accent-color: var(--accent-green); }
        input[type="range"] { width: 100%; accent-color: var(--accent-green); }
        
        .level-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .lvl-btn {
            background: var(--blue-700); border: 1px solid var(--blue-600);
            color: white; padding: 10px 0; border-radius: 4px; cursor: pointer;
            font-size: 0.9rem; text-align: center;
        }
        .lvl-btn:disabled { opacity: 0.3; cursor: not-allowed; border: none; }
        .lvl-btn.unlocked { background: var(--blue-600); border-color: var(--accent-green); color: var(--white); font-weight: bold; }
        .lvl-btn.completed { background: var(--accent-green); color: var(--blue-900); }

        #next-canvas { width: 40px; height: 40px; margin: 0 auto; display: block; }

    </style>
</head>
<body>

    <div class="bg-pattern"></div>
    <canvas id="bg-canvas"></canvas>

    <div id="drawer-toggle">☰</div>
    <div id="drawer-overlay"></div>

    <aside id="drawer">
        <div class="drawer-top-bar">
            <span style="font-weight:900; font-size:1.2rem;">MENU</span>
            <div class="drawer-close-btn" id="drawer-close">✕</div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">AJUSTES</div>
            <div class="setting-row">
                <span>Música</span>
                <input type="checkbox" id="toggle-music" checked>
            </div>
            <div class="setting-row">
                <span>Efectos (SFX)</span>
                <input type="checkbox" id="toggle-sfx" checked>
            </div>
            <div class="setting-row">
                <span>Vibración</span>
                <input type="checkbox" id="toggle-haptics" checked>
            </div>
            <div class="setting-row">
                <span>Pieza Fantasma</span>
                <input type="checkbox" id="toggle-ghost" checked>
            </div>
            <div class="setting-row" style="flex-direction:column; align-items:flex-start;">
                <div style="display:flex; justify-content:space-between; width:100%">
                    <span>Sensibilidad</span>
                    <span id="sens-val" style="color:var(--accent-green)">5</span>
                </div>
                <input type="range" id="slider-sens" min="1" max="10" value="5" style="margin-top:8px;">
            </div>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">CONTROLES</div>
            <p style="font-size:0.85rem; color:#ccc; line-height:1.6;">
                <strong>Tap:</strong> Rotar<br>
                <strong>Deslizar ↔:</strong> Mover (1:1)<br>
                <strong>Deslizar ↓:</strong> Suave<br>
                <strong>Swipe Rápido ↓:</strong> Hard Drop<br>
            </p>
        </div>

        <div class="drawer-section">
            <div class="drawer-header">NIVELES</div>
            <div class="level-grid" id="level-grid"></div>
        </div>
    </aside>

    <div id="game-container">
        <div id="screen-start" class="screen active">
            <div class="title">
                <span class="t-let">T</span><span class="t-let">E</span><span class="t-let">T</span><span class="t-let">R</span><span class="t-let">I</span><span class="t-let">S</span>
            </div>
            <button id="btn-start" class="btn btn-green pulse">JUGAR NIVEL 1</button>
            <a href="../index.html" class="btn btn-red">SALIR</a>
        </div>

        <div id="screen-game" class="screen">
            <div id="game-ui">
                <div class="hud-top">
                    <div class="hud-box">
                        <div class="hud-label">MOVS</div>
                        <div class="hud-value" id="hud-moves">0</div>
                    </div>
                    <div class="hud-box" style="flex:2;">
                        <div class="hud-label" id="hud-obj-label">OBJETIVO</div>
                        <div class="hud-value" id="hud-obj-val">--</div>
                    </div>
                    <div class="hud-box">
                        <div class="hud-label">SIG</div>
                        <canvas id="next-canvas" width="60" height="60"></canvas>
                    </div>
                </div>
                <div id="btn-pause">||</div>
            </div>
            <canvas id="tetris-canvas"></canvas>
        </div>

        <div id="screen-pause" class="screen overlay">
            <h2>EN PAUSA</h2>
            <button id="btn-resume" class="btn btn-green">CONTINUAR</button>
            <button id="btn-quit-level" class="btn btn-orange">SALIR AL MENÚ</button>
        </div>

        <div id="screen-gameover" class="screen overlay">
            <h2 style="color:var(--accent-red)">GAME OVER</h2>
            <p id="go-reason" style="margin-bottom:20px; color:#ccc; font-size:1.1rem;">Inténtalo de nuevo</p>
            <button id="btn-retry" class="btn btn-green">REINTENTAR</button>
            <button id="btn-go-menu" class="btn btn-red">MENÚ PRINCIPAL</button>
        </div>

        <div id="screen-win" class="screen overlay">
            <h2 style="color:var(--accent-green)">¡NIVEL COMPLETADO!</h2>
            <div style="text-align:center; margin-bottom:20px;">
                <p style="font-size:1.2rem;">Puntuación: <span id="win-score" style="font-weight:bold;">0</span></p>
                <p style="color:#fbbf24;">Monedas ganadas: +<span id="win-coins">0</span></p>
            </div>
            <button id="btn-next-level" class="btn btn-green">SIGUIENTE NIVEL</button>
            <button id="btn-win-menu" class="btn btn-orange">MENÚ</button>
        </div>
    </div>

    <audio id="bg-music" src="../assets/music/arcade.mp3" loop></audio>

    <script>
        const CONFIG = {
            GRID_W: 10, GRID_H: 20, CELL_SIZE: 30, 
            STORAGE_KEY: "tetris_progress_v2", SETTINGS_KEY: "tetris_settings_v2",
            DROP_INTERVAL: 1000
        };

        const COLORS = {
            I: "#00f0f0", J: "#0000f0", L: "#f0a000", O: "#f0f000",
            S: "#00f000", T: "#a000f0", Z: "#f00000",
            GHOST: "rgba(255, 255, 255, 0.15)", GRID: "#12385A",
            BG_DARK: "#071024", BG_LIGHT: "#0B2A47"
        };

        const SHAPES = {
            I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
            J: [[1,0,0], [1,1,1], [0,0,0]],
            L: [[0,0,1], [1,1,1], [0,0,0]],
            O: [[1,1], [1,1]],
            S: [[0,1,1], [1,1,0], [0,0,0]],
            T: [[0,1,0], [1,1,1], [0,0,0]],
            Z: [[1,1,0], [0,1,1], [0,0,0]]
        };
        const SHAPE_KEYS = Object.keys(SHAPES);

        const LEVELS = [
            { id:1,  name:"Nivel 1", obj:{type:"lines", val:5},   moves:50,  coins:5 }, 
            { id:2,  name:"Nivel 2", obj:{type:"points", val:2000}, moves:60,  coins:10 },
            { id:3,  name:"Nivel 3", obj:{type:"lines", val:10},  moves:70,  coins:15 },
            { id:4,  name:"Nivel 4", obj:{type:"points", val:5000}, moves:80, coins:20 },
            { id:5,  name:"Nivel 5", obj:{type:"lines", val:15},  moves:90, coins:25 },
            { id:6,  name:"Nivel 6", obj:{type:"points", val:10000}, moves:100, coins:30 },
            { id:7,  name:"Nivel 7", obj:{type:"lines", val:20},  moves:110, coins:40 },
            { id:8,  name:"Nivel 8", obj:{type:"points", val:20000}, moves:120, coins:50 },
            { id:9,  name:"Nivel 9", obj:{type:"lines", val:30},  moves:140, coins:75 },
            { id:10, name:"MAESTRO", obj:{type:"lines", val:40},  moves:160, coins:100 }
        ];

        let canvas, ctx, nextCanvas, nextCtx, bgCanvas, bgCtx;
        
        let lastTime = 0;
        let dropCounter = 0;
        let currentLevelIdx = 0;
        
        let isPaused = false;
        let gameActive = false;
        
        let grid = [];
        let player = { matrix: null, pos: {x:0, y:0}, type: null, score: 0, lines: 0, movesLeft: 0, objRemaining: 0 };
        let nextPieceType = null;
        let particles = [];
        
        let settings = { music: true, sfx: true, ghost: true, touchSens: 5, haptics: true };
        let progress = { unlocked: [1], coins: 0, scores: {}, rewardsClaimed: [] };

        let audioCtx = null;
        let gainMaster = null;

        window.onload = () => {
            initDOM();
            loadStorage();
            initAudioSystem();
            initBgAnimation();
            resize();
            window.addEventListener('resize', resize);
            renderMenuLevels();
        };

        function initDOM() {
            canvas = document.getElementById('tetris-canvas');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('next-canvas');
            nextCtx = nextCanvas.getContext('2d');
            
            document.getElementById('drawer-toggle').onclick = toggleDrawer;
            document.getElementById('drawer-close').onclick = toggleDrawer;
            document.getElementById('drawer-overlay').onclick = toggleDrawer;

            document.getElementById('btn-start').onclick = () => startGame(currentLevelIdx);
            
            document.getElementById('btn-pause').onclick = togglePause;
            document.getElementById('btn-resume').onclick = togglePause;
            document.getElementById('btn-quit-level').onclick = showMainMenu;
            
            document.getElementById('btn-retry').onclick = () => startGame(currentLevelIdx);
            document.getElementById('btn-go-menu').onclick = showMainMenu;
            
            document.getElementById('btn-next-level').onclick = () => {
                if(currentLevelIdx < LEVELS.length -1) startGame(currentLevelIdx + 1);
                else showMainMenu();
            };
            document.getElementById('btn-win-menu').onclick = showMainMenu;

            document.getElementById('toggle-music').onchange = (e) => { settings.music = e.target.checked; updateMusicState(); saveSettings(); };
            document.getElementById('toggle-sfx').onchange = (e) => { settings.sfx = e.target.checked; saveSettings(); };
            document.getElementById('toggle-ghost').onchange = (e) => { settings.ghost = e.target.checked; saveSettings(); };
            document.getElementById('toggle-haptics').onchange = (e) => { settings.haptics = e.target.checked; saveSettings(); };
            
            const slider = document.getElementById('slider-sens');
            slider.oninput = (e) => {
                settings.touchSens = parseInt(e.target.value);
                document.getElementById('sens-val').innerText = settings.touchSens;
                saveSettings();
            };
            
            document.addEventListener('keydown', handleKey);
            setupTouch(canvas);
            document.body.addEventListener('click', enableAudioGlobal, { once: true });
            document.body.addEventListener('touchstart', enableAudioGlobal, { once: true });
        }

        function enableAudioGlobal() {
            if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            updateMusicState();
        }

        function loadStorage() {
            const savedSet = localStorage.getItem(CONFIG.SETTINGS_KEY);
            if(savedSet) {
                settings = Object.assign(settings, JSON.parse(savedSet));
                document.getElementById('toggle-music').checked = settings.music;
                document.getElementById('toggle-sfx').checked = settings.sfx;
                document.getElementById('toggle-ghost').checked = settings.ghost;
                document.getElementById('toggle-haptics').checked = settings.haptics;
                document.getElementById('slider-sens').value = settings.touchSens;
                document.getElementById('sens-val').innerText = settings.touchSens;
            }
            const savedProg = localStorage.getItem(CONFIG.STORAGE_KEY);
            if(savedProg) progress = Object.assign(progress, JSON.parse(savedProg));

            const maxUnlocked = Math.max(...progress.unlocked);
            const nextLvl = LEVELS.find(l => l.id === maxUnlocked);
            if(nextLvl) {
                currentLevelIdx = LEVELS.indexOf(nextLvl);
                document.getElementById('btn-start').innerText = "JUGAR " + nextLvl.name;
            }
        }

        function saveSettings() { localStorage.setItem(CONFIG.SETTINGS_KEY, JSON.stringify(settings)); }
        function saveProgress() { localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(progress)); }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const containerH = window.innerHeight;
            const containerW = window.innerWidth;
            
            let cellSize = Math.floor((containerH * 0.75) / CONFIG.GRID_H);
            if(cellSize * CONFIG.GRID_W > containerW * 0.9) cellSize = Math.floor((containerW * 0.9) / CONFIG.GRID_W);
            CONFIG.CELL_SIZE = cellSize;

            const w = CONFIG.GRID_W * CONFIG.CELL_SIZE;
            const h = CONFIG.GRID_H * CONFIG.CELL_SIZE;

            canvas.width = w * dpr; canvas.height = h * dpr;
            canvas.style.width = w + "px"; canvas.style.height = h + "px";
            ctx.resetTransform(); ctx.scale(dpr, dpr);

            const bgC = document.getElementById('bg-canvas');
            bgC.width = containerW * dpr; bgC.height = containerH * dpr;
            bgC.style.width = containerW + "px"; bgC.style.height = containerH + "px";
            const bgCtx = bgC.getContext('2d');
            bgCtx.scale(dpr, dpr);
            
            if(!gameActive) draw(); 
        }

        function draw() {
            ctx.fillStyle = COLORS.BG_DARK;
            ctx.fillRect(0, 0, CONFIG.GRID_W*CONFIG.CELL_SIZE, CONFIG.GRID_H*CONFIG.CELL_SIZE);

            for(let y=0; y<CONFIG.GRID_H; y++) {
                for(let x=0; x<CONFIG.GRID_W; x++) {
                    if((x+y)%2===0) {
                        ctx.fillStyle = COLORS.BG_LIGHT;
                        ctx.fillRect(x*CONFIG.CELL_SIZE, y*CONFIG.CELL_SIZE, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
                    }
                }
            }

            drawMatrix(grid, {x:0, y:0});

            if(gameActive && !isPaused && player.matrix) {
                if(settings.ghost) {
                    const ghostPos = { ...player.pos };
                    while(!collide(grid, {matrix:player.matrix, pos:ghostPos})) ghostPos.y++;
                    ghostPos.y--;
                    ctx.globalAlpha = 0.3;
                    drawMatrix(player.matrix, ghostPos, true);
                    ctx.globalAlpha = 1.0;
                }
                drawMatrix(player.matrix, player.pos);
            }

            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1.0;
        }

        function drawMatrix(matrix, offset, isGhost = false) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const drawX = (x + offset.x) * CONFIG.CELL_SIZE;
                        const drawY = (y + offset.y) * CONFIG.CELL_SIZE;
                        if(isGhost) {
                            ctx.strokeStyle = COLORS[value]; ctx.lineWidth = 1.5;
                            ctx.strokeRect(drawX+1, drawY+1, CONFIG.CELL_SIZE-2, CONFIG.CELL_SIZE-2);
                        } else {
                            ctx.fillStyle = COLORS[value];
                            ctx.fillRect(drawX+1, drawY+1, CONFIG.CELL_SIZE-2, CONFIG.CELL_SIZE-2);
                            ctx.fillStyle = "rgba(255,255,255,0.3)";
                            ctx.fillRect(drawX+1, drawY+1, CONFIG.CELL_SIZE-2, CONFIG.CELL_SIZE*0.2);
                        }
                    }
                });
            });
        }
        
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            if(!nextPieceType) return;
            const matrix = SHAPES[nextPieceType];
            const boxSize = 10;
            const w = matrix[0].length * boxSize;
            const h = matrix.length * boxSize;
            const offX = (nextCanvas.width - w) / 2;
            const offY = (nextCanvas.height - h) / 2;
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if(val) {
                        nextCtx.fillStyle = COLORS[nextPieceType];
                        nextCtx.fillRect(offX + x*boxSize, offY + y*boxSize, boxSize-1, boxSize-1);
                    }
                });
            });
        }

        function startGame(levelIndex) {
            currentLevelIdx = levelIndex;
            const lvlData = LEVELS[currentLevelIdx];
            grid = createGrid(CONFIG.GRID_W, CONFIG.GRID_H);
            player = {
                matrix: null, pos: {x:0, y:0}, type: null,
                score: 0, lines: 0,
                movesLeft: lvlData.moves,
                objRemaining: lvlData.obj.val
            };
            particles = [];
            isGameOver = false; isPaused = false; gameActive = true;
            nextPieceType = getRandomPiece();
            
            // CORRECCIÓN 2: Resetear dropCounter para evitar caídas instantáneas
            dropCounter = 0;
            
            playerReset();
            
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-game').classList.add('active');
            document.getElementById('game-ui').style.display = 'flex';
            document.getElementById('drawer-toggle').style.display = 'none';
            toggleDrawer(false);
            
            updateHUD();
            updateMusicState();
            
            lastTime = performance.now();
            requestAnimationFrame(update);
        }

        function createGrid(w, h) {
            const m = [];
            while (h--) m.push(new Array(w).fill(0));
            return m;
        }

        function update(time) {
            if(!gameActive || isPaused) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > CONFIG.DROP_INTERVAL) {
                playerDrop();
                dropCounter = 0;
            }
            
            // CORRECCIÓN 3: Aumentar límite de partículas para evitar borrado brusco en Tetris
            if(particles.length > 300) particles.splice(0, particles.length - 300);
            updateParticles(deltaTime);

            draw();
            requestAnimationFrame(update);
        }

        function updateParticles(dt) {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= dt * 0.003;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function playerReset() {
            const piece = nextPieceType;
            nextPieceType = getRandomPiece();
            drawNextPiece();
            player.matrix = JSON.parse(JSON.stringify(SHAPES[piece]));
            player.type = piece;
            player.matrix.forEach((row, y) => row.forEach((val, x) => {
                if(val!==0) player.matrix[y][x] = piece; 
            }));
            player.pos.y = 0;
            player.pos.x = (grid[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(grid, player)) gameOver("Tablero bloqueado");
        }

        function getRandomPiece() { return SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)]; }

        function playerDrop() {
            player.pos.y++;
            if (collide(grid, player)) {
                player.pos.y--;
                merge(grid, player);
                playSound('drop');
                triggerHaptic(20);
                decrementMoves();
                sweep();
                playerReset();
            }
        }
        
        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(grid, player)) {
                player.pos.x -= dir;
            } else {
                playSound('move');
                triggerHaptic(10);
            }
        }

        function playerRotate() {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix);
            while (collide(grid, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -1);
                    player.pos.x = pos;
                    return;
                }
            }
            playSound('rotate');
            triggerHaptic(15);
        }

        function rotate(matrix, dir = 1) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function collide(arena, p) {
            const m = p.matrix; const o = p.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(arena, p) {
            p.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + p.pos.y][x + p.pos.x] = value;
                });
            });
        }

        function sweep() {
            let rowCount = 0;
            outer: for (let y = grid.length -1; y > 0; --y) {
                for (let x = 0; x < grid[y].length; ++x) {
                    if (grid[y][x] === 0) continue outer;
                }
                const row = grid.splice(y, 1)[0].fill(0);
                grid.unshift(row);
                ++y;
                rowCount++;
                createExplosion(y * CONFIG.CELL_SIZE, CONFIG.GRID_W * CONFIG.CELL_SIZE);
            }
            if(rowCount > 0) {
                playSound('clear');
                triggerHaptic([30, 30, 30]);
                const points = rowCount * 1000 * rowCount;
                player.score += points;
                player.lines += rowCount;
                const lvl = LEVELS[currentLevelIdx];
                if(lvl.obj.type === 'lines') player.objRemaining -= rowCount;
                if(lvl.obj.type === 'points') player.objRemaining = lvl.obj.val - player.score;
                checkWin();
                updateHUD();
            }
        }
        
        function decrementMoves() {
            player.movesLeft--;
            updateHUD();
            if(player.movesLeft <= 0) gameOver("Sin movimientos");
        }

        function updateHUD() {
            const lvl = LEVELS[currentLevelIdx];
            document.getElementById('hud-moves').innerText = player.movesLeft;
            let val = Math.max(0, player.objRemaining);
            document.getElementById('hud-obj-val').innerText = (lvl.obj.type==='lines' ? val + " L" : val);
        }

        function createExplosion(y, width) {
            for(let i=0; i<30; i++) {
                particles.push({
                    x: Math.random() * width, y: y + Math.random() * 20,
                    vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                    life: 1.0, color: `hsl(${Math.random()*360}, 100%, 70%)`, size: Math.random() * 5 + 2
                });
            }
        }

        function checkWin() {
            if(player.objRemaining <= 0) {
                gameActive = false;
                const lvl = LEVELS[currentLevelIdx];
                const nextId = lvl.id + 1;
                let coinsWon = 0;
                if(!progress.rewardsClaimed.includes(lvl.id)) {
                    progress.rewardsClaimed.push(lvl.id);
                    progress.coins += lvl.coins;
                    coinsWon = lvl.coins;
                }
                if(!progress.unlocked.includes(nextId)) progress.unlocked.push(nextId);
                if(!progress.scores[lvl.id] || player.score > progress.scores[lvl.id]) progress.scores[lvl.id] = player.score;
                saveProgress();
                document.getElementById('win-score').innerText = player.score;
                document.getElementById('win-coins').innerText = coinsWon;
                document.getElementById('screen-win').classList.add('active');
                playSound('win');
            }
        }

        function gameOver(reason) {
            gameActive = false;
            document.getElementById('go-reason').innerText = reason;
            document.getElementById('screen-gameover').classList.add('active');
            playSound('lose');
        }

        function handleKey(event) {
            if(!gameActive || isPaused) {
                if(event.key.toLowerCase() === 'p') togglePause();
                return;
            }
            if (event.keyCode === 37) playerMove(-1);
            else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop();
            else if (event.keyCode === 38) playerRotate();
            else if (event.keyCode === 32) hardDrop();
            else if (event.key.toLowerCase() === 'p') togglePause();
        }
        
        function hardDrop() {
            while (!collide(grid, player)) player.pos.y++;
            player.pos.y--;
            merge(grid, player);
            playSound('drop');
            triggerHaptic(40);
            decrementMoves(); 
            createExplosion(player.pos.y * CONFIG.CELL_SIZE, CONFIG.GRID_W * CONFIG.CELL_SIZE);
            sweep();
            playerReset();
            dropCounter = 0;
        }

        // ============================================
        // CORRECCIÓN 1: SISTEMA TÁCTIL SEPARADO
        // ============================================
        function setupTouch(element) {
            let lastX = 0; 
            let initialX = 0;
            let initialY = 0;
            let touchAccumulatorX = 0;
            let touchStartTime = 0;

            element.addEventListener('pointerdown', e => {
                if(!gameActive || isPaused) return;
                e.preventDefault();
                // Coordenadas iniciales para detectar gestos (taps, swipes largos)
                initialX = e.clientX;
                initialY = e.clientY;
                // Coordenada relativa para arrastre
                lastX = e.clientX;
                touchAccumulatorX = 0;
                touchStartTime = Date.now();
            }, {passive:false});

            element.addEventListener('pointermove', e => {
                if(!gameActive || isPaused || initialX === 0) return;
                e.preventDefault();

                // Diferencia desde el último frame
                const dx = e.clientX - lastX;
                lastX = e.clientX; // Actualizamos para el siguiente frame

                const sens = Math.max(10, 35 - (settings.touchSens * 2.5));
                touchAccumulatorX += dx;

                // Movimiento horizontal acumulativo
                while(Math.abs(touchAccumulatorX) > sens) {
                    if(touchAccumulatorX > 0) {
                        playerMove(1);
                        touchAccumulatorX -= sens;
                    } else {
                        playerMove(-1);
                        touchAccumulatorX += sens;
                    }
                }
            });

            element.addEventListener('pointerup', e => {
                if(!gameActive || isPaused || initialX === 0) return;
                
                // Calculamos distancias totales desde el inicio del toque
                const totalDx = e.clientX - initialX;
                const totalDy = e.clientY - initialY;
                const dt = Date.now() - touchStartTime;

                // 1. Tap corto: Rotar
                if (dt < 250 && Math.abs(totalDy) < 30 && Math.abs(totalDx) < 20) {
                    playerRotate();
                }
                // 2. Swipes Verticales (Bajar o Hard Drop)
                else if (totalDy > 50 && Math.abs(totalDy) > Math.abs(totalDx) * 1.5) {
                    // Si fue muy rápido y largo -> Hard Drop
                    if (totalDy > 80 && dt < 300) {
                        hardDrop();
                    } else {
                        // Si fue lento o corto -> Drop normal
                        playerDrop();
                        dropCounter = 0; 
                    }
                }
                
                initialX = 0; 
                initialY = 0;
            });
            
            element.addEventListener('pointerleave', () => { initialX = 0; });
        }
        
        function triggerHaptic(pattern) {
            if(settings.haptics && navigator.vibrate) navigator.vibrate(pattern);
        }

        function initAudioSystem() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            gainMaster = audioCtx.createGain();
            gainMaster.connect(audioCtx.destination);
            gainMaster.gain.value = 0.4;
        }

        function playSound(type) {
            if(!settings.sfx || !audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(gainMaster);

            switch(type) {
                case 'move':
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.05);
                    osc.start(now); osc.stop(now + 0.05);
                    break;
                case 'rotate':
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(600, now + 0.08);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.08);
                    osc.start(now); osc.stop(now + 0.08);
                    break;
                case 'drop':
                    osc.type = 'square'; osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                    break;
                case 'clear':
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
                    gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'lose':
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.8);
                    gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    break;
                 case 'win':
                    [523, 659, 784, 1046].forEach((f, i) => {
                        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                        o.connect(g); g.connect(gainMaster); o.type = 'triangle'; o.frequency.value = f;
                        g.gain.setValueAtTime(0.1, now + i*0.1); g.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.3);
                        o.start(now + i*0.1); o.stop(now + i*0.1 + 0.3);
                    });
                    break;
            }
        }

        function updateMusicState() {
            const musicEl = document.getElementById('bg-music');
            if(audioCtx && audioCtx.state === 'running' && settings.music) musicEl.play().catch(()=>{});
            else musicEl.pause();
        }

        function togglePause() {
            if(!gameActive) return;
            isPaused = !isPaused;
            const pScreen = document.getElementById('screen-pause');
            if(isPaused) pScreen.classList.add('active');
            else {
                pScreen.classList.remove('active');
                lastTime = performance.now(); 
                requestAnimationFrame(update);
            }
            updateMusicState();
        }

        function showMainMenu() {
            gameActive = false;
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-start').classList.add('active');
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('drawer-toggle').style.display = 'block';
            loadStorage();
            renderMenuLevels();
        }

        function toggleDrawer(forceOpen = null) {
            const d = document.getElementById('drawer');
            const o = document.getElementById('drawer-overlay');
            const isOpen = d.classList.contains('open');
            if(forceOpen === false || isOpen) {
                d.classList.remove('open'); o.classList.remove('visible');
            } else {
                d.classList.add('open'); o.classList.add('visible');
            }
        }

        function renderMenuLevels() {
            const container = document.getElementById('level-grid');
            container.innerHTML = '';
            LEVELS.forEach((lvl, idx) => {
                const btn = document.createElement('div');
                const isUnlocked = progress.unlocked.includes(lvl.id);
                const isCompleted = progress.scores[lvl.id] !== undefined;
                let cls = 'lvl-btn';
                if(isUnlocked) cls += ' unlocked';
                if(isCompleted) cls += ' completed'; 
                btn.className = cls; btn.innerText = lvl.id;
                if(isUnlocked) {
                    btn.onclick = () => { startGame(idx); toggleDrawer(false); };
                } else btn.setAttribute('disabled', true);
                container.appendChild(btn);
            });
        }
        
        function initBgAnimation() {
            bgCanvas = document.getElementById('bg-canvas');
            bgCtx = bgCanvas.getContext('2d');
            const shapes = [];
            const possibleShapes = Object.values(SHAPES);
            const dpr = window.devicePixelRatio || 1;
            for(let i=0; i<30; i++) {
                shapes.push({
                    x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight,
                    speed: (0.02 + Math.random() * 0.05), scale: 1.5 + Math.random() * 1.5,
                    matrix: possibleShapes[Math.floor(Math.random()*possibleShapes.length)]
                });
            }
            function loop() {
                bgCtx.setTransform(1,0,0,1,0,0);
                bgCtx.clearRect(0,0,bgCanvas.width, bgCanvas.height);
                bgCtx.scale(dpr, dpr);
                bgCtx.fillStyle = "rgba(255,255,255,0.08)";
                shapes.forEach(s => {
                    s.x += s.speed;
                    if(s.x > window.innerWidth) s.x = -100; 
                    s.matrix.forEach((row, ry) => {
                        row.forEach((val, rx) => {
                            if(val) bgCtx.fillRect(s.x + rx * (10 * s.scale), s.y + ry * (10 * s.scale), (10 * s.scale), (10 * s.scale));
                        });
                    });
                });
                requestAnimationFrame(loop);
            }
            loop();
        }
    </script>
</body>
</html>
