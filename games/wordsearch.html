<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sopa de Letras</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* --- 1. VARIABLES & RESET --- */
        :root {
            --bg-color: #0f172a;       
            --grid-bg: #1e293b;        
            --cell-idle: #334155;      
            --text-main: #f1f5f9;      
            --text-muted: #94a3b8;     
            --accent: #818cf8;         
            --found: #34d399;          
            --hint: #fbbf24;           
            --secret: #d8b4fe;         
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overscroll-behavior: none; 
        }

        /* --- 2. HEADER Y MENÚ (ÁREA DE TOQUE MEJORADA) --- */
        .header {
            width: 100%;
            max-width: 500px;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 23, 42, 0.98);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .btn-nav {
            background: rgba(255,255,255,0.05);
            color: var(--text-muted);
            text-decoration: none;
            padding: 10px 14px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .level-control-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .btn-menu-toggle {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 16px; /* Área de toque generosa */
            border-radius: 10px;
            transition: all 0.2s ease;
        }

        .btn-menu-toggle:active {
            background: rgba(129, 140, 248, 0.2);
            transform: scale(0.96);
        }

        #lvl-display {
            font-weight: 700;
            color: var(--accent);
            font-size: 1.05rem;
            pointer-events: none;
        }

        .level-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            width: 240px;
            background: var(--grid-bg);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 6px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
            pointer-events: none;
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            transform-origin: top right;
            max-height: 60vh;
            overflow-y: auto;
        }

        .level-dropdown.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: all;
        }

        .level-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .level-item.current { background: rgba(129, 140, 248, 0.15); color: var(--accent); font-weight: bold; }
        .level-item:hover { background: rgba(255,255,255,0.05); }

        /* --- 3. JUEGO --- */
        .game-container {
            width: 100%;
            max-width: 500px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
        }

        .grid-wrapper {
            background: var(--grid-bg);
            padding: 6px;
            border-radius: 12px;
            width: 100%;
            aspect-ratio: 1 / 1;
            touch-action: none;
        }

        .grid {
            display: grid;
            gap: 2px;
            width: 100%;
            height: 100%;
        }

        .cell {
            background: var(--cell-idle);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: clamp(14px, 5vw, 22px);
            color: var(--text-muted);
        }

        .cell.selected { background: var(--accent); color: #0f172a; border-radius: 50%; transform: scale(0.9); }
        .cell.found { background: var(--found); color: #064e3b; animation: pop 0.3s; }
        .cell.secret { background: var(--secret); color: #4c1d95; }
        .cell.hint-active { background: var(--hint); color: #000; box-shadow: 0 0 15px var(--hint); z-index: 10; transform: scale(1.1); }

        @keyframes pop { 50% { transform: scale(1.2); } }

        .word-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
        .word-tag { background: rgba(255,255,255,0.05); padding: 6px 12px; border-radius: 20px; font-size: 0.85rem; color: var(--text-muted); border: 1px solid transparent; }
        .word-tag.done { background: var(--found); color: #064e3b; opacity: 0.6; text-decoration: line-through; }

        .controls { display: grid; grid-template-columns: 1fr 2fr; gap: 12px; margin-top: auto; padding-bottom: 20px; }
        .btn-action { border: none; border-radius: 12px; padding: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .btn-reset { background: #334155; color: white; }
        .btn-hint { background: var(--hint); color: #451a03; }

        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 200; display: none; align-items: center; justify-content: center; padding: 20px; }
        .modal-box { background: #1e293b; padding: 30px; border-radius: 20px; width: 100%; max-width: 340px; text-align: center; }
        .btn-confirm { background: var(--accent); color: white; width: 100%; padding: 14px; border: none; border-radius: 10px; font-weight: bold; margin-top: 15px; }
    </style>
</head>
<body>

    <div class="header">
        <a href="../index.html" class="btn-nav"><i data-lucide="arrow-left" size="18"></i> Salir</a>
        <div class="level-control-container">
            <button class="btn-menu-toggle" onclick="game.toggleLevelMenu()">
                <span id="lvl-display">Nivel 1</span>
                <i data-lucide="chevron-down" size="20" style="color:var(--accent)"></i>
            </button>
            <div id="level-menu" class="level-dropdown"></div>
        </div>
    </div>

    <div class="game-container">
        <div class="grid-wrapper" id="grid-container">
            <div id="grid" class="grid"></div>
        </div>
        <div id="words" class="word-list"></div>
        <div class="controls">
            <button class="btn-action btn-reset" onclick="game.reset()"><i data-lucide="rotate-ccw" size="20"></i></button>
            <button class="btn-action btn-hint" onclick="game.askHint()"><i data-lucide="lightbulb" size="20"></i> Pista</button>
        </div>
    </div>

    <div id="hint-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>¿Usar Pista?</h3>
            <p>Se mostrará la primera letra de una palabra.</p>
            <button class="btn-confirm" onclick="game.confirmHint()">Confirmar (-5)</button>
            <button style="background:transparent; color:var(--text-muted); border:none; margin-top:10px;" onclick="document.getElementById('hint-modal').style.display='none'">Cerrar</button>
        </div>
    </div>

    <div id="win-modal" class="modal-overlay">
        <div class="modal-box">
            <i data-lucide="award" size="48" color="#34d399"></i>
            <h2 id="win-title">¡Excelente!</h2>
            <p id="win-msg"></p>
            <button class="btn-confirm" onclick="game.next()">Siguiente</button>
        </div>
    </div>

    <script>
        const DIRS = [
            {dr:0, dc:1}, {dr:0, dc:-1}, {dr:1, dc:0}, {dr:-1, dc:0},
            {dr:1, dc:1}, {dr:1, dc:-1}, {dr:-1, dc:1}, {dr:-1, dc:-1}
        ];

        const LEVELS = [
            { words: ["XILONEN", "RAIDEN", "SACAROSA", "LUNA"], secret: ["BESO"], msg: "Tu luz ilumina mi camino." },
            { words: ["COSPLAY", "MAR", "FLOR", "LUZ", "SOL"], secret: ["PASION"], msg: "Eres arte en movimiento." },
            { words: ["DULCE", "SUEÑO", "SOFIA", "PAZ", "AMOR"], secret: ["ETERNO"], msg: "Un sueño hecho realidad." },
            { words: ["MAVUIKA", "ANILLO", "FLORES", "MUNDO"], secret: ["SHADOW"], msg: "Conquistaste este mundo." },
            { words: ["BOCCHI", "FONDO", "AZUL", "MIEDOS"], secret: ["YEKATERINA"], msg: "Superaste todos los miedos." }
        ];

        class WordSearch {
            constructor() {
                this.size = 10;
                this.state = { lvl: 0, grid: [], found: [], coordsMap: {}, completed: [] };
                this.dom = {
                    container: document.getElementById('grid-container'),
                    grid: document.getElementById('grid'),
                    words: document.getElementById('words'),
                    lvl: document.getElementById('lvl-display'),
                    menu: document.getElementById('level-menu')
                };

                const savedLvl = localStorage.getItem('ws_lvl');
                if(savedLvl) this.state.lvl = parseInt(savedLvl);
                const savedComp = localStorage.getItem('ws_comp');
                if(savedComp) this.state.completed = JSON.parse(savedComp);

                this.input = { active: false, start: null, selection: [] };
                this.setupEvents();
                this.init();
            }

            init() {
                const data = LEVELS[this.state.lvl];
                this.state.found = [];
                this.state.coordsMap = {};
                this.dom.lvl.textContent = `Nivel ${this.state.lvl + 1}`;
                this.generate([...data.words, ...data.secret]);
                this.renderWords(data.words);
            }

            generate(wordList) {
                const words = [...wordList].sort((a,b) => b.length - a.length);
                const grid = Array(this.size).fill().map(() => Array(this.size).fill(''));
                
                if (this.backtrack(grid, words, 0)) {
                    const chars = "ABCDEFGHIJKLMNÑOPQRSTUVWXYZ";
                    for(let r=0; r<this.size; r++)
                        for(let c=0; c<this.size; c++)
                            if(grid[r][c] === '') grid[r][c] = chars[Math.floor(Math.random()*chars.length)];
                    this.state.grid = grid;
                    this.draw();
                }
            }

            backtrack(grid, words, idx) {
                if (idx === words.length) return true;
                const word = words[idx];
                const positions = [];
                for(let r=0; r<this.size; r++)
                    for(let c=0; c<this.size; c++)
                        for(const d of DIRS) positions.push({r,c,d});
                
                positions.sort(() => Math.random() - 0.5);

                for (const pos of positions) {
                    if (this.canPlace(grid, word, pos)) {
                        const added = [];
                        for(let i=0; i<word.length; i++) {
                            const rr = pos.r + i*pos.d.dr, cc = pos.c + i*pos.d.dc;
                            if(grid[rr][cc] === '') { grid[rr][cc] = word[i]; added.push({rr,cc}); }
                        }
                        this.state.coordsMap[word] = {r: pos.r, c: pos.c};
                        if (this.backtrack(grid, words, idx + 1)) return true;
                        added.forEach(p => grid[p.rr][p.cc] = '');
                    }
                }
                return false;
            }

            canPlace(grid, word, pos) {
                const lr = pos.r + (word.length-1)*pos.d.dr, lc = pos.c + (word.length-1)*pos.d.dc;
                if (lr<0 || lr>=this.size || lc<0 || lc>=this.size) return false;
                for(let i=0; i<word.length; i++) {
                    const c = grid[pos.r + i*pos.d.dr][pos.c + i*pos.d.dc];
                    if (c !== '' && c !== word[i]) return false;
                }
                return true;
            }

            draw() {
                this.dom.grid.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
                this.dom.grid.innerHTML = '';
                this.state.grid.forEach((row, r) => {
                    row.forEach((char, c) => {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.textContent = char;
                        this.dom.grid.appendChild(cell);
                    });
                });
            }

            renderWords(words) {
                this.dom.words.innerHTML = words.map(w => `<div class="word-tag" id="tag-${w}">${w}</div>`).join('');
            }

            setupEvents() {
                const container = this.dom.container;
                const handleStart = (e) => {
                    const pos = this.getPos(e);
                    if (pos) { this.input.active = true; this.input.start = pos; this.updateVisuals(pos); }
                    container.setPointerCapture(e.pointerId);
                };
                const handleMove = (e) => {
                    if (!this.input.active) return;
                    const pos = this.getPos(e);
                    if (pos) this.updateVisuals(pos);
                };
                const handleEnd = () => {
                    if (!this.input.active) return;
                    this.input.active = false;
                    const word = this.input.selection.map(c => c.textContent).join('');
                    const rev = word.split('').reverse().join('');
                    if (!this.check(word)) this.check(rev);
                    this.input.selection.forEach(c => c.classList.remove('selected'));
                };

                container.addEventListener('pointerdown', handleStart);
                container.addEventListener('pointermove', handleMove);
                container.addEventListener('pointerup', handleEnd);
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.level-control-container')) this.dom.menu.classList.remove('active');
                });
            }

            getPos(e) {
                const rect = this.dom.grid.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                if (x<0 || x>rect.width || y<0 || y>rect.height) return null;
                return { r: Math.floor(y/(rect.height/this.size)), c: Math.floor(x/(rect.width/this.size)) };
            }

            updateVisuals(curr) {
                this.input.selection.forEach(c => c.classList.remove('selected'));
                this.input.selection = [];
                const start = this.input.start;
                const dr = curr.r - start.r, dc = curr.c - start.c;
                if (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) {
                    const steps = Math.max(Math.abs(dr), Math.abs(dc));
                    const ir = steps === 0 ? 0 : dr/steps, ic = steps === 0 ? 0 : dc/steps;
                    for (let i=0; i<=steps; i++) {
                        const cell = this.dom.grid.children[Math.round(start.r + i*ir) * this.size + Math.round(start.c + i*ic)];
                        cell.classList.add('selected');
                        this.input.selection.push(cell);
                    }
                }
            }

            check(word) {
                const data = LEVELS[this.state.lvl];
                if (data.words.includes(word) && !this.state.found.includes(word)) {
                    this.state.found.push(word);
                    document.getElementById(`tag-${word}`).classList.add('done');
                    this.input.selection.forEach(c => c.classList.add('found'));
                    if (this.state.found.length === data.words.length) setTimeout(() => this.win(), 300);
                    return true;
                }
                if (data.secret.includes(word)) {
                    this.input.selection.forEach(c => c.classList.add('secret'));
                    alert("¡Secreto!"); return true;
                }
                return false;
            }

            toggleLevelMenu() {
                const menu = this.dom.menu;
                if (menu.classList.contains('active')) return menu.classList.remove('active');
                menu.innerHTML = LEVELS.map((_, i) => `
                    <div class="level-item ${i === this.state.lvl ? 'current' : ''}" onclick="game.loadLevel(${i})">
                        <span>Nivel ${i + 1}</span>
                        ${this.state.completed.includes(i) ? '<i data-lucide="check" size="16"></i>' : ''}
                    </div>
                `).join('');
                menu.classList.add('active');
                lucide.createIcons();
            }

            loadLevel(i) { this.state.lvl = i; localStorage.setItem('ws_lvl', i); this.dom.menu.classList.remove('active'); this.init(); }
            
            win() {
                if (!this.state.completed.includes(this.state.lvl)) {
                    this.state.completed.push(this.state.lvl);
                    localStorage.setItem('ws_comp', JSON.stringify(this.state.completed));
                }
                document.getElementById('win-msg').textContent = LEVELS[this.state.lvl].msg;
                document.getElementById('win-modal').style.display = 'flex';
            }

            next() { this.state.lvl = (this.state.lvl + 1) % LEVELS.length; document.getElementById('win-modal').style.display = 'none'; this.init(); }
            
            askHint() { document.getElementById('hint-modal').style.display = 'flex'; }
            confirmHint() {
                document.getElementById('hint-modal').style.display = 'none';
                const missing = LEVELS[this.state.lvl].words.find(w => !this.state.found.includes(w));
                if (missing) {
                    const pos = this.state.coordsMap[missing];
                    const cell = this.dom.grid.children[pos.r * this.size + pos.c];
                    cell.classList.add('hint-active');
                    setTimeout(() => cell.classList.remove('hint-active'), 2000);
                }
            }
            reset() { if(confirm("¿Reiniciar?")) this.init(); }
        }

        window.onload = () => { lucide.createIcons(); window.game = new WordSearch(); };
    </script>
</body>
</html>
