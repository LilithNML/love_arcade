<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Laberinto</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-deep: #020617;
            --wall: #1e293b;
            --wall-glow: #334155;
            --path: #0f172a;
            --path-visited: #172554; /* Color rastro */
            --player: #38bdf8;
            --goal: #fbbf24;
            --ui-glass: rgba(255, 255, 255, 0.1);
        }

        /* RESET & BASE */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-deep);
            color: white; font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden; touch-action: none;
            display: flex; flex-direction: column; height: 100vh; width: 100vw;
        }

        /* UI SUPERIOR */
        .top-hud {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 15px; display: flex; justify-content: space-between;
            pointer-events: none; z-index: 20;
        }
        .btn-glass {
            background: var(--ui-glass); backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1); color: white;
            padding: 8px 16px; border-radius: 20px; text-decoration: none;
            display: flex; align-items: center; gap: 6px; font-weight: 600; font-size: 14px;
            pointer-events: auto; cursor: pointer; transition: 0.2s;
        }
        .btn-glass:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }
        .lvl-badge { background: var(--player); color: #000; font-weight: 800; border:none; box-shadow: 0 0 10px rgba(56, 189, 248, 0.4); }

        /* AREA DE JUEGO */
        #game-viewport {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; background: var(--bg-deep);
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* TUTORIAL OVERLAY */
        #tutorial {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 50; pointer-events: none;
            animation: fadeOut 0.5s ease 4s forwards;
            text-align: center;
        }
        .tut-hand { animation: swipeAnim 2s infinite; opacity: 0.8; }
        @keyframes swipeAnim { 
            0% { transform: translateY(20px); opacity: 0; } 
            50% { transform: translateY(-20px); opacity: 1; } 
            100% { transform: translateY(-40px); opacity: 0; } 
        }

        /* INPUT ZONES */
        .input-zone-left { position: absolute; top: 0; left: 0; bottom: 0; width: 50%; z-index: 10; }
        .input-zone-right { position: absolute; top: 0; right: 0; bottom: 0; width: 50%; z-index: 10; }
        
        .nipple-base {
            position: absolute; width: 100px; height: 100px;
            border-radius: 50%; background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            display: none; pointer-events: none;
            transform: translate(-50%, -50%); z-index: 15;
        }
        .nipple-stick {
            position: absolute; width: 40px; height: 40px;
            border-radius: 50%; background: var(--player);
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 15px var(--player);
        }

        /* MODALES */
        .modal-overlay {
            position: fixed; inset: 0; z-index: 100;
            background: rgba(2,6,23,0.95);
            display: none; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-box {
            background: #1e293b; padding: 30px; border-radius: 24px;
            text-align: center; max-width: 350px; width: 90%;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .modal-box h2 { color: var(--player); font-size: 2rem; margin: 0 0 10px 0; }
        .btn-primary {
            background: var(--player); color: #000; border: none;
            padding: 15px 30px; border-radius: 50px; font-weight: bold; font-size: 1.1rem;
            width: 100%; margin-top: 20px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(56, 189, 248, 0.3);
            transition: transform 0.1s;
        }
        .btn-primary:active { transform: scale(0.98); }

        @keyframes fadeOut { to { opacity: 0; visibility: hidden; } }
    </style>
</head>
<body>

    <div class="top-hud">
        <a href="../index.html" class="btn-glass">
            <i data-lucide="arrow-left" size="16"></i> Salir
        </a>
        <div class="btn-glass lvl-badge" id="lvl-display">NV 1</div>
    </div>

    <div id="game-viewport">
        <canvas id="canvas"></canvas>
    </div>

    <div id="tutorial">
        <i data-lucide="hand" size="64" color="white" class="tut-hand"></i>
        <p style="margin-top:20px; font-weight:bold; font-size: 1.2rem; text-shadow:0 2px 4px black;">Controles</p>
        <p style="font-size:0.9rem; opacity:0.8; line-height: 1.5;">
            Móvil: Desliza o usa Joystick Virtual<br>
            PC: Flechas o WASD
        </p>
    </div>

    <div class="input-zone-left" id="zone-joy"></div>
    <div class="input-zone-right" id="zone-swipe"></div>

    <div class="nipple-base" id="joy-ui">
        <div class="nipple-stick" id="joy-stick"></div>
    </div>

    <div id="win-modal" class="modal-overlay">
        <div class="modal-box">
            <i data-lucide="trophy" size="60" color="#fbbf24" style="margin-bottom:15px"></i>
            <h2>¡Victoria!</h2>
            <p id="win-msg" style="color:#94a3b8; font-size: 1.1rem;">Nivel Completado</p>
            <button class="btn-primary" onclick="game.nextLevel()">Siguiente Nivel</button>
        </div>
    </div>

    <div id="loading-modal" class="modal-overlay" style="background:black;">
        <div style="color:var(--player); font-family:monospace; display:flex; flex-direction:column; align-items:center;">
            <i data-lucide="loader" class="animate-spin" style="margin-bottom:15px;" size="40"></i>
            GENERANDO LABERINTO...
        </div>
    </div>

    <script src="../js/app.js"></script>

    <script>
        // CONFIGURACIÓN AJUSTADA: Balance entre reto y posibilidad técnica
        const LEVEL_CONFIG = {
            1:  { size: 9,  minSteps: 10 },
            5:  { size: 15, minSteps: 40 },
            10: { size: 21, minSteps: 80 },
            12: { size: 25, minSteps: 100 }, 
            13: { size: 29, minSteps: 120 }, 
            14: { size: 31, minSteps: 150 },
            15: { size: 35, minSteps: 180 } // Reducido de 230 para evitar crash
        };
        const MAX_LEVEL = 15;

        // --- SISTEMA DE AUDIO (Optimizado) ---
        let audioCtx = null;
        
        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) audioCtx = new AudioContext();
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if(type === 'step') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.08);
                gain.gain.setValueAtTime(0.03, now); // Volumen bajo para no molestar
                gain.gain.linearRampToValueAtTime(0, now + 0.08);
                osc.start(now); osc.stop(now + 0.08);
            } else if (type === 'win') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                osc.frequency.setValueAtTime(600, now + 0.1);
                osc.frequency.linearRampToValueAtTime(900, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);
                osc.start(now); osc.stop(now + 0.6);
            }
        }

        // --- MOTOR DEL JUEGO ---
        class MazeGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = { lvl: 1, p: {x:0,y:0}, g: {x:0,y:0}, active: false };
                
                this.grid = []; 
                this.cam = { x: 0, y: 0, zoom: 1 };
                this.drawP = { x: 0, y: 0 }; 
                this.cellSize = 40; 
                this.visited = new Set(); // Nuevo: Rastro

                const saved = localStorage.getItem('maze_pro_v2');
                if(saved) {
                    const parsed = parseInt(saved);
                    if(!isNaN(parsed)) this.state.lvl = parsed;
                }

                this.setupInputs();
                window.addEventListener('resize', () => this.resize());
                
                // Iniciar juego
                this.initLevel();
                
                // Loop de renderizado
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            async initLevel() {
                if(this.state.lvl > MAX_LEVEL) { 
                    alert("¡Juego Completado! Reiniciando..."); 
                    this.state.lvl = 1; 
                }
                
                const loader = document.getElementById('loading-modal');
                loader.style.display = 'flex';
                this.state.active = false;
                
                // Timeout para permitir que la UI del loader se renderice
                setTimeout(() => {
                    // Configuración dinámica por nivel (fórmula de respaldo)
                    const fallbackSize = 9 + Math.floor(this.state.lvl * 1.5);
                    const cfg = LEVEL_CONFIG[this.state.lvl] || { size: fallbackSize, minSteps: fallbackSize * 2 };
                    
                    document.getElementById('lvl-display').innerText = `NV ${this.state.lvl}`;
                    
                    // --- GENERACIÓN ROBUSTA (Anti-Crash) ---
                    let bestGrid = null;
                    let bestLength = 0;
                    let attempts = 0;
                    const MAX_ATTEMPTS = 50; // Límite de seguridad

                    while(attempts < MAX_ATTEMPTS) {
                        attempts++;
                        let tempGrid = this.generateMaze(cfg.size);
                        // Resolver para verificar dificultad
                        const sol = this.solveAStar({x:0,y:0}, {x:cfg.size-1, y:cfg.size-1}, tempGrid);
                        
                        if(sol) {
                            // Si cumple el requisito MÍNIMO, lo usamos
                            if(sol.length >= cfg.minSteps) {
                                bestGrid = tempGrid;
                                break; // Éxito
                            }
                            // Si no cumple, guardamos el mejor encontrado por si acaso
                            if(sol.length > bestLength) {
                                bestLength = sol.length;
                                bestGrid = tempGrid;
                            }
                        }
                    }

                    // Usar el mejor encontrado (aunque sea un poco más fácil) para no trabar el juego
                    this.grid = bestGrid; 
                    
                    this.state.p = {x:0, y:0};
                    this.state.g = {x:cfg.size-1, y:cfg.size-1};
                    this.state.active = true;
                    this.drawP = { ...this.state.p };
                    this.visited = new Set(); // Reiniciar rastro
                    this.visited.add(`0,0`);

                    this.resize();
                    
                    loader.style.display = 'none';
                    if(this.state.lvl > 1) document.getElementById('tutorial').style.display = 'none';
                    
                }, 50);
            }

            generateMaze(size) {
                let grid = Array(size).fill().map((_,y) => Array(size).fill().map((_,x) => ({x,y, w:{t:1,r:1,b:1,l:1}, v:false})));
                let stack = [grid[0][0]];
                grid[0][0].v = true;

                while(stack.length) {
                    // Algoritmo: Recursive Backtracker (modificado para ser menos lineal a veces)
                    let currIdx = stack.length - 1;
                    if(Math.random() > 0.85) currIdx = Math.floor(Math.random() * stack.length);
                    
                    let curr = stack[currIdx];
                    let neighbors = [[0,-1,'t','b'],[1,0,'r','l'],[0,1,'b','t'],[-1,0,'l','r']]
                        .map(d => ({x:curr.x+d[0], y:curr.y+d[1], w1:d[2], w2:d[3]}))
                        .filter(p => p.x>=0 && p.x<size && p.y>=0 && p.y<size && !grid[p.y][p.x].v);

                    if(neighbors.length) {
                        let nInfo = neighbors[Math.floor(Math.random() * neighbors.length)];
                        let next = grid[nInfo.y][nInfo.x];
                        curr.w[nInfo.w1] = 0; next.w[nInfo.w2] = 0; next.v = true;
                        stack.push(next);
                    } else {
                        stack.splice(currIdx, 1);
                    }
                }
                
                // Añadir bucles extra en niveles altos para complejidad
                if(this.state.lvl > 8) {
                    const loops = Math.floor(size / 3);
                    for(let i=0; i<loops; i++) {
                        let rx = Math.floor(Math.random()*(size-2))+1;
                        let ry = Math.floor(Math.random()*(size-2))+1;
                        let walls = ['t','r','b','l'];
                        grid[ry][rx].w[walls[Math.floor(Math.random()*4)]] = 0;
                    }
                }

                return grid;
            }

            solveAStar(start, end, gridRef) {
                // Versión simplificada para validación rápida
                const grid = gridRef;
                let q = [{...start, dist:0}];
                let visited = new Set();
                visited.add(`${start.x},${start.y}`);
                
                // BFS es suficiente para encontrar distancia en laberintos no ponderados
                // Usamos BFS aquí por rendimiento en la fase de generación
                let maxIter = 5000;
                
                while(q.length && maxIter-- > 0) {
                    let curr = q.shift();
                    if(curr.x === end.x && curr.y === end.y) return { length: curr.dist }; // Mock object

                    const cell = grid[curr.y][curr.x];
                    const dirs = [[0,-1,'t'],[1,0,'r'],[0,1,'b'],[-1,0,'l']];
                    for(let d of dirs) {
                        if(!cell.w[d[2]]) {
                            let nx = curr.x+d[0], ny = curr.y+d[1];
                            let key = `${nx},${ny}`;
                            if(!visited.has(key)) {
                                visited.add(key);
                                q.push({x:nx, y:ny, dist: curr.dist + 1});
                            }
                        }
                    }
                }
                return null;
            }

            setupInputs() {
                // --- JOYSTICK ---
                const joyZone = document.getElementById('zone-joy');
                const uiBase = document.getElementById('joy-ui');
                const uiStick = document.getElementById('joy-stick');
                let startX, startY, active = false;

                const handleJoyStart = (cx, cy) => {
                    initAudio(); 
                    active = true;
                    startX = cx; startY = cy;
                    uiBase.style.display = 'block';
                    uiBase.style.left = startX + 'px'; uiBase.style.top = startY + 'px';
                    uiStick.style.transform = `translate(-50%, -50%)`;
                };

                joyZone.addEventListener('touchstart', e => { e.preventDefault(); handleJoyStart(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
                joyZone.addEventListener('mousedown', e => { handleJoyStart(e.clientX, e.clientY); });

                const handleJoyMove = (cx, cy) => {
                    if(!active) return;
                    const dx = cx - startX;
                    const dy = cy - startY;
                    const dist = Math.min(40, Math.hypot(dx, dy));
                    const ang = Math.atan2(dy, dx);
                    
                    uiStick.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;

                    if(dist > 15) {
                        if(Math.abs(dx) > Math.abs(dy)) this.move(dx>0?1:-1, 0, false);
                        else this.move(0, dy>0?1:-1, false);
                    }
                };

                joyZone.addEventListener('touchmove', e => { e.preventDefault(); handleJoyMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
                window.addEventListener('mousemove', e => handleJoyMove(e.clientX, e.clientY));

                const endJoy = () => { active = false; uiBase.style.display = 'none'; };
                joyZone.addEventListener('touchend', endJoy);
                window.addEventListener('mouseup', endJoy);

                // --- SWIPE ---
                const swipeZone = document.getElementById('zone-swipe');
                let sx, sy, st;
                swipeZone.addEventListener('touchstart', e => { 
                    initAudio(); 
                    sx=e.touches[0].clientX; sy=e.touches[0].clientY; st=Date.now(); 
                }, {passive:true});
                
                swipeZone.addEventListener('touchend', e => {
                    const dx = e.changedTouches[0].clientX - sx;
                    const dy = e.changedTouches[0].clientY - sy;
                    const dt = Date.now() - st;
                    if(Math.abs(dx)<20 && Math.abs(dy)<20) return;
                    
                    const mx = Math.abs(dx)>Math.abs(dy) ? (dx>0?1:-1) : 0;
                    const my = Math.abs(dx)>Math.abs(dy) ? 0 : (dy>0?1:-1);
                    this.move(mx, my, dt < 250); // Dash si es swipe rápido
                });

                // --- TECLADO (NUEVO) ---
                window.addEventListener('keydown', (e) => {
                    if(!this.state.active) return;
                    initAudio();
                    switch(e.key) {
                        case 'ArrowUp': case 'w': this.move(0, -1, false); break;
                        case 'ArrowDown': case 's': this.move(0, 1, false); break;
                        case 'ArrowLeft': case 'a': this.move(-1, 0, false); break;
                        case 'ArrowRight': case 'd': this.move(1, 0, false); break;
                    }
                });
            }

            move(dx, dy, dash) {
                if(!this.state.active || !this.grid.length) return;
                
                // Debounce simple para evitar movimientos ultrarrápidos accidentales
                const now = Date.now();
                if(!dash && now - (this.lastMove || 0) < 120) return;
                this.lastMove = now;

                const performStep = () => {
                    const {x, y} = this.state.p;
                    if (!this.grid[y] || !this.grid[y][x]) return false;
                    
                    const c = this.grid[y][x];
                    // Chequeo de paredes
                    if(dy===-1 && c.w.t) return false;
                    if(dx===1 && c.w.r) return false;
                    if(dy===1 && c.w.b) return false;
                    if(dx===-1 && c.w.l) return false;
                    
                    this.state.p.x += dx; this.state.p.y += dy;
                    
                    // Marcar rastro (Breadcrumbs)
                    this.visited.add(`${this.state.p.x},${this.state.p.y}`);
                    
                    playSound('step');
                    
                    if(this.state.p.x === this.state.g.x && this.state.p.y === this.state.g.y) {
                        this.win();
                        return false; // Stop dash
                    }
                    return true;
                };

                if(dash) {
                    let steps = 0;
                    const iv = setInterval(() => {
                        if(!performStep() || steps++ > 50 || !this.state.active) clearInterval(iv);
                    }, 30);
                } else {
                    performStep();
                }
            }

            win() {
                if(!this.state.active) return;
                this.state.active = false;
                playSound('win');
                
                // SISTEMA ECONÓMICO (NO TOCADO - SOLO CONEXIÓN SEGURA)
                const reward = 50 + ((this.state.lvl - 1) * 10);
                let message = "Nivel Completado";

                // Verificación de seguridad por si GameCenter no existe
                if(window.GameCenter && typeof window.GameCenter.completeLevel === 'function') {
                    const r = window.GameCenter.completeLevel('maze', this.state.lvl, reward);
                    // Asumimos que r devuelve objeto con info, si no, fallback visual
                    if(r && r.paid) message = `<strong style="color:#10b981">+${reward} Monedas</strong>`;
                }
                
                document.getElementById('win-msg').innerHTML = message;
                document.getElementById('win-modal').style.display = 'flex';
            }

            nextLevel() {
                this.state.lvl++;
                localStorage.setItem('maze_pro_v2', this.state.lvl);
                document.getElementById('win-modal').style.display = 'none';
                this.initLevel();
            }

            resize() {
                const p = document.getElementById('game-viewport');
                if(!p) return;
                this.canvas.width = p.clientWidth;
                this.canvas.height = p.clientHeight;
                
                if(this.grid && this.grid.length > 0) {
                    // ZOOM INTELIGENTE: Más visión en niveles altos
                    const baseVision = window.innerWidth < 600 ? 9 : 14;
                    const levelBonus = Math.floor(this.state.lvl / 3); 
                    const visibleCells = baseVision + levelBonus;
                    
                    this.cam.zoom = this.canvas.width / (visibleCells * this.cellSize);
                }
            }

            loop() {
                // Optimización: Si no hay grid, no dibujar
                if (!this.grid || this.grid.length === 0) {
                    requestAnimationFrame(this.loop);
                    return;
                }

                // Interpolación suave de cámara
                this.drawP.x += (this.state.p.x - this.drawP.x) * 0.25;
                this.drawP.y += (this.state.p.y - this.drawP.y) * 0.25;

                const ctx = this.ctx;
                const cs = this.cellSize;
                const w = this.canvas.width;
                const h = this.canvas.height;
                const scale = this.cam.zoom || 1;

                // Centro de la cámara
                const cx = -this.drawP.x * cs * scale + w/2 - (cs*scale)/2;
                const cy = -this.drawP.y * cs * scale + h/2 - (cs*scale)/2;

                // Fondo limpio
                ctx.fillStyle = '#020617';
                ctx.fillRect(0,0,w,h);

                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(scale, scale);

                // Dibujar Celdas Visitadas (Rastro visual)
                ctx.fillStyle = '#172554'; // Azul oscuro sutil
                this.visited.forEach(key => {
                    const [vx, vy] = key.split(',').map(Number);
                    ctx.fillRect(vx*cs, vy*cs, cs, cs);
                });

                // Estilo de paredes mejorado
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                
                // Dibujar solo paredes visibles (Culling simple por rendimiento podría ir aquí, 
                // pero con canvas 2D nativo y paths agrupados es bastante rápido)
                this.grid.forEach(row => row.forEach(c => {
                    let x=c.x*cs, y=c.y*cs;
                    if(c.w.t) { ctx.moveTo(x,y); ctx.lineTo(x+cs,y); }
                    if(c.w.l) { ctx.moveTo(x,y); ctx.lineTo(x,y+cs); }
                    if(c.x===this.grid.length-1 && c.w.r) { ctx.moveTo(x+cs,y); ctx.lineTo(x+cs,y+cs); }
                    if(c.y===this.grid.length-1 && c.w.b) { ctx.moveTo(x,y+cs); ctx.lineTo(x+cs,y+cs); }
                }));
                ctx.stroke();

                // Meta (Animada)
                const time = Date.now()/300;
                const gx = this.state.g.x*cs+cs/2;
                const gy = this.state.g.y*cs+cs/2;
                
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#fbbf24'; 
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(gx, gy, cs/4 + Math.sin(time)*2, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Jugador
                ctx.fillStyle = '#38bdf8';
                ctx.beginPath();
                ctx.arc(this.drawP.x*cs+cs/2, this.drawP.y*cs+cs/2, cs/3, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
                requestAnimationFrame(this.loop);
            }
        }

        window.onload = () => {
            if(window.lucide) lucide.createIcons();
            window.game = new MazeGame();
        };
    </script>
</body>
</html>
